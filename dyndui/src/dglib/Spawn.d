/*
 * This file is part of dui.
 * 
 * dui is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 * 
 * dui is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dui; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * - automatically generated by leds
 * - pos-processed by Antonio Monteiro
 */

module dglib.Spawn;

private import def.Types;
private import def.Constants;

private import dglib.ErrorG;
private import lib.glib;

private import dglib.SpawnException;
private import dool.String;

/**
 * 
 */
public
class Spawn
{
	protected:

	public:

	/**
	 * Flags passed to gSpawnSync(), gSpawnAsync() and gSpawnAsyncWithPipes().<br>
	 * GSPAWNLEAVEDESCRIPTORSOPEN the parent's open file descriptors will be inherited by the child; otherwise all
	 * descriptors except stdin/stdout/stderr will be closed before calling exec() in the child.<br>
	 * GSPAWNDONOTREAPCHILD the child will not be automatically reaped; you must call waitpid() or handle SIGCHLD
	 * yourself, or the child will become a zombie.<br>
	 * GSPAWNSEARCHPATH argv[0] need not be an absolute path, it will be looked for in the user's PATH.<br>
	 * GSPAWNSTDOUTTODEVNULL the child's standad output will be discarded, instead of going to the same location
	 * as the parent's standard output.<br>
	 * GSPAWNSTDERRTODEVNULL the child's standard error will be discarded.<br>
	 * GSPAWNCHILDINHERITSSTDIN the child will inherit the parent's standard input (by default, the child's
	 * standard input is attached to /dev/null).<br>
	 * GSPAWNFILEANDARGVZERO the first element of argv is the file to execute, while the remaining elements are
	 * the actual argument vector to pass to the file. Normally gSpawnAsyncWithPipes() uses argv[0] as the file to
	 * execute, and passes all of argv to the child.
	 */


	/**
	 * Specifies the type of the setup function passed to gSpawnAsync(), gSpawnSync() and gSpawnAsyncWithPipes(). It
	 * is called in the child after GLib has performed all the setup it plans to perform but before calling
	 * exec(). Obviously, actions taken in this function will only affect the child, not the parent.
	 * @param userData user data to pass to the function.
	 */

	/**
	 * Executes a child program asynchronously (your program will not block waiting for the child to exit). The child
	 * program is specified by the only argument that must be provided, argv. argv should be a NULL-terminated
	 * array of strings, to be passed as the argument vector for the child. The first string in argv is of course
	 * the name of the program to execute. By default, the name of the program must be a full path; the PATH shell
	 * variable will only be searched if you pass the GSPAWNSEARCHPATH flag.<br>
	 * On Windows, the low-level child process creation API (CreateProcess())doesn't use argument vectors, but a
	 * command line. The C runtime library's spawn*() family of functions (which gSpawnAsyncWithPipes() eventually
	 * calls) paste the argument vector elements into a command line, and the C runtime startup code does a
	 * corresponding recostruction of an argument vector from the command line, to be passed to main().
	 * Complications arise when you have argument vector elements that contain spaces of double quotes. The
	 * spawn*() functions don't do any quoting or escaping, but on the other hand the startup code does do
	 * unquoting and unescaping in order to enable receiving arguments with embedded spaces or double quotes. To
	 * work around this asymmetry, gSpawnAsyncWithPipes() will do quoting and escaping on argument vector elements
	 * that need it before calling the C runtime spawn() function.<br>
	 * envp is a NULL-terminated array of strings, where each string has the form KEY=VALUE. This will become the
	 * child's environment. If envp is NULL, the child inherits its parent's environment.<br>
	 * flags should be the bitwise OR of any flags you want to affect the function's behavior. On Unix, the
	 * GSPAWNDONOTREAPCHILD means that the child will not be automatically reaped; you must call waitpid() or
	 * handle SIGCHLD yourself, or the child will become a zombie. On Windows, the flag means that a handle to the
	 * child will be returned childPid. You must call CloseHandle() on it eventually (or exit the process), or the
	 * child processs will continue to take up some table space even after its death. Quite similar to zombies on
	 * Unix, actually.<br>
	 * GSPAWNLEAVEDESCRIPTORSOPEN means that the parent's open file descriptors will be inherited by the child;
	 * otherwise all descriptors except stdin/stdout/stderr will be closed before calling exec() in the child.
	 * GSPAWNSEARCHPATH means that argv[0] need not be an absolute path, it will be looked for in the user's PATH.
	 * GSPAWNSTDOUTTODEVNULL means that the child's standard output will be discarded, instead of going to the
	 * same location as the parent's standard output. If you use this flag, standardOutput must be NULL.
	 * GSPAWNSTDERRTODEVNULL means that the child's standard error will be discarded, instead of going to the same
	 * location as the parent's standard error. If you use this flag, standardError must be NULL.
	 * GSPAWNCHILDINHERITSSTDIN means that the child will inherit the parent's standard input (by default, the
	 * child's standard input is attached to /dev/null). If you use this flag, standardInput must be NULL.
	 * GSPAWNFILEANDARGVZERO means that the first element of argv is the file to execute, while the remaining
	 * elements are the actual argument vector to pass to the file. Normally gSpawnAsyncWithPipes() uses argv[0]
	 * as the file to execute, and passes all of argv to the child.<br>
	 * childSetup and userData are a function and user data. On POSIX platforms, the function is called in the
	 * child after GLib has performed all the setup it plans to perform (including creating pipes, closing file
	 * descriptors, etc.) but before calling exec(). That is, childSetup is called just before calling exec() in
	 * the child. Obviously actions taken in this function will only affect the child, not the parent. On Windows,
	 * there is no separate fork() and exec() functionality. Child processes are created and run right away with
	 * one API call, CreateProcess(). childSetup is called in the parent process just before creating the child
	 * process. You should carefully consider what you do in childSetup if you intend your software to be portable
	 * to Windows.<br>
	 * If non-NULL, childPid will on Unix be filled with the child's process ID. You can use the process ID to
	 * send signals to the child, or to waitpid() if you specified the GSPAWNDONOTREAPCHILD flag. On Windows,
	 * childPid will be filled with a handle to the child process only if you specified the GSPAWNDONOTREAPCHILD
	 * flag. You can then access the child process using the Win32 API, for example wait for its termination with
	 * the WaitFor*() functions, or examine its exit code with GetExitCodeProcess(). You should close the handle
	 * with CloseHandle() when you no longer need it.<br>
	 * If non-NULL, the standardInput, standardOutput, standardError locations will be filled with file
	 * descriptors for writing to the child's standard input or reading from its standard output or standard
	 * error. The caller of gSpawnAsyncWithPipes() must close these file descriptors when they are no longer in
	 * use. If these parameters are NULL, the corresponding pipe won't be created.<br>
	 * If standardInput is NULL, the child's standard input is attached to /dev/null unless
	 * GSPAWNCHILDINHERITSSTDIN is set.<br>
	 * If standardError is NULL, the child's standard error goes to the same location as the parent's standard
	 * error unless GSPAWNSTDERRTODEVNULL is set.<br>
	 * If standardOutput is NULL, the child's standard output goes to the same location as the parent's standard
	 * output unless GSPAWNSTDOUTTODEVNULL is set.<br>
	 * error can be NULL to ignore errors, or non-NULL to report errors. If an error is set, the function returns
	 * FALSE. Errors are reported even if they occur in the child (for example if the executable in argv[0] is not
	 * found). Typically the message field of returned errors should be displayed to users. Possible errors are
	 * those from the GSPAWNERROR domain.<br>
	 * If an error occurs, childPid, standardInput, standardOutput, and standardError will not be filled with
	 * valid values.<br>
	 * If childPid is not NULL and an error does not occur then the returned pid must be closed using
	 * gSpawnClosePid().
	 * @param workingDirectory child's current working directory, or NULL to inherit parent's
	 * @param argv child's argument vector
	 * @param envp child's environment, or NULL to inherit parent's
	 * @param flags flags from GSpawnFlags
	 * @param childSetup function to run in the child just before exec()
	 * @param userData user data for childSetup
	 * @param childPid return location for child process ID, or NULL
	 * @param standardInput return location for file descriptor to write to child's stdin, or NULL
	 * @param standardOutput return location for file descriptor to read child's stdout, or NULL
	 * @param standardError return location for file descriptor to read child's stderr, or NULL
	 * @param error return location for error
	 * @return TRUE on success, FALSE if an error was set
	 */
	static bit asyncWithPipes(
		String  workingDirectory,
		char** argv, char** envp,
		SpawnFlags flags, 
		GSpawnChildSetupFunc child_setup,
		gpointer user_data,
		out GPid child_pid, 
		gint * standard_input = null, 
		gint * standard_output = null, 
		gint * standard_error = null)
		//ErrorG error = null)
	{
		
		ErrorG error = new ErrorG();
		bit result =  g_spawn_async_with_pipes(
			((workingDirectory is null) ? null : workingDirectory.toStringz()), 
			cast(char**)argv,
			cast(char**)envp, 
			flags, 
			child_setup,
			user_data, 
			&child_pid,
			standard_input, standard_output, standard_error,
			(error is null? null : error.getGA())
			) == 0 ? false : true;
			
			if ( error.getCode() != 0 )
			{
				error.dump();
				throw new SpawnException(error.getCode(), error.getMessage());
			}
			
			return result;
	}

	/**
	 * See gSpawnAsyncWithPipes() for a full description; this function simply calls the gSpawnAsyncWithPipes()
	 * without any pipes.
	 * @param workingDirectory child's current working directory, or NULL to inherit parent's
	 * @param argv child's argument vector
	 * @param envp child's environment, or NULL to inherit parent's
	 * @param flags flags from GSpawnFlags
	 * @param childSetup function to run in the child just before exec()
	 * @param userData user data for childSetup
	 * @param childPid return location for child process ID, or NULL
	 * @param error return location for error
	 * @return TRUE on success, FALSE if error is set
	 */
	static bit async(String working_directory, 
			char[] * argv, char[] * envp, 
			SpawnFlags flags, GSpawnChildSetupFunc child_setup, gpointer user_data, GPid * child_pid)//, ErrorG error)
	{
		ErrorG error = new ErrorG();
		bit result = g_spawn_async(
				working_directory.toStringz(), 
				cast(char**)argv, 
				cast(char**)envp,
				flags, 
				child_setup, 
				user_data, 
				child_pid, 
				error.getGA()
				) == 0 ? false : true;
				
		if ( error.getCode() != 0 )
		{
			error.dump();
			throw new SpawnException(error.getCode(), error.getMessage());
		}
		
		return result;
	}


	/**
	 * Executes a child synchronously (waits for the child to exit before returning). All output from the child is
	 * stored in standardOutput and standardError, if those parameters are non-NULL. If exitStatus is non-NULL,
	 * the exit status of the child is stored there as it would be returned by waitpid(); standard UNIX macros
	 * such as WIFEXITED() and WEXITSTATUS() must be used to evaluate the exit status. If an error occurs, no data
	 * is returned in standardOutput, standardError, or exitStatus.<br>
	 * This function calls gSpawnAsyncWithPipes() internally; see that function for full details on the other
	 * parameters.
	 * @param workingDirectory child's current working directory, or NULL to inherit parent's
	 * @param argv child's argument vector
	 * @param envp child's environment, or NULL to inherit parent's
	 * @param flags flags from GSpawnFlags
	 * @param childSetup function to run in the child just before exec()
	 * @param userData user data for childSetup
	 * @param standardOutput return location for child output
	 * @param standardError return location for child error messages
	 * @param exitStatus child exit status, as returned by waitpid()
	 * @param error return location for error
	 * @return TRUE on success, FALSE if an error was set.
	 */
	static bit sync(String working_directory, 
			char[][] argv, char[][] envp, SpawnFlags flags, 
			GSpawnChildSetupFunc child_setup, gpointer user_data, String standard_output, String standard_error, out gint exit_status
			)
			//, ErrorG error)
	{
		
		ErrorG error = new ErrorG();
		
		char** cargv = new char*[argv.length];
		int i = 0;
		foreach (char[] p; argv)
		{
			cargv[i++] = cast(char*)p;
		}
		char** cenvp = new char*[envp.length];
		i = 0;
		foreach (char[] p; envp)
		{
			cenvp[i++] = cast(char*)p;
		}

		char* gOut;
		char* gErr;

		bit result = g_spawn_sync(
			working_directory.toStringz(),
			cargv,
			cenvp,
			flags, 
			child_setup, 
			user_data, 
			&gOut, 
			&gErr, 
			&exit_status, 
			error.getGA()) == 0 ? false : true;
		
		standard_output.setz(gOut);
		standard_error.setz(gErr);

				
		if ( error.getCode() != 0 )
		{
			error.dump();
			throw new SpawnException(error.getCode(), error.getMessage());
		}
		
		return result;
	}


	/**
	 * A simple version of gSpawnAsync() that parses a command line with gShellParseArgv() and passes it to
	 * gSpawnAsync(). Runs a command line in the background. Unlike gSpawnAsync(), the GSPAWNSEARCHPATH flag is
	 * enabled, other flags are not. Note that GSPAWNSEARCHPATH can have security implications, so consider using
	 * gSpawnAsync() directly if appropriate. Possible errors are those from gShellParseArgv() and gSpawnAsync().<br>
	 * The same concerns on Windows apply as for gSpawnCommandLineSync().
	 * @param commandLine a command line
	 * @param error return location for errors
	 * @return TRUE on success, FALSE if error is set.
	 */
	static bit commandLineAsync(String command_line)//, ErrorG error)
	{
		ErrorG error = new ErrorG();
		
		bit result = g_spawn_command_line_async(command_line.toStringz(), error.getGA()) == 0 ? false : true;
				
		if ( error.getCode() != 0 )
		{
			error.dump();
			throw new SpawnException(error.getCode(), error.getMessage());
		}
		
		return result;
	}


	/**
	 * A simple version of gSpawnSync() with little-used parameters removed, taking a command line instead of an
	 * argument vector. See gSpawnSync() for full details. commandLine will be parsed by gShellParseArgv(). Unlike
	 * gSpawnSync(), the GSPAWNSEARCHPATH flag is enabled. Note that GSPAWNSEARCHPATH can have security
	 * implications, so consider using gSpawnSync() directly if appropriate. Possible errors are those from
	 * gSpawnSync() and those from gShellParseArgv().<br>
	 * On Windows, please note the implications of gShellParseArgv() parsing commandLine. Space is a separator,
	 * and backslashes are special. Thus you cannot simply pass a commandLine containing canonical Windows paths,
	 * like "c:\\program files\\app\\app.exe", as the backslashes will be eaten, and the space will act as a
	 * separator. You need to enclose such paths with single quotes, like "'c:\\program files\\app\\app.exe'
	 * 'e:\\folder\\argument.txt'".
	 * @param commandLine a command line
	 * @param standardOutput return location for child output
	 * @param standardError return location for child errors
	 * @param exitStatus return location for child exit status
	 * @param error return location for errors
	 * @return TRUE on success, FALSE if an error was set
	 */
	static bit commandLineSync(
				String command_line,
				String standard_output,
				String standard_error,
				out gint exit_status)
				//ErrorG error)
	in
	{
		assert(command_line!is null);
		assert(standard_output!is null);
		assert(standard_error!is null);
	}
	body
	{
		ErrorG error = new ErrorG();
		char* gOut;
		char* gErr;
		bit result = g_spawn_command_line_sync( command_line.toStringz(), &gOut, &gErr,
				&exit_status, (error is null ? null : error.getGA()) ) == 0 ? false : true;

		standard_output.setz(gOut);
		standard_error.setz(gErr);

		if ( error.getCode() != 0 )
		{
			printf("ERROR PATH TAKEN\n");
			error.dump();
			throw new SpawnException(error.getCode(), error.getMessage());
		}

		return result;
	}


	/**
	 * On some platforms, notably WIN32, the GPid type represents a resource which must be closed to prevent resource
	 * leaking. gSpawnClosePid() is provided for this purpose. It should be used on all platforms, even though it
	 * doesn't do anything under UNIX.
	 * @param pid The process identifier to close
	 */
	static void closePid(GPid pid)
	{
		g_spawn_close_pid(pid);
	}


}


/+
enum GSpawnError

typedef enum
{
  G_SPAWN_ERROR_FORK,   /* fork failed due to lack of memory */
  G_SPAWN_ERROR_READ,   /* read or select on pipes failed */
  G_SPAWN_ERROR_CHDIR,  /* changing to working dir failed */
  G_SPAWN_ERROR_ACCES,  /* execv() returned EACCES */
  G_SPAWN_ERROR_PERM,   /* execv() returned EPERM */
  G_SPAWN_ERROR_2BIG,   /* execv() returned E2BIG */
  G_SPAWN_ERROR_NOEXEC, /* execv() returned ENOEXEC */
  G_SPAWN_ERROR_NAMETOOLONG, /* ""  "" ENAMETOOLONG */
  G_SPAWN_ERROR_NOENT,       /* ""  "" ENOENT */
  G_SPAWN_ERROR_NOMEM,       /* ""  "" ENOMEM */
  G_SPAWN_ERROR_NOTDIR,      /* ""  "" ENOTDIR */
  G_SPAWN_ERROR_LOOP,        /* ""  "" ELOOP   */
  G_SPAWN_ERROR_TXTBUSY,     /* ""  "" ETXTBUSY */
  G_SPAWN_ERROR_IO,          /* ""  "" EIO */
  G_SPAWN_ERROR_NFILE,       /* ""  "" ENFILE */
  G_SPAWN_ERROR_MFILE,       /* ""  "" EMFLE */
  G_SPAWN_ERROR_INVAL,       /* ""  "" EINVAL */
  G_SPAWN_ERROR_ISDIR,       /* ""  "" EISDIR */
  G_SPAWN_ERROR_LIBBAD,      /* ""  "" ELIBBAD */
  G_SPAWN_ERROR_FAILED       /* other fatal failure, error->message
                              * should explain
                              */
} GSpawnError;

Error codes returned by spawning processes.
G_SPAWN_ERROR_FORK	Fork failed due to lack of memory.
G_SPAWN_ERROR_READ	Read or select on pipes failed.
G_SPAWN_ERROR_CHDIR	Changing to working directory failed.
G_SPAWN_ERROR_ACCES	execv() returned EACCES.
G_SPAWN_ERROR_PERM	execv() returned EPERM.
G_SPAWN_ERROR_2BIG	execv() returned E2BIG.
G_SPAWN_ERROR_NOEXEC	execv() returned ENOEXEC.
G_SPAWN_ERROR_NAMETOOLONG	execv() returned ENAMETOOLONG.
G_SPAWN_ERROR_NOENT	execv() returned ENOENT.
G_SPAWN_ERROR_NOMEM	execv() returned ENOMEM.
G_SPAWN_ERROR_NOTDIR	execv() returned ENOTDIR.
G_SPAWN_ERROR_LOOP	execv() returned ELOOP.
G_SPAWN_ERROR_TXTBUSY	execv() returned ETXTBUSY.
G_SPAWN_ERROR_IO	execv() returned EIO.
G_SPAWN_ERROR_NFILE	execv() returned ENFILE.
G_SPAWN_ERROR_MFILE	execv() returned EMFILE.
G_SPAWN_ERROR_INVAL	execv() returned EINVAL.
G_SPAWN_ERROR_ISDIR	execv() returned EISDIR.
G_SPAWN_ERROR_LIBBAD	execv() returned ELIBBAD.
G_SPAWN_ERROR_FAILED	Some other fatal failure, error->message should explain.
G_SPAWN_ERROR

#define G_SPAWN_ERROR g_spawn_error_quark ()

Error domain for spawning processes. Errors in this domain will be from the GSpawnError enumeration. See GError for information on error domains.
enum GSpawnFlags

typedef enum
{
  G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0,
  G_SPAWN_DO_NOT_REAP_CHILD      = 1 << 1,
  /* look for argv[0] in the path i.e. use execvp() */
  G_SPAWN_SEARCH_PATH            = 1 << 2,
  /* Dump output to /dev/null */
  G_SPAWN_STDOUT_TO_DEV_NULL     = 1 << 3,
  G_SPAWN_STDERR_TO_DEV_NULL     = 1 << 4,
  G_SPAWN_CHILD_INHERITS_STDIN   = 1 << 5,
  G_SPAWN_FILE_AND_ARGV_ZERO     = 1 << 6
} GSpawnFlags;

Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes().
G_SPAWN_LEAVE_DESCRIPTORS_OPEN	the parent's open file descriptors will be inherited by the child; otherwise all descriptors except stdin/stdout/stderr will be closed before calling exec() in the child.
G_SPAWN_DO_NOT_REAP_CHILD	the child will not be automatically reaped; you must call waitpid() or handle SIGCHLD yourself, or the child will become a zombie.
G_SPAWN_SEARCH_PATH	argv[0] need not be an absolute path, it will be looked for in the user's PATH.
G_SPAWN_STDOUT_TO_DEV_NULL	the child's standad output will be discarded, instead of going to the same location as the parent's standard output.
G_SPAWN_STDERR_TO_DEV_NULL	the child's standard error will be discarded.
G_SPAWN_CHILD_INHERITS_STDIN	the child will inherit the parent's standard input (by default, the child's standard input is attached to /dev/null).
G_SPAWN_FILE_AND_ARGV_ZERO	the first element of argv is the file to execute, while the remaining elements are the actual argument vector to pass to the file. Normally g_spawn_async_with_pipes() uses argv[0] as the file to execute, and passes all of argv to the child.
GSpawnChildSetupFunc ()

void        (*GSpawnChildSetupFunc)         (gpointer user_data);

Specifies the type of the setup function passed to g_spawn_async(), g_spawn_sync() and g_spawn_async_with_pipes(). It is called in the child after GLib has performed all the setup it plans to perform but before calling exec(). Obviously, actions taken in this function will only affect the child, not the parent.
user_data :	user data to pass to the function.
g_spawn_async_with_pipes ()

gboolean    g_spawn_async_with_pipes        (const gchar *working_directory,
                                             gchar **argv,
                                             gchar **envp,
                                             GSpawnFlags flags,
                                             GSpawnChildSetupFunc child_setup,
                                             gpointer user_data,
                                             GPid *child_pid,
                                             gint *standard_input,
                                             gint *standard_output,
                                             gint *standard_error,
                                             GError **error);

Executes a child program asynchronously (your program will not block waiting for the child to exit). The child program is specified by the only argument that must be provided, argv. argv should be a NULL-terminated array of strings, to be passed as the argument vector for the child. The first string in argv is of course the name of the program to execute. By default, the name of the program must be a full path; the PATH shell variable will only be searched if you pass the G_SPAWN_SEARCH_PATH flag.

On Windows, the low-level child process creation API (CreateProcess())doesn't use argument vectors, but a command line. The C runtime library's spawn*() family of functions (which g_spawn_async_with_pipes() eventually calls) paste the argument vector elements into a command line, and the C runtime startup code does a corresponding recostruction of an argument vector from the command line, to be passed to main(). Complications arise when you have argument vector elements that contain spaces of double quotes. The spawn*() functions don't do any quoting or escaping, but on the other hand the startup code does do unquoting and unescaping in order to enable receiving arguments with embedded spaces or double quotes. To work around this asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on argument vector elements that need it before calling the C runtime spawn() function.

envp is a NULL-terminated array of strings, where each string has the form KEY=VALUE. This will become the child's environment. If envp is NULL, the child inherits its parent's environment.

flags should be the bitwise OR of any flags you want to affect the function's behavior. On Unix, the G_SPAWN_DO_NOT_REAP_CHILD means that the child will not be automatically reaped; you must call waitpid() or handle SIGCHLD yourself, or the child will become a zombie. On Windows, the flag means that a handle to the child will be returned child_pid. You must call CloseHandle() on it eventually (or exit the process), or the child processs will continue to take up some table space even after its death. Quite similar to zombies on Unix, actually.

G_SPAWN_LEAVE_DESCRIPTORS_OPEN means that the parent's open file descriptors will be inherited by the child; otherwise all descriptors except stdin/stdout/stderr will be closed before calling exec() in the child. G_SPAWN_SEARCH_PATH means that argv[0] need not be an absolute path, it will be looked for in the user's PATH. G_SPAWN_STDOUT_TO_DEV_NULL means that the child's standard output will be discarded, instead of going to the same location as the parent's standard output. If you use this flag, standard_output must be NULL. G_SPAWN_STDERR_TO_DEV_NULL means that the child's standard error will be discarded, instead of going to the same location as the parent's standard error. If you use this flag, standard_error must be NULL. G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent's standard input (by default, the child's standard input is attached to /dev/null). If you use this flag, standard_input must be NULL. G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of argv is the file to execute, while the remaining elements are the actual argument vector to pass to the file. Normally g_spawn_async_with_pipes() uses argv[0] as the file to execute, and passes all of argv to the child.

child_setup and user_data are a function and user data. On POSIX platforms, the function is called in the child after GLib has performed all the setup it plans to perform (including creating pipes, closing file descriptors, etc.) but before calling exec(). That is, child_setup is called just before calling exec() in the child. Obviously actions taken in this function will only affect the child, not the parent. On Windows, there is no separate fork() and exec() functionality. Child processes are created and run right away with one API call, CreateProcess(). child_setup is called in the parent process just before creating the child process. You should carefully consider what you do in child_setup if you intend your software to be portable to Windows.

If non-NULL, child_pid will on Unix be filled with the child's process ID. You can use the process ID to send signals to the child, or to waitpid() if you specified the G_SPAWN_DO_NOT_REAP_CHILD flag. On Windows, child_pid will be filled with a handle to the child process only if you specified the G_SPAWN_DO_NOT_REAP_CHILD flag. You can then access the child process using the Win32 API, for example wait for its termination with the WaitFor*() functions, or examine its exit code with GetExitCodeProcess(). You should close the handle with CloseHandle() when you no longer need it.

If non-NULL, the standard_input, standard_output, standard_error locations will be filled with file descriptors for writing to the child's standard input or reading from its standard output or standard error. The caller of g_spawn_async_with_pipes() must close these file descriptors when they are no longer in use. If these parameters are NULL, the corresponding pipe won't be created.

If standard_input is NULL, the child's standard input is attached to /dev/null unless G_SPAWN_CHILD_INHERITS_STDIN is set.

If standard_error is NULL, the child's standard error goes to the same location as the parent's standard error unless G_SPAWN_STDERR_TO_DEV_NULL is set.

If standard_output is NULL, the child's standard output goes to the same location as the parent's standard output unless G_SPAWN_STDOUT_TO_DEV_NULL is set.

error can be NULL to ignore errors, or non-NULL to report errors. If an error is set, the function returns FALSE. Errors are reported even if they occur in the child (for example if the executable in argv[0] is not found). Typically the message field of returned errors should be displayed to users. Possible errors are those from the G_SPAWN_ERROR domain.

If an error occurs, child_pid, standard_input, standard_output, and standard_error will not be filled with valid values.

If child_pid is not NULL and an error does not occur then the returned pid must be closed using g_spawn_close_pid().

working_directory :	child's current working directory, or NULL to inherit parent's
argv :	child's argument vector
envp :	child's environment, or NULL to inherit parent's
flags :	flags from GSpawnFlags
child_setup :	function to run in the child just before exec()
user_data :	user data for child_setup
child_pid :	return location for child process ID, or NULL
standard_input :	return location for file descriptor to write to child's stdin, or NULL
standard_output :	return location for file descriptor to read child's stdout, or NULL
standard_error :	return location for file descriptor to read child's stderr, or NULL
error :	return location for error
Returns :	TRUE on success, FALSE if an error was set
g_spawn_async ()

gboolean    g_spawn_async                   (const gchar *working_directory,
                                             gchar **argv,
                                             gchar **envp,
                                             GSpawnFlags flags,
                                             GSpawnChildSetupFunc child_setup,
                                             gpointer user_data,
                                             GPid *child_pid,
                                             GError **error);

See g_spawn_async_with_pipes() for a full description; this function simply calls the g_spawn_async_with_pipes() without any pipes.

working_directory :	child's current working directory, or NULL to inherit parent's
argv :	child's argument vector
envp :	child's environment, or NULL to inherit parent's
flags :	flags from GSpawnFlags
child_setup :	function to run in the child just before exec()
user_data :	user data for child_setup
child_pid :	return location for child process ID, or NULL
error :	return location for error
Returns :	TRUE on success, FALSE if error is set
g_spawn_sync ()

gboolean    g_spawn_sync                    (const gchar *working_directory,
                                             gchar **argv,
                                             gchar **envp,
                                             GSpawnFlags flags,
                                             GSpawnChildSetupFunc child_setup,
                                             gpointer user_data,
                                             gchar **standard_output,
                                             gchar **standard_error,
                                             gint *exit_status,
                                             GError **error);

Executes a child synchronously (waits for the child to exit before returning). All output from the child is stored in standard_output and standard_error, if those parameters are non-NULL. If exit_status is non-NULL, the exit status of the child is stored there as it would be returned by waitpid(); standard UNIX macros such as WIFEXITED() and WEXITSTATUS() must be used to evaluate the exit status. If an error occurs, no data is returned in standard_output, standard_error, or exit_status.

This function calls g_spawn_async_with_pipes() internally; see that function for full details on the other parameters.

working_directory :	child's current working directory, or NULL to inherit parent's
argv :	child's argument vector
envp :	child's environment, or NULL to inherit parent's
flags :	flags from GSpawnFlags
child_setup :	function to run in the child just before exec()
user_data :	user data for child_setup
standard_output :	return location for child output
standard_error :	return location for child error messages
exit_status :	child exit status, as returned by waitpid()
error :	return location for error
Returns :	TRUE on success, FALSE if an error was set.
g_spawn_command_line_async ()

gboolean    g_spawn_command_line_async      (const gchar *command_line,
                                             GError **error);

A simple version of g_spawn_async() that parses a command line with g_shell_parse_argv() and passes it to g_spawn_async(). Runs a command line in the background. Unlike g_spawn_async(), the G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note that G_SPAWN_SEARCH_PATH can have security implications, so consider using g_spawn_async() directly if appropriate. Possible errors are those from g_shell_parse_argv() and g_spawn_async().

The same concerns on Windows apply as for g_spawn_command_line_sync().

command_line :	a command line
error :	return location for errors
Returns :	TRUE on success, FALSE if error is set.
g_spawn_command_line_sync ()

gboolean    g_spawn_command_line_sync       (const gchar *command_line,
                                             gchar **standard_output,
                                             gchar **standard_error,
                                             gint *exit_status,
                                             GError **error);

A simple version of g_spawn_sync() with little-used parameters removed, taking a command line instead of an argument vector. See g_spawn_sync() for full details. command_line will be parsed by g_shell_parse_argv(). Unlike g_spawn_sync(), the G_SPAWN_SEARCH_PATH flag is enabled. Note that G_SPAWN_SEARCH_PATH can have security implications, so consider using g_spawn_sync() directly if appropriate. Possible errors are those from g_spawn_sync() and those from g_shell_parse_argv().

On Windows, please note the implications of g_shell_parse_argv() parsing command_line. Space is a separator, and backslashes are special. Thus you cannot simply pass a command_line containing canonical Windows paths, like "c:\\program files\\app\\app.exe", as the backslashes will be eaten, and the space will act as a separator. You need to enclose such paths with single quotes, like "'c:\\program files\\app\\app.exe' 'e:\\folder\\argument.txt'".

command_line :	a command line
standard_output :	return location for child output
standard_error :	return location for child errors
exit_status :	return location for child exit status
error :	return location for errors
Returns :	TRUE on success, FALSE if an error was set
g_spawn_close_pid ()

void        g_spawn_close_pid               (GPid pid);

On some platforms, notably WIN32, the GPid type represents a resource which must be closed to prevent resource leaking. g_spawn_close_pid() is provided for this purpose. It should be used on all platforms, even though it doesn't do anything under UNIX.

pid :	The process identifier to close
+/

