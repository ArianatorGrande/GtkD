#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


#
###
#####
# Definitions for wrapping GLib
#####
###
#


addTypedefs: start
/* The GLib Basic Types */
public alias int gint;
public alias uint guint;
public alias int gboolean;
public alias void* gpointer;
public alias void* gconstpointer;
public alias char gchar;
public alias char guchar;
public alias short gshort;
public alias ushort gushort;
public alias int glong;
public alias uint gulong;
public alias byte gint8;
public alias byte guint8;
public alias short gint16;
public alias ushort guint16;
public alias int gint32;
public alias long gint64;
public alias uint guint32;
public alias ulong guint64;
public alias float gfloat;
public alias double gdouble;
public alias uint gsize;
public alias int gssize;
public alias long goffset;
public alias void* va_list;
public alias dchar unichar;
public alias wchar unichar2;
public alias uint time_t;
public alias uint XID;

version(Tango) public alias char[] string;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
addEnums: end

addStructs: start
addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start

const uint G_MAXUINT = 4294967295;

addConstants: end


# must start with wrap

wrap: glib

###########################################################
### GLib Fundamentals #####################################
###########################################################

file: glib-Version-Information.html
class: Version
prefix: glib_
import: glib.Str
outFile: GLib

#file: glib-Basic-Types.html
#outFile: types

#file: glib-Limits-of-Basic-Types.html
#outFile: typeLimits

#file: glib-Standard-Macros.html
#class: 
#prefix: 
#outFile: 

#file: glib-Type-Conversion-Macros.html
#class: 
#prefix: 
#outFile: 

#file: glib-Byte-Order-Macros.html
#class: 
#prefix: 
#outFile: 

#file: glib-Numerical-Definitions.html
#class: 
#prefix: 
#outFile: 

#file: glib-Miscellaneous-Macros.html
#class: 
#prefix: 
#outFile: 

file: glib-Atomic-Operations.html
class: Atomic
prefix: g_atomic_
outFile: Atomic

###########################################################
### GLib Core Application Support #########################
###########################################################

file: glib-The-Main-Event-Loop.html

struct: GMainLoop
class: MainLoop
prefix: g_main_loop_
prefix: g_
noprefix: g_main_context_
noprefix: g_timeout_
noprefix: g_child_
noprefix: g_source_
structWrap: GMainLoop* MainLoop
import: glib.MainContext
structWrap: GMainContext* MainContext
import: glib.Source
structWrap: GSource* Source
outFile: MainLoop

struct: GMainContext
class: MainContext
prefix: g_main_context_
strictPrefix: Yes
import: glib.Source
structWrap: GSource* Source
import: gthread.Cond
structWrap: GCond* Cond
import: gthread.Mutex
structWrap: GMutex* Mutex
structWrap: GMainContext* MainContext
#import: glib.SourceFuncs
#structWrap: GSourceFuncs* SourceFuncs
#import: glib.PollFD
#structWrap: GPollFD* PollFD
outFile: MainContext

class: Timeout
prefix: g_timeout_
strictPrefix: Yes
import: glib.Source
structWrap: GSource* Source
outFile: Timeout

class: Child
import: glib.Source
structWrap: GSource* Source
prefix: g_child_
strictPrefix: Yes
outFile: Child

struct: GSource
class: Source
prefix: g_source_
strictPrefix: Yes
#import: glib.SourceFuncs
#structWrap: GSourceFuncs* SourceFuncs
structWrap: GSource* Source
import: glib.MainContext
structWrap: GMainContext* MainContext
#import: glib.SourceCallbackFuncs
#structWrap: GSourceCallbackFuncs* SourceCallbackFuncs
#import: glib.PollFD
#structWrap: GPollFD* PollFD
import: glib.TimeVal
structWrap: GTimeVal* TimeVal
outFile: Source


#file: glib-Threads.html
#In APILookupGThread.txt

file: glib-Thread-Pools.html
struct: GThreadPool
class: ThreadPool
prefix: g_thread_pool_
#import: glib.ErrorG
outFile: ThreadPool


file: glib-Asynchronous-Queues.html
struct: GAsyncQueue
class: AsyncQueue
prefix: g_async_queue_
structWrap: GAsyncQueue* AsyncQueue
import: glib.TimeVal
structWrap: GTimeVal* TimeVal
outFile: AsyncQueue

file: glib-Dynamic-Loading-of-Modules.html
struct: GModule
class: Module
prefix: g_module_
structWrap: GModule* Module
import: glib.Str
outFile: Module

file: glib-Memory-Allocation.html
class: Memory
prefix: g_
#import: glib.MemVTable
#structWrap: GMemVTable* MemVTable
outFile: Memory

file: glib-IO-Channels.html
struct: GIOChannel
class: IOChannel
prefix: g_io_channel_
#import: glib.ErrorG
import: glib.StringG
import: glib.Source
import: glib.Str
structWrap: GString* StringG
structWrap: GSource* Source
structWrap: GIOChannel* IOChannel
outFile: IOChannel


file: glib-Error-Reporting.html
struct: GError
class: ErrorG
prefix: g_error_
import: glib.Str
structWrap: GError* ErrorG
outFile: ErrorG


file: glib-Warnings-and-Assertions.html
class: Messages
prefix: g_
import: glib.Str
outFile: Messages

file: glib-Message-Logging.html
class: MessageLog
prefix: g_
import: glib.Str
outFile: MessageLog


###########################################################
### GLib Utilities ########################################
###########################################################

file: glib-String-Utility-Functions.html
class: Str
import: std.c.stdio
import: glib.StringG
structWrap: GString* StringG
import: std.c.string
prefix: g_

code: start
	const static char[10] digits    = "0123456789";			/// 0..9
	
	/*************************************************
	 * Convert C-style 0 terminated string s to char[] string.
	 * copied from phobos
	 */
	public static string toString(char *s)
	{
		version(D_Version2)
			return s ? s[0 .. strlen(s)].idup : cast(string)null;
		else
			return s ? s[0 .. strlen(s)].dup : cast(string)null;
	}
	
	/*********************************
	 * Convert array of chars s[] to a C-style 0 terminated string.
	 * copied from phobos
	 */
	public static char* toStringz(string s)
	in
	{
	}
	out (result)
	{
	//	if (result)
	//	{
	//		// TODO this one fails in some case???
	//		assert(strlen(result) == s.length);
	//		assert(memcmp(result, s, s.length) == 0);
	//	}
	}
	body
	{
		if ( s is null ) return null;
		char[] copy;
		
		if (s.length == 0)
		{
			copy = "".dup;
		}
		else
		{
			// Need to make a copy
			copy = new char[s.length + 1];
			copy[0..s.length] = s.dup;
			copy[s.length] = 0;
		}
		
		return copy.ptr;
	}
	
	/** */
	public static char** toStringzArray(string[] args)
	{
		if ( args is null )
		{
			return null;
		}
		char** argv = (new char*[args.length]).ptr;
		int argc = 0;
		foreach (string p; args)
		{
			argv[argc++] = cast(char*)(p.dup~'\0');
		}
		argv[argc] = null;
		
		return argv;
	}
	
	/** */
	public static string[] toStringArray(char** args)
	{
		if ( args is null )
		{
			return null;
		}
		string[] argv;
		
		char* arg = args[0];
		int i=0;
		while( (arg) != null && i<10)
		{
			argv ~= toString(arg);
			++i;
			arg = args[i];
		}
		
		return argv;
	}
	
	/** */
	public static string toString(bool b)
	{
		return b ? "true" : "false";
	}
	
	/** */
	public static char[] toString(char c)
	{
		char[] result = new char[2];
		result[0] = c;
		result[1] = 0;
		return result[0 .. 1];
	}
	
	/** */
	public static string toString(ubyte ub)  { return toString(cast(uint) ub); } /// ditto
	/** */
	public static string toString(ushort us) { return toString(cast(uint) us); } /// ditto
	
	/** */
	public static string toString(uint u)
	{
		char[uint.sizeof * 3] buffer = void;
		int ndigits;
		char c;
		string result;
		
		ndigits = 0;
		if (u < 10)
		{
			version(D_Version2)
				result = digits[u .. u + 1].idup;
			else
				// Avoid storage allocation for simple stuff
				result = digits[u .. u + 1];
		}
		else
		{
			while (u)
			{
				c = (u % 10) + '0';
				u /= 10;
				ndigits++;
				buffer[buffer.length - ndigits] = c;
			}

			version(D_Version2)
			{
				//result = new char[ndigits];
				result = buffer[buffer.length - ndigits .. buffer.length].idup;
			}
			else
			{
				result = new char[ndigits];
				result[] = buffer[buffer.length - ndigits .. buffer.length];
			}
		}
		return result;
	}
	
	/** */
	public static string toString(ulong u)
	{
		char[ulong.sizeof * 3] buffer;
		int ndigits;
		char c;
		string result;
		
		if (u < 0x1_0000_0000)
			return toString(cast(uint)u);
		
		ndigits = 0;
		while (u)
		{
			c = (u % 10) + '0';
			u /= 10;
			ndigits++;
			buffer[buffer.length - ndigits] = c;
		}

		version(D_Version2)
		{
			//result = new char[ndigits];
			result = buffer[buffer.length - ndigits .. buffer.length].idup;
		}
		else
		{
			result = new char[ndigits];
			result[] = buffer[buffer.length - ndigits .. buffer.length];
		}
		return result;
	}
	
	/** */
	public static string toString(byte b)  { return toString(cast(int) b); } /// ditto
	/** */
	public static string toString(short s) { return toString(cast(int) s); } /// ditto
	
	/** */
	public static string toString(int i)
	{
		char[1 + int.sizeof * 3] buffer;
		char c;
		string result;
		
		if (i >= 0)
			return toString(cast(uint)i);
		
		uint u = -i;
		int ndigits = 1;
		while (u)
		{
			c = (u % 10) + '0';
			u /= 10;
			buffer[buffer.length - ndigits] = c;
			ndigits++;
		}
		buffer[buffer.length - ndigits] = '-';

		version(D_Version2)
		{
			//result = new char[ndigits];
			result = buffer[buffer.length - ndigits .. buffer.length].idup;
		}
		else
		{
			result = new char[ndigits];
			result[] = buffer[buffer.length - ndigits .. buffer.length];
		}
		return result;
	}
code: end


outFile: Str

file: glib-Character-Set-Conversion.html
class: CharacterSet
prefix: g_
import: glib.Str
#import: glib.ErrorG
# these fail to compile because of a reference to a struct that size is not known
noprefix: g_convert_with_iconv
noprefix: g_iconv_open
noprefix: g_iconv
noprefix: g_iconv_close
outFile: CharacterSet

file: glib-Unicode-Manipulation.html
class: Unicode
prefix: g_
import: glib.Str
#import: glib.ErrorG
outFile: Unicode

file: glib-Base64-Encoding.html
class: Base64
prefix: g_base64_
import: glib.Str
outFile: Base64

file: glib-Data-Checksums.html
struct: GChecksum
class: Checksum
prefix: g_checksum_
import: glib.Str
structWrap: GChecksum* Checksum
outFile: Checksum

file: glib-I18N.html
class: Internationalization
prefix: g_
import: glib.Str
outFile: Internationalization

file: glib-Date-and-Time-Functions.html
struct: GTimeVal
class: TimeVal
prefix: g_time_val_
prefix: g_
noprefix: g_date_
import: glib.Str
outFile: TimeVal

struct: GDate
class: Date
prefix: g_date_
strictPrefix: Y
import: glib.TimeVal
structWrap: GTimeVal* TimeVal
import: glib.Str
structWrap: GDate* Date
outFile: Date

file: glib-Random-Numbers.html
struct: GRand
class: RandG
prefix: g_rand_
prefix: g_
structWrap: GRand* RandG

nocode: g_rand_int
nocode: g_rand_int_range
nocode: g_rand_double
nocode: g_rand_double_range

code: start
	/**
	 * Returns the next random guint32 from rand_ equally distributed over
	 * the range [0..2^32-1].
	 * Params:
	 * rand =  a GRand.
	 * Returns: A random number.
	 */
	public uint randInt()
	{
		// guint32 g_rand_int (GRand *rand_);
		return g_rand_int(gRand);
	}
	
	/**
	 * Returns the next random gint32 from rand_ equally distributed over
	 * the range [begin..end-1].
	 * Params:
	 * rand =  a GRand.
	 * begin =  lower closed bound of the interval.
	 * end =  upper open bound of the interval.
	 * Returns: A random number.
	 */
	public int randIntRange(int begin, int end)
	{
		// gint32 g_rand_int_range (GRand *rand_,  gint32 begin,  gint32 end);
		return g_rand_int_range(gRand, begin, end);
	}
	
	/**
	 * Returns the next random gdouble from rand_ equally distributed over
	 * the range [0..1).
	 * Params:
	 * rand =  a GRand.
	 * Returns: A random number.
	 */
	public double randDouble()
	{
		// gdouble g_rand_double (GRand *rand_);
		return g_rand_double(gRand);
	}
	
	/**
	 * Returns the next random gdouble from rand_ equally distributed over
	 * the range [begin..end).
	 * Params:
	 * rand =  a GRand.
	 * begin =  lower closed bound of the interval.
	 * end =  upper open bound of the interval.
	 * Returns: A random number.
	 */
	public double randDoubleRange(double begin, double end)
	{
		// gdouble g_rand_double_range (GRand *rand_,  gdouble begin,  gdouble end);
		return g_rand_double_range(gRand, begin, end);
	}
code: end
outFile: RandG

#file: glib-Hook-Functions.html
#class: Hook
#prefix: g_hook_
##import: glib.HookList
##structWrap: GHookList* HookList
##import: glib.Hook
#structWrap: GHook* Hook
#outFile: Hook

file: glib-Miscellaneous-Utility-Functions.html
class: Util
import: glib.ListG
structWrap: GList* ListG
prefix: g_
#import: glib.DebugKey
#structWrap: GDebugKey* DebugKey
import: glib.Str
outFile: Util

file: glib-Lexical-Scanner.html
struct: GScanner
class: ScannerG
prefix: g_scanner_
structWrap: GScanner* ScannerG
#import: glib.ScannerConfig
#structWrap: GScannerConfig* ScannerConfig
import: glib.Str
outFile: ScannerG

file: glib-Automatic-String-Completion.html
struct: GCompletion
class: StringCompletion
import: glib.ListG
structWrap: GList* ListG
prefix:g_completion_
import: glib.Str
outFile: StringCompletion

file: glib-Timers.html
struct: GTimer
class: Timer
prefix: g_timer_
structWrap: GTimer* Timer
outFile: Timer

file: glib-Spawning-Processes.html
class: Spawn
import: glib.ErrorG
import: glib.MainLoop
structWrap: GMainLoop* MainLoop
prefix: g_spawn_
#import: glib.Pid
#structWrap: GPid* Pid
#import: glib.Error*
#structWrap: GError** Error*
import: glib.Str
import: std.thread
import: std.c.stdio
import: std.string
import: std.c.string
nocode: g_spawn_async_with_pipes

code: start
	
	version(Tango) alias splitLines splitlines;
	
	
	string workingDirectory = ".";
	string[] argv;
	string[] envp;
	GSpawnFlags flags = SpawnFlags.SEARCH_PATH;
	GSpawnChildSetupFunc childSetup;
	void* userData;
	GPid childPid;
	FILE* standardInput;
	FILE* standardOutput;
	FILE* standardError;
	GError* error;
	int stdIn;
	int stdOut;
	int stdErr;
	
	// for commandLineSync
	int exitStatus;
	char* strOutput;
	char* strError;
	
	alias bool delegate(Spawn) ChildWatch;
	ChildWatch externalWatch;
	
	/**
	 * Creates a Spawn for execution.
	 */
	public this(string program, string[] envp=null)
	{
		argv ~= program;
		this.envp = envp;
	}
	
	/**
	 * Creates a Spawn for execution.
	 */
	public this(string[] program, string[] envp=null)
	{
		argv = program;
		this.envp = envp;
	}
	
	/**
	 * Adds a delegate to be notified on the end of the child process.
	 * Params:
	 *    	dlg =
	 */
	public void addChildWatch(ChildWatch dlg)
	{
		externalWatch = dlg;
	}
	
	/**
	 * Closes all open streams and child process.
	 */
	public void close()
	{
		if (stdIn != 0 )
		{
			fclose(standardInput);
			stdIn = 0;
		}
		if (stdOut != 0 )
		{
			fclose(standardOutput);
			stdOut = 0;
		}
		if (stdErr != 0 )
		{
			fclose(standardError);
			stdErr = 0;
		}
		if ( childPid != 0 )
		{
			closePid(childPid);
			childPid = 0;
		}
	}
	
	/**
	 * Adds a parameter to the execution program
	 */
	public void addParm(string parm)
	{
		argv ~= parm;
	}
	
	/**
	 * Gets the last error message
	 */
	public string getLastError()
	{
		if ( error != null )
		{
			return Str.toString(error.message);
		}
		return "";
	}
	
	version(Tango)
	{
		version (Windows)
			extern (C) FILE*  fdopen(int, char*); //Generates linker error on linux.
		else
			private import tango.stdc.posix.stdio;
	}
	
	/**
	 * Executes the prepared process
	 */
	public int execAsyncWithPipes(
		ChildWatch externalWatch = null,
		bool delegate(string) readOutput = null,
		bool delegate(string) readError = null )
	{
		int result = g_spawn_async_with_pipes(
		Str.toStringz(workingDirectory),
		Str.toStringzArray(argv),
		Str.toStringzArray(envp),
		flags,
		childSetup,
		userData,
		&childPid,
		&stdIn,
		&stdOut,
		&stdErr,
		&error
		);
		
		if ( result != 0 )
		{
			this.externalWatch = externalWatch;
			g_child_watch_add(childPid, cast(GChildWatchFunc)(&childWatchCallback), cast(void*)this);
			standardInput = fdopen(stdIn, "w");
			standardOutput = fdopen(stdOut, "r");
			standardError = fdopen(stdErr, "r");
			
			if ( readOutput !is null )
			{
				(new ReadFile(standardOutput, readOutput)).start();
			}
			if ( readError !is null )
			{
				(new ReadFile(standardError, readError)).start();
			}
		}
		
		return result;
	}
	
	class ReadFile : Thread
	{
		bool delegate(string) read;
		FILE* file;
		
		int lineCount;
		
		this(FILE* file, bool delegate (string) read )
		{
			this.file = file;
			this.read = read;
		}
		
		public int run()
		{
			string line = readLine(file);
			while( line !is null )
			{
				++lineCount;
				//writefln("Spawn.ReadFile.run line (%s) ========== >>>%s<<<", lineCount, line);
				//printf("Spawn.ReadFile.run line (%d) ========== >>>%.*s<<<", lineCount, line);
				if ( read !is null )
				{
					read(line);
				}
				line = readLine(file);
			}
			return 0;
		}
	}
	
	private string readLine(FILE* stream, int max=4096)
	{
		if ( feof(stream) )
		{
			if ( externalWatch !is null )
			{
				externalWatch(this);
			}
			return null;
		}
		string line;
		line.length = max+1;
		char* lineP = fgets(Str.toStringz(line), max, stream);
		if ( lineP is null )
		{
			return "";
		}
		int l = strlen(line.ptr);
		if ( l > 0 ) --l;
		//printf("\nreadLine\n");
		//foreach ( char c ; line )
		//{
		//       printf("%c", c);
		//}
		//printf("\n\n");
		return line[0..l];
	}
	
	extern(C) static void childWatchCallback(int pid, int status, Spawn spawn)
	{
		//writefln("Spawn.childWatchCallback %s %s", pid, status);
		spawn.exitStatus = status;
		if ( spawn.externalWatch !is null )
		{
			spawn.externalWatch(spawn);
		}
		spawn.close();
	}
	
	
	public bool endOfOutput()
	{
		if ( standardOutput is null ) return true;
		return feof(standardOutput) != 0;
	}
	
	public bool endOfError()
	{
		if ( standardError is null ) return true;
		return feof(standardError) != 0;
	}
	
	string getOutputString()
	{
		return Str.toString(strOutput);
	}
	
	string getErrorString()
	{
		return Str.toString(strError);
	}
	
	int getExitStatus()
	{
		return exitStatus;
	}
	
	/**
	 * Executes a command synchronasly and
	 * optionally calls delegates for sysout, syserr and end of job
	 *
	 */
	public int commandLineSync(
		ChildWatch externalWatch = null,
		bool delegate(string) readOutput = null,
		bool delegate(string) readError = null )
	{
		string commandLine;
		foreach ( int count, string arg; argv)
		{
			if ( count > 0 )
			{
				commandLine ~= ' ';
			}
			commandLine ~= arg;
		}
		int status = g_spawn_command_line_sync(
			Str.toStringz(commandLine),
			&strOutput,
			&strError,
			&exitStatus,
			&error);
		if ( readOutput != null )
		{
			foreach ( string line ; splitlines(Str.toString(strOutput)) )
			{
				readOutput(line);
			}
		}
		if ( readError != null )
		{
			foreach ( string line ; splitlines(Str.toString(strError)) )
			{
				readError(line);
			}
		}
		if ( externalWatch != null )
		{
			externalWatch(this);
		}
		return status;
	}
code: end

outFile: Spawn

file: glib-File-Utilities.html
class: FileUtils
prefix: g_
noprefix: g_dir_
noprefix: g_mapped_file_
import: std.c.stdio
import: glib.Str
#import: glib.ErrorG
#structWrap: GError** Error*
outFile: FileUtils

struct: GDir
class: Directory
prefix: g_dir_
strictPrefix: Y
import: glib.Str
#import: glib.ErrorG
outFile: Directory

struct: GMappedFile
class: MappedFile
prefix: g_mapped_file_
strictPrefix: Y
import: glib.Str
#import: glib.ErrorG
outFile: MappedFile

file: glib-URI-Functions.html
class: URI
prefix: g_uri_
import: glib.Str
outFile: URI

file: glib-Shell-related-Utilities.html
class: ShellUtils
prefix: g_shell_
import: glib.Str
#import: glib.ErrorG
outFile: ShellUtils

file: glib-Commandline-option-parser.html

struct: GOptionContext
class: OptionContext
prefix: g_option_context_
noprefix: g_option_group_
#import: glib.ErrorG
#structWrap: GError** Error*
#import: glib.OptionEntry
#structWrap: GOptionEntry* OptionEntry
import: glib.OptionGroup
structWrap: GOptionGroup* OptionGroup
import: glib.Str
outFile: OptionContext

struct: GOptionGroup
class: OptionGroup
prefix: g_option_group_
strictPrefix: Yes
#import: glib.OptionEntry
#structWrap: GOptionEntry* OptionEntry
import: glib.Str
outFile: OptionGroup

file: glib-Glob-style-pattern-matching.html
struct: GPatternSpec
class: Pattern
prefix: g_pattern_spec_
prefix: g_pattern_
structWrap: GPatternSpec* Pattern
import: glib.Str
outFile: Pattern

file: glib-Perl-compatible-regular-expressions.html
struct: GRegex
class: Regex
prefix: g_regex_
noprefix: g_match_info_
import: glib.Str
structWrap: GRegex* Regex
#import: glib.ErrorG
#structWrap: GError** ErrorG*
#import: glib.MatchInfo
#structWrap: GMatchInfo** MatchInfo*
outFile: Regex

struct: GMatchInfo
class: MatchInfo
prefix: g_match_info_
strictPrefix: Y
import: glib.Str
#import: glib.ErrorG
#structWrap: GError** ErrorG*
outFile: MatchInfo

file: glib-Simple-XML-Subset-Parser.html
struct: GMarkupParseContext
class: SimpleXML
prefix: g_markup_parse_context_
prefix: g_markup_
import: glib.ListSG
structWrap: GSList* ListSG
#import: glib.ErrorG
#structWrap: GError** Error*
#import: glib.MarkupParser
#structWrap: GMarkupParser* MarkupParser
import: glib.Str
outFile: SimpleXML

file: glib-Key-value-file-parser.html
struct: GKeyFile
class: KeyFile
prefix: g_key_file_
#import: glib.ErrorG
import: glib.Str
outFile: KeyFile

file: glib-Bookmark-file-parser.html
struct: GBookmarkFile
class: BookmarkFile
prefix: g_bookmark_file_
#import: glib.ErrorG
#structWrap: GError** Error*
import: glib.Str
outFile: BookmarkFile

file: glib-Windows-Compatibility-Functions.html
class: WindowsUtils
prefix: g_win32_
import: glib.Str
outFile: WindowsUtils


###########################################################
### GLib Data Types #######################################
###########################################################

file: glib-Memory-Slices.html
class: MemorySlice
prefix: g_slice_
outFile: MemorySlice

file: glib-Memory-Chunks.html
struct: GMemChunk
class: MemoryChunk
prefix: g_mem_chunk_
prefix: g_
import: glib.Str
outFile: MemoryChunk

file: glib-Doubly-Linked-Lists.html
struct: GList
class: ListG
prefix: g_list_
structWrap: GList* ListG

code: start
  	/** */ 
	void* data()
	{
		int* pt = cast(int*)getStruct();
		return cast(void *)(*pt);
	}
code: end
outFile: ListG

file: glib-Singly-Linked-Lists.html
struct: GSList
class: ListSG
prefix: g_slist_
structWrap: GSList* ListSG

code: start
  	/** */ 
	void* data()
	{
		int* pt = cast(int*)getStruct();
		return cast(void *)(*pt);
	}
code: end
outFile: ListSG

file: glib-Double-ended-Queues.html
struct: GQueue
class: QueueG
prefix: g_queue_
structWrap: GQueue* QueueG
import: glib.ListG
structWrap: GList* ListG
outFile: QueueG

file: glib-Sequences.html
struct: GSequence
class: Sequence
prefix: g_sequence_
structWrap: GSequence* Sequence
#structWrap: GSequenceIter* SequenceIter
outFile: Sequence

file: glib-Trash-Stacks.html
struct: GTrashStack
class: TrashStack
prefix: g_trash_stack_
#structWrap: GTrashStack** TrashStack*
outFile: TrashStack

file: glib-Hash-Tables.html
struct: GHashTable
class: HashTable
prefix: g_hash_table_
structWrap: GHashTable* HashTable
import: glib.ListG
structWrap: GList* ListG
outFile: HashTable

file: glib-Strings.html
struct: GString
class: StringG
prefix: g_string_
structWrap: GString* StringG
import: glib.Str
outFile: StringG

file: glib-String-Chunks.html
struct: GStringChunk
class: StringGChunk
prefix: g_string_chunk_
import: glib.Str
outFile: StringGChunk

file: glib-Arrays.html
struct: GArray
class: ArrayG
prefix: g_array_
structWrap: GArray* ArrayG
import: glib.Str
outFile: ArrayG

file: glib-Pointer-Arrays.html
struct: GPtrArray
class: PtrArray
prefix: g_ptr_array_
structWrap: GPtrArray* PtrArray
outFile: PtrArray

file: glib-Byte-Arrays.html
struct: GByteArray
class: ByteArray
prefix: g_byte_array_
outFile: ByteArray

file: glib-Balanced-Binary-Trees.html
struct: GTree
class: BBTree
prefix: g_tree_
outFile: BBTree

file: glib-N-ary-Trees.html
struct: GNode
class: Node
prefix: g_node_
structWrap: GNode* Node
outFile: Node

file: glib-Quarks.html
struct: GQuark
class: Quark
prefix: g_quark_
import: glib.Str
outFile: Quark

file: glib-Keyed-Data-Lists.html
struct: GData
class: DataList
prefix: g_datalist_
outFile: DataList

file: glib-Datasets.html
class: Dataset
prefix: g_dataset_
outFile: Dataset

file: glib-Relations-and-Tuples.html
struct: GRelation
class: Relation
prefix: g_relation_
noprefix: g_tuples_
import: glib.Tuples
structWrap: GTuples* Tuples
outFile: Relation

struct: GTuples
class: Tuples
prefix: g_tuples_
strictPrefix: Yes
outFile: Tuples

file: glib-Caches.html
struct: GCache
class: Cache
prefix: g_cache_
outFile: Cache

file: glib-Memory-Allocators.html
struct: GAllocator
class: Allocator
prefix: g_allocator_
import: glib.Str
outFile: Allocator

###########################################################
### GLib Tools ############################################
###########################################################
