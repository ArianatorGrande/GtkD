#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version, with
# some exceptions, please read the COPYING file.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
#


#
###
#####
# Definitions for wrapping GObject
#####
###
#


addTypedefs: start

public import gtkc.glibtypes;
public import gtkc.gobjecttypes;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
addEnums: end

addStructs: start
addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end

# must start with wrap
wrap: gio

###########################################################
### File Operations #######################################
###########################################################

file: GFile.html
struct: GFile
class: File
extend: GObject
prefix: g_file_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AppInfo
import: gio.AppInfoIF
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileAttributeInfoList
import: gio.FileEnumerator
import: gio.FileInfo
import: gio.FileInputStream
import: gio.FileIOStream
import: gio.FileMonitor
import: gio.FileOutputStream
import: gio.Mount
import: gio.MountIF
import: gio.MountOperation
structWrap: GAppInfo* AppInfoIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFile* File
structWrap: GFileAttributeInfoList* FileAttributeInfoList
structWrap: GFileEnumerator* FileEnumerator
structWrap: GFileInfo* FileInfo
structWrap: GFileInputStream* FileInputStream
structWrap: GFileIOStream* FileIOStream
structWrap: GFileMonitor* FileMonitor
structWrap: GFileOutputStream* FileOutputStream
structWrap: GMount* MountIF
structWrap: GMountOperation* MountOperation

out: g_file_set_attributes_finish info
out: g_file_load_contents contents
out: g_file_load_contents length
out: g_file_load_contents etag_out
out: g_file_load_contents_finish contents
out: g_file_load_contents_finish length
out: g_file_load_contents_finish etag_out
out: g_file_load_partial_contents_finish contents
out: g_file_load_partial_contents_finish  length
out: g_file_load_partial_contents_finish etag_out
out: g_file_replace_contents new_etag
out: g_file_replace_contents_finish new_etag

# g_file_new_for_commandline_arg also accepts paths ans uris
nocode: g_file_new_for_path
nocode: g_file_new_for_uri
outFile: File


file: gio-GFileAttribute.html
struct: GFileAttributeInfoList
class: FileAttributeInfoList
prefix: g_file_attribute_info_list_
import: glib.Str
structWrap: GFileAttributeInfoList* FileAttributeInfoList
outFile: FileAttributeInfoList

file: GFileInfo.html
struct: GFileInfo
class: FileInfo
extend: GObject
prefix: g_file_info_
noprefix: g_file_attribute_matcher_
import: glib.Str
import: glib.TimeVal
import: gobject.ObjectG
import: gio.Icon
import: gio.IconIF
import: gio.FileAttributeMatcher
structWrap: GTimeVal* TimeVal
structWrap: GObject* ObjectG
structWrap: GIcon* IconIF
structWrap: GFileAttributeMatcher* FileAttributeMatcher
structWrap: GFileInfo* FileInfo

out: g_file_info_get_attribute_data type
out: g_file_info_get_attribute_data value_pp
out: g_file_info_get_attribute_data status
array: g_file_info_set_attribute_stringv attr_value

outFile: FileInfo


struct: GFileAttributeMatcher
class: FileAttributeMatcher
prefix: g_file_attribute_matcher_
strictPrefix: Y
import: glib.Str
structWrap: GFileAttributeMatcher* FileAttributeMatcher
outFile: FileAttributeMatcher

file: GFileEnumerator.html
struct: GFileEnumerator
class: FileEnumerator
prefix: g_file_enumerator_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.File
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFile* File
outFile: FileEnumerator

file: gio-GIOError.html
class: ErrorGIO
prefix: g_io_error_
outFile: ErrorGIO

file: GMountOperation.html
struct: GMountOperation
class: MountOperation
extend: GObject
prefix: g_mount_operation_
import: glib.Str
import: glib.ArrayG
structWrap: GArray* ArrayG
outFile: MountOperation

###########################################################
### File System Monitoring ################################
###########################################################

file: GFileMonitor.html
struct: GFileMonitor
class: FileMonitor
extend: GObject
prefix: g_file_monitor_
import: gio.File
structWrap: GFile* File
outFile: FileMonitor

###########################################################
### Asynchronous I/O ######################################
###########################################################

file: GCancellable.html
struct: GCancellable
class: Cancellable
prefix: g_cancellable_
import: glib.ErrorG
import: glib.GException
import: glib.Source
structWrap: GCancellable* Cancellable
structWrap: GSource* Source
outFile: Cancellable

file: GAsyncResult.html
struct: GAsyncResult
class: AsyncResultT
template: TStruct
prefix: g_async_result_
import: gobject.ObjectG
structWrap: GObject* ObjectG
interface: AsyncResultIF
outFile: AsyncResultT

file: gio-GIOScheduler.html
struct: GIOSchedulerJob
class: IOSchedulerJob
prefix: g_io_scheduler_job_
prefix: g_io_scheduler_
import: gio.Cancellable
structWrap: GCancellable* Cancellable
outFile: IOSchedulerJob

file: GSimpleAsyncResult.html
struct: GSimpleAsyncResult
class: SimpleAsyncResult
prefix: g_simple_async_result_
prefix: g_
implements: AsyncResultIF
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.Cancellable
structWrap: GError* ErrorG
structWrap: GObject* ObjectG
structWrap: GCancellable* Cancellable

#imports for AsyncResult Interface.
import: gio.AsyncResultIF
import: gio.AsyncResultT

code: start
	// add the AsyncResult capabilities
	mixin AsyncResultT!(GSimpleAsyncResult);
code: end
outFile: SimpleAsyncResult

###########################################################
### Data conversion #######################################
###########################################################

file: GConverter.html
struct: GConverter
class: ConverterT
template: TStruct
prefix: g_converter_
import: glib.ErrorG
import: glib.GException

array: g_converter_convert inbuf inbuf_size
array: g_converter_convert outbuf outbuf_size
out: g_converter_convert bytes_read
out: g_converter_convert bytes_written

interface: ConverterIF
outFile: ConverterT

file:
class: Converter
extend: ObjectG
implements: ConverterIF
import: gobject.ObjectG

# imports for Converter Interface
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// Minimal implementation.
	mixin ConverterT!(GConverter);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gConverter;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GConverter* gConverter)
	{
		if(gConverter is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gConverter);
		this.gConverter = gConverter;
	}
code: end
outFile: Converter

file: GCharsetConverter.html
struct: GCharsetConverter
class: CharsetConverter
implements: ConverterIF
prefix: g_charset_converter_
import: glib.Str
import: glib.ErrorG
import: glib.GException

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GCharsetConverter);
code: end
outFile: CharsetConverter

file: GZlibCompressor.html
struct: GZlibCompressor
class: ZlibCompressor
implements: ConverterIF
import: gio.FileInfo
structWrap: GFileInfo* FileInfo
prefix: g_zlib_compressor_

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GZlibCompressor);
code: end
outFile: ZlibCompressor

file: GZlibDecompressor.html
struct: GZlibDecompressor
class: ZlibDecompressor
implements: ConverterIF
import: gio.FileInfo
structWrap: GFileInfo* FileInfo
prefix: g_zlib_decompressor_

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GZlibDecompressor);
code: end
outFile: ZlibDecompressor

###########################################################
### Streaming I/O #########################################
###########################################################

file: GSeekable.html
struct: GSeekable
class: SeekableT
template: TStruct
prefix: g_seekable_
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
structWrap: GCancellable* Cancellable
interface: SeekableIF
outFile: SeekableT

file: GInputStream.html
struct: GInputStream
class: InputStream
prefix: g_input_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
out: g_input_stream_read_all bytes_read
outFile: InputStream

file: GOutputStream.html
struct: GOutputStream
class: OutputStream
extend: GObject
prefix: g_output_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
out: g_output_stream_write_all bytes_read
outFile: OutputStream

file: GIOStream.html
struct: GIOStream
class: IOStream
prefix: g_io_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
import: gio.OutputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
structWrap: GIOStream* IOStream
structWrap: GOutputStream* OutputStream
outFile: IOStream

file: GFileInputStream.html
struct: GFileInputStream
class: FileInputStream
implements: SeekableIF
prefix: g_file_input_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileInputStream);
code: end
outFile: FileInputStream

file: GFileOutputStream.html
struct: GFileOutputStream
class: FileOutputStream
implements: SeekableIF
prefix: g_file_output_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileOutputStream);
code: end
outFile: FileOutputStream

file: GFileIOStream.html
struct: GFileIOStream
class: FileIOStream
implements: SeekableIF
prefix: g_file_io_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileIOStream);
code: end
outFile: FileIOStream

file: GFileDescriptorBased.html
struct: GFileDescriptorBased
class: FileDescriptorBasedT
template: TStruct
prefix: g_file_descriptor_based_
interface: FileDescriptorBasedIF
outFile: FileDescriptorBasedT

file: GFilterInputStream.html
struct: GFilterInputStream
class: FilterInputStream
prefix: g_filter_input_stream_
import: gio.InputStream
structWrap: GInputStream* InputStream
outFile: FilterInputStream

file: GFilterOutputStream.html
struct: GFilterOutputStream
class: FilterOutputStream
prefix: g_filter_output_stream_
import: gio.OutputStream
structWrap: GOutputStream* OutputStream
outFile: FilterOutputStream

file: GMemoryInputStream.html
struct: GMemoryInputStream
ctorStruct: GInputStream
class: MemoryInputStream
implements: SeekableIF
prefix: g_memory_input_stream_

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GMemoryInputStream);
code: end
outFile: MemoryInputStream

file: GMemoryOutputStream.html
struct: GMemoryOutputStream
ctorStruct: GOutputStream
class: MemoryOutputStream
implements: SeekableIF
prefix: g_memory_output_stream_

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GMemoryOutputStream);
code: end
outFile: MemoryOutputStream

file: GBufferedInputStream.html
struct: GBufferedInputStream
ctorStruct: GInputStream
class: BufferedInputStream
prefix: g_buffered_input_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
out: g_buffered_input_stream_peek_buffer count
outFile: BufferedInputStream

file: GBufferedOutputStream.html
struct: GBufferedOutputStream
ctorStruct: GOutputStream
class: BufferedOutputStream
prefix: g_buffered_output_stream_
import: gio.OutputStream
structWrap: GOutputStream* OutputStream
outFile: BufferedOutputStream

file: GDataInputStream.html
struct: GDataInputStream
class: DataInputStream
prefix: g_data_input_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.InputStream
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream

out: g_data_input_stream_read_line_finish result
out: g_data_input_stream_read_upto_finish result
out: g_data_input_stream_read_until_finish result
array:  g_data_input_stream_read_line Return length
array: g_data_input_stream_read_line_finish Return length
array: g_data_input_stream_read_upto stop_chars stop_chars_len
array: g_data_input_stream_read_upto Return length
array: g_data_input_stream_read_upto_async stop_chars stop_chars_len
array: g_data_input_stream_read_upto_finish Return length
array: g_data_input_stream_read_until Return length
array: g_data_input_stream_read_until_finish Return length

nocode: g_data_input_stream_read_byte
outFile: DataInputStream

file: GDataOutputStream.html
struct: GDataOutputStream
class: DataOutputStream
prefix: g_data_output_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.OutputStream
structWrap: GCancellable* Cancellable
structWrap: GOutputStream* OutputStream
outFile: DataOutputStream

file: GUnixInputStream.html
struct: GUnixInputStream
ctorStruct: GInputStream
class: UnixInputStream
implements: PollableInputStreamIF
prefix: g_unix_input_stream_

#imports for PollableInputStream Interface.
import: gio.PollableInputStreamT
import: gio.PollableInputStreamIF

code: start
	// add the PollableInputStream capabilities
	mixin PollableInputStreamT!(GUnixInputStream);
code: end
outFile: UnixInputStream

file: GUnixOutputStream.html
struct: GUnixOutputStream
ctorStruct: GOutputStream
class: UnixOutputStream
implements: PollableOutputStreamIF
prefix: g_unix_output_stream_

#imports for PollableOutputStream Interface.
import: gio.PollableOutputStreamT
import: gio.PollableOutputStreamIF

code: start
	// add the PollableOutputStream capabilities
	mixin PollableOutputStreamT!(GUnixOutputStream);
code: end
outFile: UnixOutputStream

file: gio-GConverterInputstream.html
struct: GConverterInputStream
ctorStruct: GInputStream
class: ConverterInputStream
prefix: g_converter_input_stream_
import: gio.Converter
import: gio.ConverterIF
structWrap: GConverter* ConverterIF
outFile: ConverterInputStream

file: gio-GConverterOutputstream.html
struct: GConverterOutputStream
ctorStruct: GOutputStream
class: ConverterOutputStream
prefix: g_converter_output_stream_
import: gio.Converter
import: gio.ConverterIF
structWrap: GConverter* ConverterIF
outFile: ConverterOutputStream

file: GPollableInputStream.html
struct: GPollableInputStream
class: PollableInputStreamT
template: TStruct
prefix: g_pollable_input_stream_
import: gobject.ObjectG
import: glib.ErrorG
import: glib.GException
import: glib.Source
import: gio.Cancellable
structWrap: GObject* ObjectG
structWrap: GCancellable* Cancellable
structWrap: GSource* Source
array: g_pollable_input_stream_read_nonblocking buffer size
interface: PollableInputStreamIF
outFile: PollableInputStreamT

file: GPollableOutputStream.html
struct: GPollableOutputStream
class: PollableOutputStreamT
template: TStruct
prefix: g_pollable_input_stream_
import: glib.ErrorG
import: glib.GException
import: glib.Source
import: gio.Cancellable
structWrap: GCancellable* Cancellable
structWrap: GSource* Source
array: g_pollable_output_stream_write_nonblocking buffer size
interface: PollableOutputStreamIF
outFile: PollableOutputStreamT

###########################################################
### File types and applications ###########################
###########################################################

file: gio-GContentType.html
class: ContentType
prefix: g_content_type_
import: glib.Str
import: glib.ListG
import: gio.File
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GFile* File
structWrap: GIcon* IconIF
array: g_content_type_guess data data_size
out: g_content_type_guess result_uncertain
outFile: ContentType

file: GAppInfo.html
struct: GAppInfo
class: AppInfoT
template: TStruct
prefix: g_app_info_
noprefix: g_app_launch_context_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AppInfoIF
import: gio.AppLaunchContext
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GAppInfo* AppInfoIF
structWrap: GAppLaunchContext* AppLaunchContext
structWrap: GIcon* IconIF
interface: AppInfoIF
outFile: AppInfoT

file:
class: AppInfo
extend: ObjectG
implements: AppInfoIF
import: gobject.ObjectG

# imports for AppInfo Interface
import: gio.AppInfoT
import: gio.AppInfoIF

code: start
	// Minimal implementation.
	mixin AppInfoT!(GAppInfo);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gAppInfo;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GAppInfo* gAppInfo)
	{
		if(gAppInfo is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gAppInfo);
		this.gAppInfo = gAppInfo;
	}
code: end
outFile: AppInfo

struct: GAppLaunchContext
class: AppLaunchContext
extend: GObject
prefix: g_app_launch_context_
strictPrefix: Y
import: glib.Str
import: glib.ListG
import: gio.AppInfoIF
structWrap: GList* ListG
structWrap: GAppInfo* AppInfoIF
outFile: AppLaunchContext

file: gio-Desktop-file-based-GAppInfo.html
struct: GDesktopAppInfo
class: DesktopAppInfo
implements: AppInfoIF
prefix: g_desktop_app_info_
import: glib.KeyFile
import: gio.AppInfo
import: gio.AppInfoIF
structWrap: GKeyFile* KeyFile
structWrap: GAppInfo* AppInfoIF

#imports for AppInfo Interface.
import: gio.AppInfoT
import: gio.AppInfoIF

nocode: g_desktop_app_info_new_from_filename

code: start
	// add the AppInfo capabilities
	mixin AppInfoT!(GDesktopAppInfo);

	public static DesktopAppInfo createFromFilename(string filename)
	{
		return new DesktopAppInfo(g_desktop_app_info_new_from_filename(Str.toStringz(filename)));
	}
code: end
outFile: DesktopAppInfo

###########################################################
### Volumes and Drives ####################################
###########################################################

file: GVolumeMonitor.html
struct: GVolumeMonitor
class: VolumeMonitor
prefix: g_volume_monitor_
import: glib.Str
import: glib.ListG
import: gio.Drive
import: gio.DriveIF
import: gio.Mount
import: gio.MountIF
import: gio.Volume
import: gio.VolumeIF
structWrap: GList* ListG
structWrap: GDrive* DriveIF
structWrap: GMount* MountIF
structWrap: GVolume* VolumeIF
structWrap: GVolumeMonitor*

nocode: g_volume_monitor_get

code: start
	/**
	 * Gets the volume monitor used by gio.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this()
	{
		// GVolumeMonitor* g_volume_monitor_get (void);
		auto p = g_volume_monitor_get();
		if(p is null)
		{
			throw new ConstructionException("g_volume_monitor_get()");
		}
		this(cast(GVolumeMonitor*) p);
	}
code: end
outFile: VolumeMonitor

file: GVolume.html
struct: GVolume
class: VolumeT
template: TStruct
prefix: g_volume_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Drive
import: gio.DriveIF
import: gio.File
import: gio.Icon
import: gio.IconIF
import: gio.Mount
import: gio.MountIF
import: gio.MountOperation
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDrive* DriveIF
structWrap: GFile* File
structWrap: GIcon* IconIF
structWrap: GMount* MountIF
structWrap: GMountOperation* MountOperation
interface: VolumeIF
outFile: VolumeT

file:
class: Volume
extend: ObjectG
implements: VolumeIF
import: gobject.ObjectG

# imports for Volume Interface
import: gio.VolumeT
import: gio.VolumeIF

code: start
	// Minimal implementation.
	mixin VolumeT!(GVolume);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gVolume;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GVolume* gVolume)
	{
		if(gVolume is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gVolume);
		this.gVolume = gVolume;
	}
code: end
outFile: Volume

file: GMount.html
struct: GMount
class: MountT
template: TStruct
prefix: g_mount_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Drive
import: gio.DriveIF
import: gio.File
import: gio.Icon
import: gio.IconIF
import: gio.MountOperation
import: gio.Volume
import: gio.VolumeIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDrive* DriveIF
structWrap: GFile* File
structWrap: GIcon* IconIF
structWrap: GMountOperation* MountOperation
structWrap: GVolume* VolumeIF
interface: MountIF
outFile: MountT

file:
class: Mount
extend: ObjectG
implements: MountIF
import: gobject.ObjectG

# imports for Mount Interface
import: gio.MountT
import: gio.MountIF

code: start
	// Minimal implementation.
	mixin MountT!(GMount);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gMount;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GMount* gMount)
	{
		if(gMount is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gMount);
		this.gMount = gMount;
	}
code: end
outFile: Mount

file: GDrive.html
struct: GDrive
class: DriveT
template: TStruct
prefix: g_drive_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Icon
import: gio.IconIF
import: gio.MountOperation
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GIcon* IconIF
structWrap: GMountOperation* MountOperation
interface: DriveIF
outFile: DriveT

file:
class: Drive
extend: ObjectG
implements: DriveIF
import: gobject.ObjectG

# imports for Drive Interface
import: gio.DriveT
import: gio.DriveIF

code: start
	// Minimal implementation.
	mixin DriveT!(GDrive);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gDrive;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GDrive* gDrive)
	{
		if(gDrive is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gDrive);
		this.gDrive = gDrive;
	}
code: end
outFile: Drive

file: gio-Unix-Mounts.html
struct: GUnixMountEntry
class: UnixMountEntry
prefix: g_unix_mount_
prefix: g_unix_
noprefix: g_unix_mount_point_
noprefix: g_unix_mount_monitor_
import: glib.Str
import: glib.ListG
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GIcon* IconIF
structWrap: GUnixMountEntry* UnixMountEntry

inout: g_unix_mounts_get time_read
inout: g_unix_mount_at time_read
nosignal: mountpoints-changed
nosignal: mounts-changed

outFile: UnixMountEntry

struct: GUnixMountPoint
class: UnixMountPoint
prefix: g_unix_mount_point_
strictPrefix: Y
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
structWrap: GUnixMountPoint* UnixMountPoint

inout: g_unix_mount_points_get time_read
nosignal: mountpoints-changed
nosignal: mounts-changed

outFile: UnixMountPoint

struct: GUnixMountMonitor
class: UnixMountMonitor
prefix: g_unix_mount_monitor_
strictPrefix: Y
outFile: UnixMountMonitor

###########################################################
### Icons #################################################
###########################################################

file: GIcon.html
struct: GIcon
class: IconT
template: TStruct
prefix: g_icon_
import: glib.Str
import: glib.ErrorG
import: glib.GException
override: toString
#Skip this one for now
nocode: g_icon_new_for_string
interface: IconIF
outFile: IconT

file:
class: Icon
extend: ObjectG
implements: IconIF
import: gobject.ObjectG

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

code: start
	// Minimal implementation.
	mixin IconT!(GIcon);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gIcon;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GIcon* gIcon)
	{
		if(gIcon is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gIcon);
		this.gIcon = gIcon;
	}
code: end
outFile: Icon

file: GFileIcon.html
struct: GFileIcon
ctorStruct: GIcon
class: FileIcon
implements: IconIF
implements: LoadableIconIF
prefix: g_file_icon_

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

#imports for LoadableIcon Interface.
import: gio.LoadableIconT
import: gio.LoadableIconIF

code: start
	// add the Icon capabilities
	mixin IconT!(GFileIcon);

	// add the LoadableIcon capabilities
	mixin LoadableIconT!(GFileIcon);
code: end
outFile: FileIcon

file: GLoadableIcon.html
struct: GLoadableIcon
class: LoadableIconT
template: TStruct
prefix: g_loadable_icon_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream

out: g_loadable_icon_load type
out: g_loadable_icon_load_finish type

interface: LoadableIconIF
outFile: LoadableIconT

file: GThemedIcon.html
struct: GThemedIcon
ctorStruct: GIcon
class: ThemedIcon
implements: IconIF
prefix: g_themed_icon_
import: glib.Str

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

array: g_themed_icon_new_from_names iconnames
nocode: g_themed_icon_new

code: start
	// add the Icon capabilities
	mixin IconT!(GThemedIcon);
code: end
outFile: ThemedIcon

file: GEmblemedIcon.html
struct: GEmblemedIcon
ctorStruct: GIcon
class: EmblemedIcon
implements: IconIF
prefix: g_emblemed_icon_
import: glib.ListG
import: gio.Emblem
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GEmblem* Emblem
structWrap: GIcon* IconIF

#imports for Icon Interface.
import: gio.IconT
#import: gio.IconIF

array: g_themed_icon_new_from_names iconnames

code: start
	// add the Icon capabilities
	mixin IconT!(GEmblemedIcon);
code: end
outFile: EmblemedIcon

file: GEmblem.html
struct: GEmblem
class: Emblem
implements: IconIF
prefix: g_emblem_
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF

#imports for Icon Interface.
import: gio.IconT
#import: gio.IconIF

array: g_themed_icon_new_from_names iconnames

code: start
	// add the Icon capabilities
	mixin IconT!(GEmblem);
code: end
outFile: Emblem

###########################################################
### Failable Initialization ###############################
###########################################################

file: GInitable.html
struct: GInitable
class: InitableT
template: TStruct
prefix: g_initable_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.Cancellable
structWrap: GObject* ObjectG
structWrap: GCancellable* Cancellable
array: g_initable_newv parameters n_parameters
interface: InitableIF
outFile: InitableT

file: GAsyncInitable.html
struct: GAsyncInitable
class: AsyncInitableT
template: TStruct
prefix: g_initable_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GObject* ObjectG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
array: g_async_initable_newv_async parameters n_parameters
interface: AsyncInitableIF
outFile: AsyncInitableT

###########################################################
### Lowlevel network support ##############################
###########################################################

file: GSocket.html
struct: GSocket
class: Socket
implements: InitableIF
prefix: g_socket_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Source
import: gio.SocketAddress
import: gio.Cancellable
import: gio.Credentials
import: gio.SocketControlMessage
structWrap: GCredentials* Credentials
structWrap: GSource* Source
structWrap: GSocketAddress* SocketAddress
structWrap: GCancellable* Cancellable
structWrap: GSocketControlMessage* SocketControlMessage

#imports for Initable Interface.
import: gio.InitableT
import: gio.InitableIF

alias: GLIB_SYSDEF_MSG_OOB 1
alias: GLIB_SYSDEF_MSG_PEEK 2
alias: GLIB_SYSDEF_MSG_DONTROUTE 4

inout: g_socket_receive_from address
array: g_socket_receive_from buffer size
inout: g_socket_receive_message address
array: g_socket_receive_message vectors num_vectors
inout: g_socket_receive_message messages
array: g_socket_receive_message messages num_messages
inout: g_socket_receive_message flags
array: g_socket_send_message vectors num_vectors
inout: g_socket_send_message messages
array: g_socket_send_message messages num_messages

code: start
	// add the Initable capabilities
	mixin InitableT!(GSocket);
code: end
outFile: Socket

file: GInetAddress.html
struct: GInetAddress
class: InetAddress
prefix: g_inet_address_
import: glib.Str
override: toString
array: g_inet_address_new_from_bytes bytes
array: g_inet_address_to_bytes Return getNativeSize()

nocode: g_inet_address_new_any
nocode: g_inet_address_new_loopback

code: start
	/**
	 * Creates a GInetAddress for the "any" address (unassigned/"don't
	 * care") for family.
	 * Since 2.22
	 * Params:
	 * family = the address family
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (GSocketFamily family, bool loopback = false)
	{
		// GInetAddress * g_inet_address_new_any (GSocketFamily family);
		GInetAddress* p;

		if ( loopback )
		{
			p = g_inet_address_new_loopback(family);
		}
		else
		{
			p = g_inet_address_new_any(family);
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by g_inet_address_new_any(family)");
		}
		this(cast(GInetAddress*) p);
	}
code: end
outFile: InetAddress

file: GSocketAddress.html
struct: GSocketAddress
class: SocketAddress
implements: SocketConnectableIF
prefix: g_socket_address_
import: glib.ErrorG
import: glib.GException

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
import: gio.SocketConnectableIF

alias: GLIB_SYSDEF_AF_UNIX 1
alias: GLIB_SYSDEF_AF_INET 2
alias: GLIB_SYSDEF_AF_INET6 23

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GSocketAddress);
code: end
outFile: SocketAddress

file: GInetSocketAddress.html
struct: GInetSocketAddress
ctorStruct: GSocketAddress
class: InetSocketAddress
prefix: g_inet_socket_address_
import: gio.InetAddress
structWrap: GInetAddress* InetAddress
outFile: InetSocketAddress

file: GUnixSocketAddress.html
struct: GUnixSocketAddress
ctorStruct: GSocketAddress
class: UnixSocketAddress
prefix: g_unix_socket_address_
import: glib.Str
array: g_unix_socket_address_new_with_type path path_len
outFile: UnixSocketAddress

file: GSocketControlMessage.html
struct: GSocketControlMessage
class: SocketControlMessage
prefix: g_socket_control_message_
structWrap: GSocketControlMessage* SocketControlMessage
outFile: SocketControlMessage

file: GUnixFDList.html
struct: GUnixFDList
class: UnixFDList
prefix: g_unix_fd_list_
import: glib.ErrorG
import: glib.GException

array: g_unix_fd_list_new_from_array fds n_fds
array: g_unix_fd_list_peek_fds Return length
array: g_unix_fd_list_steal_fds Return length
outFile: UnixFDList

file: GUnixFDMessage.html
struct: GUnixFDMessage
ctorStruct: GSocketControlMessage
class: UnixFDMessage
prefix: g_unix_fd_message_
import: glib.ErrorG
import: glib.GException
import: gio.UnixFDList
structWrap: GUnixFDList* UnixFDList
array: g_unix_fd_message_steal_fds Return length
outFile: UnixFDMessage

file: GCredentials.html
struct: GCredentials
class: Credentials
prefix: g_credentials_
override: toString
import: glib.Str
import: glib.ErrorG
import: glib.GException
structWrap: GCredentials* Credentials
outFile: Credentials

file: GUnixCredentialsMessage.html
struct: GUnixCredentialsMessage
ctorStruct: GSocketControlMessage
class: UnixCredentialsMessage
prefix: g_unix_credentials_message_
import: gio.Credentials
structWrap: GCredentials* Credentials
outFile: UnixCredentialsMessage

file: GProxy.html
struct: GProxy
class: ProxyT
template: TStruct
prefix: g_initable_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.IOStream
import: gio.ProxyAddress
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GIOStream* IOStream
structWrap: GProxy* ProxyIF
structWrap: GProxyAddress* ProxyAddress
interface: ProxyIF
outFile: ProxyT

file:
class: Proxy
extend: ObjectG
implements: ProxyIF
import: gobject.ObjectG

#imports for Proxy Interface.
import: gio.ProxyT
import: gio.ProxyIF

code: start
	// Minimal implementation.
	mixin ProxyT!(GProxy);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gProxy;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GProxy* gProxy)
	{
		if(gProxy is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gProxy);
		this.gProxy = gProxy;
	}
code: end
outFile: Proxy

file: GProxyAddress.html
struct: GProxyAddress
ctorStruct: GSocketAddress
class: ProxyAddress
prefix: g_proxy_address_
import: glib.Str
outFile: ProxyAddress

###########################################################
### Highlevel network functionallity ######################
###########################################################

file: GSocketClient.html
struct: GSocketClient
class: SocketClient
prefix: g_socket_client_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.SocketAddress
import: gio.SocketConnection
import: gio.SocketConnectableIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
structWrap: GSocketConnectable* SocketConnectableIF
outFile: SocketClient

file: GSocketConnection.html
struct: GSocketConnection
class: SocketConnection
prefix: g_socket_connection_
noprefix: g_tcp_connection_
noprefix: g_unix_connection_
import: glib.ErrorG
import: glib.GException
import: gio.Socket
import: gio.SocketAddress
structWrap: GSocket* Socket
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
outFile: SocketConnection

file: GUnixConnection.html
struct: GUnixConnection
class: UnixConnection
prefix: g_unix_connection_
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.Credentials
structWrap: GCancellable* Cancellable
structWrap: GCredentials* Credentials
outFile: UnixConnection

file: GTcpConnection.html
struct: GTcpConnection
class: TcpConnection
prefix: g_tcp_connection_
outFile: TcpConnection

file: GSocketListener.html
struct: GSocketListener
class: SocketListener
prefix: g_socket_listener_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Socket
import: gio.SocketAddress
import: gio.SocketConnection
structWrap: GObject* ObjectG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
structWrap: GSocket* Socket

out: g_socket_listener_add_address effective_address
out: g_socket_listener_accept source_object
inout: g_socket_listener_accept_finish source_object
out: g_socket_listener_accept_socket source_object
inout: g_socket_listener_accept_socket_finish source_object
outFile: SocketListener

file: GSocketService.html
struct: GSocketService
class: SocketService
prefix: g_socket_service_
outFile: SocketService

file: GThreadedSocketService.html
struct: GThreadedSocketService
ctorStruct: GSocketService
class: ThreadedSocketService
prefix: g_threaded_socket_service_
outFile: ThreadedSocketService

###########################################################
### TLS (SSL) Support #####################################
###########################################################

file: GTlsCertificate.html
struct: GTlsCertificate
class: TlsCertificate
prefix: g_tls_certificate_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.SocketConnectableIF
structWrap: GList* ListG
structWrap: GSocketConnectable* SocketConnectableIF
structWrap: GTlsCertificate* TlsCertificate
array: g_tls_certificate_new_from_pem data length
openFile: TlsCertificate

file: gio-TLS-Overview.html
closeFile: TlsCertificate

file: GTlsConnection.html
struct: GTlsConnection
ctorStruct: GIOStream
class: TlsConnection
prefix: g_tls_connection_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.TlsCertificate
structWrap: GCancellable* Cancellable
structWrap: GTlsCertificate* TlsCertificate
outFile: TlsConnection

file: GTlsClientConnection.html
struct: GTlsClientConnection
ctorStruct: GIOStream
class: TlsClientConnection
extend: GTlsConnection
prefix: g_tls_client_connection_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.IOStream
import: gio.SocketConnectable
import: gio.SocketConnectableIF
structWrap: GList* ListG
structWrap: GIOStream* IOStream
structWrap: GSocketConnectable* SocketConnectableIF
outFile: TlsClientConnection

file: GTlsServerConnection.html
struct: GTlsServerConnection
ctorStruct: GIOStream
class: TlsServerConnection
extend: GTlsConnection
prefix: g_tls_server_connection_
import: glib.ErrorG
import: glib.GException
import: gio.IOStream
import: gio.TlsCertificate
structWrap: GIOStream* IOStream
structWrap: GTlsCertificate* TlsCertificate
outFile: TlsServerConnection

file: GTlsBackend.html
struct: GTlsBackend
class: TlsBackend
prefix: g_tls_backend_
structWrap: GTlsBackend* TlsBackend
outFile: TlsBackend

###########################################################
### DNS resolution ########################################
###########################################################

file: GResolver.html
struct: GResolver
class: Resolver
prefix: g_resolver_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GResolver* Resolver
outFile: Resolver

file: GProxyResolver.html
struct: GProxyResolver
class: ProxyResolverT
template: TStruct
prefix: g_proxy_resolver_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.ProxyResolver
import: gio.ProxyResolverIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GProxyResolver* ProxyResolverIF
interface: ProxyResolverIF
outFile: ProxyResolverT

file:
class: ProxyResolver
extend: ObjectG
implements: ProxyResolverIF
import: gobject.ObjectG

#imports for ProxyResolver Interface.
import: gio.ProxyResolverT
import: gio.ProxyResolverIF

code: start
	// Minimal implementation.
	mixin ProxyResolverT!(GProxyResolver);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gProxyResolver;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GProxyResolver* gProxyResolver)
	{
		if(gProxyResolver is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gProxyResolver);
		this.gProxyResolver = gProxyResolver;
	}
code: end
outFile: ProxyResolver

file: GSocketConnectable.html
struct: GSocketConnectable
class: SocketConnectableT
template: TStruct
prefix: g_socket_connectable_
noprefix: g_socket_address_enumerator_
import: gio.SocketAddressEnumerator
structWrap: GSocketAddressEnumerator* SocketAddressEnumerator
interface: SocketConnectableIF
outFile: SocketConnectableT

file:
class: SocketConnectable
extend: ObjectG
implements: SocketConnectableIF
import: gobject.ObjectG

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
import: gio.SocketConnectableIF

code: start
	// Minimal implementation.
	mixin SocketConnectableT!(GSocketConnectable);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gSocketConnectable;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GSocketConnectable* gSocketConnectable)
	{
		if(gSocketConnectable is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gSocketConnectable);
		this.gSocketConnectable = gSocketConnectable;
	}
code: end
outFile: SocketConnectable

struct: GSocketAddressEnumerator
class: SocketAddressEnumerator
prefix: g_socket_address_enumerator_
strictPrefix: Y
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.SocketAddress
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketAddress* SocketAddress
outFile: SocketAddressEnumerator

file: GNetworkAddress.html
struct: GNetworkAddress
ctorStruct: GSocketConnectable
class: NetworkAddress
implements: SocketConnectableIF
prefix: g_network_address_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.SocketConnectable
import: gio.SocketConnectableIF
structWrap: GSocketConnectable* SocketConnectableIF

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
#import: gio.SocketConnectableIF

nocode: g_network_address_parse

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GNetworkAddress);

	/**
	 * Creates a new GSocketConnectable for connecting to the given
	 * hostname and port. May fail and return NULL in case
	 * parsing host_and_port fails.
	 * host_and_port may be in any of a number of recognised formats: an IPv6
	 * address, an IPv4 address, or a domain name (in which case a DNS
	 * lookup is performed). Quoting with [] is supported for all address
	 * types. A port override may be specified in the usual way with a
	 * colon. Ports may be given as decimal numbers or symbolic names (in
	 * which case an /etc/services lookup is performed).
	 * If no port is specified in host_and_port then default_port will be
	 * used as the port number to connect to.
	 * In general, host_and_port is expected to be provided by the user
	 * (allowing them to give the hostname, and a port overide if necessary)
	 * and default_port is expected to be provided by the application.
	 * Since 2.22
	 * Params:
	 * hostAndPort =  the hostname and optionally a port
	 * defaultPort =  the default port if not in host_and_port
	 * Returns: the new GNetworkAddress, or NULL on error
	 * Throws: GException on failure.
	 */
	public static SocketConnectableIF parse(string hostAndPort, ushort defaultPort)
	{
		// GSocketConnectable * g_network_address_parse (const gchar *host_and_port,  guint16 default_port,  GError **error);
		GError* err = null;
		
		auto p = g_network_address_parse(Str.toStringz(hostAndPort), defaultPort, &err);
		
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		if(p is null)
		{
			return null;
		}
		return new NetworkAddress(cast(GNetworkAddress*) p);
	}
code: end
outFile: NetworkAddress

file: GNetworkService.html
struct: GNetworkService
ctorStruct: GSocketConnectable
class: NetworkService
implements: SocketConnectableIF
prefix: g_network_service_
import: glib.Str

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
import: gio.SocketConnectableIF

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GNetworkService);
code: end
outFile: NetworkService

file: GSrvTarget.html
struct: GSrvTarget
class: SrvTarget
prefix: g_srv_target_
import: glib.Str
import: glib.ListG
structWrap: GList* ListG
structWrap: GSrvTarget* SrvTarget
outFile: SrvTarget

###########################################################
### Lowlevel D-Bus Support ################################
###########################################################

file: gio-D-Bus-Utilities.html
class: DBusUtilities
prefix: g_dbus_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.StringG
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.IOStream
openFile: DBusUtilities

file: gio-D-Bus-Addresses.html
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GIOStream* IOStream
out: g_dbus_address_get_stream_finish out_guid
out: g_dbus_address_get_stream_sync out_guid
mergeFile: DBusUtilities

file: gio-D-Bus-Introspection-Data.html
structWrap: GString* StringG
closeFile: DBusUtilities

file: GDBusError.html
struct: GError
class: DBusError
prefix: g_dbus_error_
import: glib.Str
import: glib.ErrorG
structWrap: GError* ErrorG
array: g_dbus_error_register_error_domain entries num_entries
out: g_dbus_error_register_error_domain quark_volatile
out: g_dbus_error_set_dbus_error error
out: g_dbus_error_set_dbus_error_valist error
outFile: DBusError

file: GDBusMessage.html
struct: GDBusMessage
class: DBusMessage
prefix: g_dbus_message_
alias: body bod
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Variant
import: gio.UnixFDList
structWrap: GError* ErrorG
structWrap: GVariant* Variant
structWrap: GDBusMessage* DBusMessage
structWrap: GUnixFDList* UnixFDList
array: g_dbus_message_to_blob Return out_size
array: g_dbus_message_bytes_needed blob blob_len
array: g_dbus_message_new_from_blob blob blob_len
out: g_dbus_message_to_gerror error
outFile: DBusMessage

file: GDBusConnection.html
struct: GDBusConnection
class: DBusConnection
extend: GObject
implements: InitableIF
implements: AsyncInitableIF
prefix: g_dbus_connection_
prefix: g_dbus_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Variant
import: glib.VariantType
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Credentials
import: gio.DBusAuthObserver
import: gio.DBusMessage
import: gio.DBusMethodInvocation
import: gio.IOStream
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GCredentials* Credentials
structWrap: GDBusAuthObserver* DBusAuthObserver
structWrap: GDBusConnection* DBusConnection
structWrap: GDBusMessage* DBusMessage
structWrap: GDBusMethodInvocation* DBusMethodInvocation
structWrap: GIOStream* IOStream

#imports for Initable Interface.
import: gio.InitableT
import: gio.InitableIF

#imports for AsyncInitable Interface.
import: gio.AsyncInitableT
import: gio.AsyncInitableIF

out: g_dbus_connection_send_message out_serial
out: g_dbus_connection_send_message_with_reply out_serial
out: g_dbus_connection_send_message_with_reply_sync out_serial

nocode: g_dbus_connection_new_finish
nocode: g_dbus_connection_new_for_address_finish

code: start
	// add the Initable capabilities
	mixin InitableT!(DBusConnection);

	// add the AsyncInitable capabilities
	mixin AsyncInitableT!(DBusConnection);

	/**
	 * Finishes an operation started with g_dbus_connection_new().
	 * Since 2.26
	 * Params:
	 *      res    = A GAsyncResult obtained from the GAsyncReadyCallback
	 *               passed to g_dbus_connection_new().
	 *     address = If true finish an address.
	 * Throws: GException on failure.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (AsyncResultIF res, bool address = false)
	{
		// GDBusConnection * g_dbus_connection_new_finish (GAsyncResult *res,  GError **error);
		GError* err = null;
		GDBusConnection* p;
		
		if ( address )
		{
			p = g_dbus_connection_new_for_address_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}
		else
		{
			p = g_dbus_connection_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}

		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		if(p is null)
		{
			throw new ConstructionException("null returned by g_dbus_connection_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err)");
		}
		this(cast(GDBusConnection*) p);
	}	
code: end
outFile: DBusConnection

file: GDBusMethodInvocation.html
struct: GDBusMethodInvocation
class: DBusMethodInvocation
prefix: g_dbus_method_invocation_
import: glib.Str
import: glib.ErrorG
import: glib.Variant
import: gio.DBusConnection
import: gio.DBusMessage
structWrap: GError* ErrorG
structWrap: GVariant* Variant
structWrap: GDBusConnection* DBusConnection
structWrap: GDBusMessage* DBusMessage
outFile: DBusMethodInvocation

file: GDBusServer.html
struct: GDBusServer
class: DBusServer
implements: InitableIF
prefix: g_dbus_server_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.DBusAuthObserver
structWrap: GCancellable* Cancellable
structWrap: GDBusAuthObserver* DBusAuthObserver

#imports for Initable Interface.
import: gio.InitableT
import: gio.InitableIF

code: start
	// add the Initable capabilities
	mixin InitableT!(GDBusServer);
code: end
outFile: DBusServer

file: GDBusAuthObserver.html
struct: GDBusAuthObserver
class: DBusAuthObserver
prefix: g_dbus_auth_observer_
import: gio.Credentials
import: gio.IOStream
structWrap: GCredentials* Credentials
structWrap: GIOStream* IOStream
outFile: DBusAuthObserver

###########################################################
### HighLevel D-Bus Support ###############################
###########################################################

file: gio-Owning-Bus-Names.html
class: DBusNames
prefix: g_bus_
import: glib.Str
import: gobject.Closure
import: gio.DBusConnection
structWrap: GClosure* Closure
structWrap: GDBusConnection* DBusConnection
openFile: DBusNames

file: gio-Watching-Bus-Names.html
structWrap: GClosure* Closure
structWrap: GDBusConnection* DBusConnection
closeFile: DBusNames

file: GDBusProxy.html
struct: GDBusProxy
class: DBusProxy
extend: GObject
prefix: g_dbus_proxy_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Variant
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.DBusConnection
structWrap: GVariant* Variant
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDBusConnection* DBusConnection

nocode: g_dbus_proxy_new_finish
nocode: g_dbus_proxy_new_for_bus_finish

code: start
/**
	 * Finishes creating a GDBusProxy.
	 * Since 2.26
	 * Params:
	 *     res    = A GAsyncResult obtained from the GAsyncReadyCallback
	 *              function passed to g_dbus_proxy_new().
	 *     forBus = If true finish an address.
	 * Throws: GException on failure.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (AsyncResultIF res, bool forBus = false)
	{
		// GDBusProxy * g_dbus_proxy_new_finish (GAsyncResult *res,  GError **error);
		GError* err = null;
		GDBusProxy* p;

		if ( forBus )
		{
			p = g_dbus_proxy_new_for_bus_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}
		else
		{
			p = g_dbus_proxy_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}
	
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		if(p is null)
		{
			throw new ConstructionException("null returned by g_dbus_proxy_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err)");
		}
		this(cast(GDBusProxy*) p);
	}
code: end
outFile: DBusProxy

###########################################################
### Utilities #############################################
###########################################################

file: GFilenameCompleter.html
struct: GFilenameCompleter
class: FilenameCompleter
prefix: g_filename_completer_
import: glib.Str
outFile: FilenameCompleter

###########################################################
### Settings ##############################################
###########################################################

file: GSettings.html
struct: GSettings
class: Settings
prefix: g_settings_
import: glib.Str
import: glib.Variant
import: glib.VariantType
import: gobject.Value
import: gio.SettingsBackend
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
structWrap: GValue* Value
structWrap: GSettings* Settings
structWrap: GSettingsBackend* SettingsBackend
array: g_settings_set_strv value
outFile: Settings

file: GSettingsBackend.html
struct: GSettingsBackend
class: SettingsBackend
prefix: g_settings_backend_
prefix: g_
import: glib.Str
import: glib.BBTree
import: glib.Variant
structWrap: GTree* BBTree
structWrap: GVariant* Variant
structWrap: GSettingsBackend* SettingsBackend
out: g_settings_backend_flatten_tree path
out: g_settings_backend_flatten_tree keys
out: g_settings_backend_flatten_tree values
array: g_settings_backend_flatten_tree keys
array: g_settings_backend_flatten_tree values keys.length
outFile: SettingsBackend

###########################################################
### Permissions ###########################################
###########################################################

file: GPermission.html
struct: GPermission
class: Permission
prefix: g_permission_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
outFile: Permission

file: GSimplePermission.html
struct: GSimplePermission
ctorStruct: GPermission
class: SimplePermission
prefix: g_simple_permission_
outFile: SimplePermission

###########################################################
### Application Support ###################################
###########################################################

file: GActionGroup.html
struct: GActionGroup
class: ActionGroupT
template: TStruct
prefix: g_action_group_
import: glib.Str
import: glib.Variant
import: glib.VariantType
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
interface: ActionGroupIF
outFile: ActionGroupT

file: GSimpleActionGroup.html
struct: GSimpleActionGroup
class: SimpleActionGroup
implements: ActionGroupIF
prefix: g_simple_action_group_
import: glib.Str
import: gio.Action
import: gio.ActionIF
structWrap: GAction* ActionIF

#imports for ActionGroup Interface.
import: gio.ActionGroupIF
import: gio.ActionGroupT

code: start
	// add the ActionGroup capabilities
	mixin ActionGroupT!(GSimpleActionGroup);
code: end
outFile: SimpleActionGroup

file: GAction.html
struct: GAction
class: ActionT
template: TStruct
prefix: g_action_
import: glib.Str
import: glib.Variant
import: glib.VariantType
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
interface: ActionIF
outFile: ActionT

file:
class: Action
extend: ObjectG
implements: ActionIF
import: gobject.ObjectG

# imports for Converter Interface
import: gio.ActionT
import: gio.ActionIF

code: start
	// Minimal implementation.
	mixin ActionT!(GAction);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gAction;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GAction* gAction)
	{
		if(gAction is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gAction);
		this.gAction = gAction;
	}
code: end
outFile: Action

file: GSimpleAction.html
struct: GSimpleAction
class: SimpleAction
implements: ActionIF
prefix: g_simple_action_
import: glib.Str
import: glib.Variant
import: glib.VariantType
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType

#imports for Action Interface.
import: gio.ActionIF
import: gio.ActionT

code: start
	// add the Action capabilities
	mixin ActionT!(GSimpleAction);
code: end
outFile: SimpleAction

file: GApplication.html
struct: GApplication
class: Application
implements: ActionGroupIF
prefix: g_application_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.File
structWrap: GCancellable* Cancellable
structWrap: GFile* File

#imports for ActionGroup Interface.
import: gio.ActionGroupIF
import: gio.ActionGroupT

array: g_application_open files n_files
array: g_application_run argv argc

code: start
	// add the ActionGroup capabilities
	mixin ActionGroupT!(GApplication);
code: end
outFile: Application

file: GApplicationCommandLine.html
struct: GApplicationCommandLine
class: ApplicationCommandLine
prefix: g_application_command_line_
import: glib.Str
import: glib.Variant
structWrap: GVariant* Variant
array: g_application_command_line_get_arguments Return argc
outFile: ApplicationCommandLine

###########################################################
### Extending GIO #########################################
###########################################################

file: GVfs.html
struct: GVfs
class: Vfs
prefix: g_vfs_
import: glib.Str
import: gio.File
structWrap: GFile* File
structWrap: GVfs* Vfs
outFile: Vfs

file: GIOModule.html
struct: GIOModule
class: IOModule
prefix: g_io_module_
prefix: g_io_
import: glib.Str
import: glib.ListG
structWrap: GList* ListG
outFile: IOModule

file: gio-Extension-Points.html
struct: GIOExtension
class: IOExtension
prefix: g_io_extension_
noprefix: g_io_extension_point_
import: glib.Str
structWrap: GIOExtension* IOExtension
outFile: IOExtension

struct: GIOExtensionPoint
class: IOExtensionPoint
prefix: g_io_extension_point_
strictPrefix: Y
import: glib.Str
import: glib.ListG
import: gio.IOExtension
structWrap: GList* ListG
structWrap: GIOExtension* IOExtension
structWrap: GIOExtensionPoint* IOExtensionPoint
outFile: IOExtensionPoint
