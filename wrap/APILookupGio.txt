#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


#
###
#####
# Definitions for wrapping GObject
#####
###
#


addTypedefs: start

public import gtkc.glibtypes;
public import gtkc.gobjecttypes;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
public enum GConverterFlags
{
  NO_FLAGS     = 0,
  INPUT_AT_END = 1 << 0,
  FLUSH        = 1 << 1
}
addEnums: end

addStructs: start
addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end

# must start with wrap
wrap: gio

###########################################################
### File Operations #######################################
###########################################################

file: GFile.html
struct: GFile
class: File
extend: GObject
prefix: g_file_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AppInfo
import: gio.AppInfoIF
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileAttributeInfoList
import: gio.FileEnumerator
import: gio.FileInfo
import: gio.FileInputStream
import: gio.FileIOStream
import: gio.FileMonitor
import: gio.FileOutputStream
import: gio.Mount
import: gio.MountIF
import: gio.MountOperation
structWrap: GAppInfo* AppInfoIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFile* File
structWrap: GFileAttributeInfoList* FileAttributeInfoList
structWrap: GFileEnumerator* FileEnumerator
structWrap: GFileInfo* FileInfo
structWrap: GFileInputStream* FileInputStream
structWrap: GFileIOStream* FileIOStream
structWrap: GFileMonitor* FileMonitor
structWrap: GFileOutputStream* FileOutputStream
structWrap: GMount* MountIF
structWrap: GMountOperation* MountOperation

out: g_file_set_attributes_finish info
out: g_file_load_contents contents
out: g_file_load_contents length
out: g_file_load_contents etag_out
out: g_file_load_contents_finish contents
out: g_file_load_contents_finish length
out: g_file_load_contents_finish etag_out
out: g_file_load_partial_contents_finish contents
out: g_file_load_partial_contents_finish  length
out: g_file_load_partial_contents_finish etag_out
out: g_file_replace_contents new_etag
out: g_file_replace_contents_finish new_etag

# g_file_new_for_commandline_arg also accepts paths ans uris
nocode: g_file_new_for_path
nocode: g_file_new_for_uri

outFile: File


file: gio-GFileAttribute.html
struct: GFileAttributeInfoList
class: FileAttributeInfoList
prefix:  g_file_attribute_info_list_
import: glib.Str
structWrap: GFileAttributeInfoList* FileAttributeInfoList
outFile: FileAttributeInfoList

file: GFileInfo.html
struct: GFileInfo
class: FileInfo
prefix: g_file_info_
noprefix: g_file_attribute_matcher_
import: glib.Str
import: glib.TimeVal
import: gobject.ObjectG
import: gio.Icon
import: gio.IconIF
import: gio.FileAttributeMatcher
structWrap: GTimeVal* TimeVal
structWrap: GObject* ObjectG
structWrap: GIcon* IconIF
structWrap: GFileAttributeMatcher* FileAttributeMatcher
structWrap: GFileInfo* FileInfo

out: g_file_info_get_attribute_data type
out: g_file_info_get_attribute_data value_pp
out: g_file_info_get_attribute_data status
array: g_file_info_set_attribute_stringv attr_value

outFile: FileInfo


struct: GFileAttributeMatcher
class: FileAttributeMatcher
prefix: g_file_attribute_matcher_
strictPrefix: Y
import: glib.Str
structWrap: GFileAttributeMatcher* FileAttributeMatcher
outFile: FileAttributeMatcher

file: GFileEnumerator.html
struct: GFileEnumerator
class: FileEnumerator
prefix: g_file_enumerator_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.File
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFile* File
outFile: FileEnumerator

file: gio-GIOError.html
class: ErrorGIO
prefix: g_io_error_
outFile: ErrorGIO

file: GMountOperation.html
struct: GMountOperation
class: MountOperation
prefix: g_mount_operation_
import: glib.Str
import: glib.ArrayG
structWrap: GArray* ArrayG
outFile: MountOperation

###########################################################
### File System Monitoring ################################
###########################################################

file: GFileMonitor.html
struct: GFileMonitor
class: FileMonitor
prefix: g_file_monitor_
import: gio.File
structWrap: GFile* File
outFile: FileMonitor

###########################################################
### Asynchronous I/O ######################################
###########################################################

file: GCancellable.html
struct: GCancellable
class: Cancellable
prefix: g_cancellable_
import: glib.ErrorG
import: glib.GException
structWrap: GCancellable* Cancellable
outFile: Cancellable

file: GAsyncResult.html
struct: GAsyncResult
class: AsyncResultT
template: TStruct
prefix: g_async_result_
import: gobject.ObjectG
structWrap: GObject* ObjectG
interface: AsyncResultIF
outFile: AsyncResultT

file: gio-GIOScheduler.html
struct: GIOSchedulerJob
class: IOSchedulerJob
prefix: g_io_scheduler_job_
prefix: g_io_scheduler_
import: gio.Cancellable
structWrap: GCancellable* Cancellable
outFile: IOSchedulerJob

file: GSimpleAsyncResult.html
struct: GSimpleAsyncResult
class: SimpleAsyncResult
prefix: g_simple_async_result_
implements: AsyncResultIF
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.Cancellable
structWrap: GError* ErrorG
structWrap: GObject* ObjectG
structWrap: GCancellable* Cancellable

#imports for AsyncResult Interface.
import: gio.AsyncResultIF
import: gio.AsyncResultT

code: start
	// add the AsyncResult capabilities
	mixin AsyncResultT!(GSimpleAsyncResult);
code: end
outFile: SimpleAsyncResult

###########################################################
### Data conversion #######################################
###########################################################

file: GConverter.html
struct: GConverter
class: ConverterT
template: TStruct
prefix: g_converter_
import: glib.ErrorG
import: glib.GException

array: g_converter_convert inbuf inbuf_size
array: g_converter_convert outbuf outbuf_size
out: g_converter_convert bytes_read
out: g_converter_convert bytes_written

interface: ConverterIF
outFile: ConverterT

file: GCharsetConverter.html
struct: GCharsetConverter
class: CharsetConverter
implements: ConverterIF
prefix: g_charset_converter_
import: glib.Str
import: glib.ErrorG
import: glib.GException

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GCharsetConverter);
code: end
outFile: CharsetConverter

file: GZlibCompressor.html
struct: GZlibCompressor
class: ZlibCompressor
implements: ConverterIF
prefix: g_zlib_compressor_

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GZlibCompressor);
code: end
outFile: ZlibCompressor

file: GZlibDecompressor.html
struct: GZlibDecompressor
class: ZlibDecompressor
implements: ConverterIF
prefix: g_zlib_decompressor_

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GZlibDecompressor);
code: end
outFile: ZlibDecompressor

###########################################################
### Streaming I/O #########################################
###########################################################

file: GSeekable.html
struct: GSeekable
class: SeekableT
template: TStruct
prefix: g_seekable_
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
structWrap: GCancellable* Cancellable
interface: SeekableIF
outFile: SeekableT

file: GInputStream.html
struct: GInputStream
class: InputStream
prefix: g_input_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
out: g_input_stream_read_all bytes_read
outFile: InputStream

file: GOutputStream.html
struct: GOutputStream
class: OutputStream
prefix: g_output_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
out: g_output_stream_write_all bytes_read
outFile: OutputStream

file: GIOStream.html
struct: GIOStream
class: IOStream
prefix: g_io_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
import: gio.OutputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
structWrap: GOutputStream* OutputStream
outFile: IOStream

file: GFileInputStream.html
struct: GFileInputStream
class: FileInputStream
implements: SeekableIF
prefix: g_file_input_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileInputStream);
code: end
outFile: FileInputStream

file: GFileOutputStream.html
struct: GFileOutputStream
class: FileOutputStream
implements: SeekableIF
prefix: g_file_output_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileOutputStream);
code: end
outFile: FileOutputStream

file: GFileIOStream.html
struct: GFileIOStream
class: FileIOStream
implements: SeekableIF
prefix: g_file_io_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileIOStream);
code: end
outFile: FileIOStream

file: GFileDescriptorBased.html
struct: GFileDescriptorBased
class: FileDescriptorBasedT
template: TStruct
prefix: g_file_descriptor_based_
interface: FileDescriptorBasedIF
outFile: FileDescriptorBasedT

file: GFilterInputStream.html
struct: GFilterInputStream
class: FilterInputStream
prefix: g_filter_input_stream_
import: gio.InputStream
structWrap: GInputStream* InputStream
outFile: FilterInputStream

file: GFilterOutputStream.html
struct: GFilterOutputStream
class: FilterOutputStream
prefix: g_filter_output_stream_
import: gio.OutputStream
structWrap: GOutputStream* OutputStream
outFile: FilterOutputStream

file: GMemoryInputStream.html
struct: GMemoryInputStream
ctorStruct: GInputStream
class: MemoryInputStream
implements: SeekableIF
prefix: g_memory_input_stream_

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GMemoryInputStream);
code: end
outFile: MemoryInputStream

file: GMemoryOutputStream.html
struct: GMemoryOutputStream
ctorStruct: GOutputStream
class: MemoryOutputStream
implements: SeekableIF
prefix: g_memory_output_stream_

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GMemoryOutputStream);
code: end
outFile: MemoryOutputStream

file: GBufferedInputStream.html
struct: GBufferedInputStream
ctorStruct: GInputStream
class: BufferedInputStream
prefix: g_buffered_input_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
out: g_buffered_input_stream_peek_buffer count
outFile: BufferedInputStream

file: GBufferedOutputStream.html
struct: GBufferedOutputStream
ctorStruct: GOutputStream
class: BufferedOutputStream
prefix: g_buffered_output_stream_
import: gio.OutputStream
structWrap: GOutputStream* OutputStream
outFile: BufferedOutputStream

file: GDataInputStream.html
struct: GDataInputStream
class: DataInputStream
prefix: g_data_input_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.InputStream
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
out: g_data_input_stream_read_line length
out: g_data_input_stream_read_until length
out: g_data_input_stream_read_line_finish result
out: g_data_input_stream_read_until_finish result

nocode: g_data_input_stream_read_byte
outFile: DataInputStream

file: GDataOutputStream.html
struct: GDataOutputStream
class: DataOutputStream
prefix: g_data_output_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.OutputStream
structWrap: GCancellable* Cancellable
structWrap: GOutputStream* OutputStream
outFile: DataOutputStream

file: GUnixInputStream.html
struct: GUnixInputStream
ctorStruct: GInputStream
class: UnixInputStream
implements: FileDescriptorBasedIF
prefix: g_unix_input_stream_

#imports for FileDescriptorBased Interface.
import: gio.FileDescriptorBasedT
import: gio.FileDescriptorBasedIF

code: start
	// add the FileDescriptorBased capabilities
	mixin FileDescriptorBasedT!(GUnixInputStream);
code: end
outFile: UnixInputStream

file: GUnixOutputStream.html
struct: GUnixOutputStream
ctorStruct: GOutputStream
class: UnixOutputStream
implements: FileDescriptorBasedIF
prefix: g_unix_output_stream_

#imports for FileDescriptorBased Interface.
import: gio.FileDescriptorBasedT
import: gio.FileDescriptorBasedIF

code: start
	// add the FileDescriptorBased capabilities
	mixin FileDescriptorBasedT!(GUnixOutputStream);
code: end
outFile: UnixOutputStream

###########################################################
### File types and applications ###########################
###########################################################

file: gio-GContentType.html
class: ContentType
prefix: g_content_type_
import: glib.Str
import: glib.ListG
import: gio.File
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GFile* File
structWrap: GIcon* IconIF
array: g_content_type_guess data data_size
out: g_content_type_guess result_uncertain
outFile: ContentType

file: GAppInfo.html
struct: GAppInfo
class: AppInfoT
template: TStruct
prefix: g_app_info_
noprefix: g_app_launch_context_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AppInfoIF
import: gio.AppLaunchContext
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GAppInfo* AppInfoIF
structWrap: GAppLaunchContext* AppLaunchContext
structWrap: GIcon* IconIF
interface: AppInfoIF
outFile: AppInfoT

file:
class: AppInfo
extend: ObjectG
implements: AppInfoIF
import: gobject.ObjectG

# imports for AppInfo Interface
import: gio.AppInfoT
import: gio.AppInfoIF

code: start
	// Minimal implementation.
	mixin AppInfoT!(GAppInfo);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gAppInfo;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GAppInfo* gAppInfo)
	{
		if(gAppInfo is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gAppInfo);
		this.gAppInfo = gAppInfo;
	}
code: end
outFile: AppInfo

struct: GAppLaunchContext
class: AppLaunchContext
prefix: g_app_launch_context_
strictPrefix: Y
import: glib.Str
import: glib.ListG
import: gio.AppInfoIF
structWrap: GList* ListG
structWrap: GAppInfo* AppInfoIF
outFile: AppLaunchContext

file: gio-Desktop-file-based-GAppInfo.html
struct: GDesktopAppInfo
class: DesktopAppInfo
implements: AppInfoIF
prefix: g_desktop_app_info_
import: glib.KeyFile
import: gio.AppInfo
import: gio.AppInfoIF
structWrap: GKeyFile* KeyFile
structWrap: GAppInfo* AppInfoIF

#imports for AppInfo Interface.
import: gio.AppInfoT
import: gio.AppInfoIF

nocode: g_desktop_app_info_new_from_filename

code: start
	// add the AppInfo capabilities
	mixin AppInfoT!(GDesktopAppInfo);

	public static DesktopAppInfo createFromFilename(string filename)
	{
		return new DesktopAppInfo(g_desktop_app_info_new_from_filename(Str.toStringz(filename)));
	}
code: end
outFile: DesktopAppInfo

###########################################################
### Volumes and Drives ####################################
###########################################################

file: GVolumeMonitor.html
struct: GVolumeMonitor
class: VolumeMonitor
prefix: g_volume_monitor_
import: glib.Str
import: glib.ListG
import: gio.Drive
import: gio.DriveIF
import: gio.Mount
import: gio.MountIF
import: gio.Volume
import: gio.VolumeIF
structWrap: GList* ListG
structWrap: GDrive* DriveIF
structWrap: GMount* MountIF
structWrap: GVolume* VolumeIF
structWrap: GVolumeMonitor*

nocode: g_volume_monitor_get

code: start
	/**
	 * Gets the volume monitor used by gio.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this()
	{
		// GVolumeMonitor* g_volume_monitor_get (void);
		auto p = g_volume_monitor_get();
		if(p is null)
		{
			throw new ConstructionException("g_volume_monitor_get()");
		}
		this(cast(GVolumeMonitor*) p);
	}
code: end
outFile: VolumeMonitor

file: GVolume.html
struct: GVolume
class: VolumeT
template: TStruct
prefix: g_volume_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Drive
import: gio.DriveIF
import: gio.File
import: gio.Icon
import: gio.IconIF
import: gio.Mount
import: gio.MountIF
import: gio.MountOperation
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDrive* DriveIF
structWrap: GFile* File
structWrap: GIcon* IconIF
structWrap: GMount* MountIF
structWrap: GMountOperation* MountOperation
interface: VolumeIF
outFile: VolumeT

file:
class: Volume
extend: ObjectG
implements: VolumeIF
import: gobject.ObjectG

# imports for Volume Interface
import: gio.VolumeT
import: gio.VolumeIF

code: start
	// Minimal implementation.
	mixin VolumeT!(GVolume);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gVolume;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GVolume* gVolume)
	{
		if(gVolume is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gVolume);
		this.gVolume = gVolume;
	}
code: end
outFile: Volume

file: GMount.html
struct: GMount
class: MountT
template: TStruct
prefix: g_mount_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Drive
import: gio.DriveIF
import: gio.File
import: gio.Icon
import: gio.IconIF
import: gio.MountOperation
import: gio.Volume
import: gio.VolumeIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDrive* DriveIF
structWrap: GFile* File
structWrap: GIcon* IconIF
structWrap: GMountOperation* MountOperation
structWrap: GVolume* VolumeIF
interface: MountIF
outFile: MountT

file:
class: Mount
extend: ObjectG
implements: MountIF
import: gobject.ObjectG

# imports for Mount Interface
import: gio.MountT
import: gio.MountIF

code: start
	// Minimal implementation.
	mixin MountT!(GMount);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gMount;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GMount* gMount)
	{
		if(gMount is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gMount);
		this.gMount = gMount;
	}
code: end
outFile: Mount

file: GDrive.html
struct: GDrive
class: DriveT
template: TStruct
prefix: g_drive_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Icon
import: gio.IconIF
import: gio.MountOperation
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GIcon* IconIF
structWrap: GMountOperation* MountOperation
interface: DriveIF
outFile: DriveT

file:
class: Drive
extend: ObjectG
implements: DriveIF
import: gobject.ObjectG

# imports for Drive Interface
import: gio.DriveT
import: gio.DriveIF

code: start
	// Minimal implementation.
	mixin DriveT!(GDrive);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gDrive;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GDrive* gDrive)
	{
		if(gDrive is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gDrive);
		this.gDrive = gDrive;
	}
code: end
outFile: Drive

file: gio-Unix-Mounts.html
struct: GUnixMountEntry
class: UnixMountEntry
prefix: g_unix_mount_
prefix: g_unix_
noprefix: g_unix_mount_point_
noprefix: g_unix_mount_monitor_
import: glib.Str
import: glib.ListG
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GIcon* IconIF
structWrap: GUnixMountEntry* UnixMountEntry

inout: g_unix_mounts_get time_read
inout: g_unix_mount_at time_read
nosignal: mountpoints-changed
nosignal: mounts-changed

outFile: UnixMountEntry

struct: GUnixMountPoint
class: UnixMountPoint
prefix: g_unix_mount_point_
strictPrefix: Y
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
structWrap: GUnixMountPoint* UnixMountPoint

inout: g_unix_mount_points_get time_read
nosignal: mountpoints-changed
nosignal: mounts-changed

outFile: UnixMountPoint

struct: GUnixMountMonitor
class: UnixMountMonitor
prefix: g_unix_mount_monitor_
strictPrefix: Y
outFile: UnixMountMonitor

###########################################################
### Icons #################################################
###########################################################

file: GIcon.html
struct: GIcon
class: IconT
template: TStruct
prefix: g_icon_
import: glib.Str
import: glib.ErrorG
import: glib.GException
override: toString
#Skip this one for now
nocode: g_icon_new_for_string
interface: IconIF
outFile: IconT

file:
class: Icon
extend: ObjectG
implements: IconIF
import: gobject.ObjectG

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

code: start
	// Minimal implementation.
	mixin IconT!(GIcon);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gIcon;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GIcon* gIcon)
	{
		if(gIcon is null)
		{
			this = null;
			return;
		}

		super(cast(GObject*)gIcon);
		this.gIcon = gIcon;
	}
code: end
outFile: Icon

file: GFileIcon.html
struct: GFileIcon
ctorStruct: GIcon
class: FileIcon
implements: IconIF
implements: LoadableIconIF
prefix: g_file_icon_

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

#imports for LoadableIcon Interface.
import: gio.LoadableIconT
import: gio.LoadableIconIF

code: start
	// add the Icon capabilities
	mixin IconT!(GFileIcon);

	// add the LoadableIcon capabilities
	mixin LoadableIconT!(GFileIcon);
code: end
outFile: FileIcon

file: GLoadableIcon.html
struct: GLoadableIcon
class: LoadableIconT
template: TStruct
prefix: g_loadable_icon_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream

out: g_loadable_icon_load type
out: g_loadable_icon_load_finish type

interface: LoadableIconIF
outFile: LoadableIconT

file: GThemedIcon.html
struct: GThemedIcon
ctorStruct: GIcon
class: ThemedIcon
implements: IconIF
prefix: g_themed_icon_
import: glib.Str

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

array: g_themed_icon_new_from_names iconnames
nocode: g_themed_icon_new

code: start
	// add the Icon capabilities
	mixin IconT!(GThemedIcon);
code: end
outFile: ThemedIcon

file: GEmblemedIcon.html
struct: GEmblemedIcon
ctorStruct: GIcon
class: EmblemedIcon
implements: IconIF
prefix: g_emblemed_icon_
import: glib.ListG
import: gio.Emblem
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GEmblem* Emblem
structWrap: GIcon* IconIF

#imports for Icon Interface.
import: gio.IconT
#import: gio.IconIF

array: g_themed_icon_new_from_names iconnames

code: start
	// add the Icon capabilities
	mixin IconT!(GEmblemedIcon);
code: end
outFile: EmblemedIcon

file: GEmblem.html
struct: GEmblem
class: Emblem
implements: IconIF
prefix: g_emblem_
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF

#imports for Icon Interface.
import: gio.IconT
#import: gio.IconIF

array: g_themed_icon_new_from_names iconnames

code: start
	// add the Icon capabilities
	mixin IconT!(GEmblem);
code: end
outFile: Emblem

###########################################################
### Failable Initialization ###############################
###########################################################

file: GInitable.html
struct: GInitable
class: InitableT
template: TStruct
prefix: g_initable_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.Cancellable
structWrap: GObject* ObjectG
structWrap: GCancellable* Cancellable
array: g_initable_newv parameters n_parameters
interface: InitableIF
outFile: InitableT

file: GAsyncInitable.html
struct: GAsyncInitable
class: AsyncInitableT
template: TStruct
prefix: g_initable_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GObject* ObjectG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
array: g_async_initable_newv_async parameters n_parameters
interface: AsyncInitableIF
outFile: AsyncInitableT

###########################################################
### Lowlevel platform-independent network support #########
###########################################################

file: GSocket.html
struct: GSocket
class: Socket
implements: InitableIF
prefix: g_socket_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Source
import: gio.SocketAddress
import: gio.Cancellable
import: gio.SocketControlMessage
structWrap: GSource* Source
structWrap: GSocketAddress* SocketAddress
structWrap: GCancellable* Cancellable
structWrap: GSocketControlMessage* SocketControlMessage

#imports for Initable Interface.
import: gio.InitableT
import: gio.InitableIF

alias: GLIB_SYSDEF_MSG_OOB 1
alias: GLIB_SYSDEF_MSG_PEEK 2
alias: GLIB_SYSDEF_MSG_DONTROUTE 4

inout: g_socket_receive_from address
array: g_socket_receive_from buffer size
inout: g_socket_receive_message address
array: g_socket_receive_message vectors num_vectors
inout: g_socket_receive_message messages
array: g_socket_receive_message messages num_messages
inout: g_socket_receive_message flags
array: g_socket_send_message vectors num_vectors
inout: g_socket_send_message messages
array: g_socket_send_message messages num_messages

code: start
	// add the Initable capabilities
	mixin InitableT!(GSocket);
code: end
outFile: Socket

file: GInetAddress.html
struct: GInetAddress
class: InetAddress
prefix: g_inet_address_
import: glib.Str
array: g_inet_address_new_from_bytes bytes
array: g_inet_address_to_bytes Return getNativeSize()
outFile: InetAddress

file: GSocketAddress.html
struct: GSocketAddress
class: SocketAddress
implements: SocketConnectableIF
prefix: g_socket_address_
import: glib.ErrorG
import: glib.GException

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
import: gio.SocketConnectableIF

alias: GLIB_SYSDEF_AF_UNIX 1
alias: GLIB_SYSDEF_AF_INET 2
alias: GLIB_SYSDEF_AF_INET6 23

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GSocketAddress);
code: end
outFile: SocketAddress

file: GInetSocketAddress.html
struct: GInetSocketAddress
ctorStruct: GSocketAddress
class: InetSocketAddress
prefix: g_inet_socket_address_
import: gio.InetAddress
structWrap: GInetAddress* InetAddress
outFile: InetSocketAddress

file: GUnixSocketAddress.html
struct: GUnixSocketAddress
ctorStruct: GSocketAddress
class: UnixSocketAddress
prefix: g_unix_socket_address_
import: glib.Str
outFile: UnixSocketAddress

file: GSocketControlMessage.html
struct: GSocketControlMessage
class: SocketControlMessage
prefix: g_socket_control_message_
structWrap: GSocketControlMessage* SocketControlMessage
outFile: SocketControlMessage

file: GUnixFDList.html
struct: GUnixFDList
class: UnixFDList
prefix: g_unix_fd_list_
import: glib.ErrorG
import: glib.GException

array: g_unix_fd_list_new_from_array fds n_fds
array: g_unix_fd_list_peek_fds Return length
array: g_unix_fd_list_steal_fds Return length
outFile: UnixFDList

file: GUnixFDMessage.html
struct: GUnixFDMessage
ctorStruct: GSocketControlMessage
class: UnixFDMessage
prefix: g_unix_fd_message_
import: glib.ErrorG
import: glib.GException
import: gio.UnixFDList
structWrap: GUnixFDList* UnixFDList
array: g_unix_fd_message_steal_fds Return length
outFile: UnixFDMessage

###########################################################
### DNS resolution ########################################
###########################################################

file: GResolver.html
struct: GResolver
class: Resolver
prefix: g_resolver_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GResolver* Resolver
outFile: Resolver

file: GSocketConnectable.html
struct: GSocketConnectable
class: SocketConnectableT
template: TStruct
prefix: g_socket_connectable_
strictPrefix: Y
import: gio.SocketAddressEnumerator
structWrap: GSocketAddressEnumerator* SocketAddressEnumerator
interface: SocketConnectableIF
outFile: SocketConnectableT

struct: GSocketAddressEnumerator
class: SocketAddressEnumerator
prefix: g_socket_address_enumerator_
noprefix: g_socket_connectable_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.SocketAddress
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketAddress* SocketAddress
outFile: SocketAddressEnumerator

file: GNetworkAddress.html
struct: GNetworkAddress
ctorStruct: GSocketConnectable
class: NetworkAddress
implements: SocketConnectableIF
prefix: g_network_address_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.SocketConnectableIF
structWrap: GSocketConnectable* SocketConnectableIF

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
#import: gio.SocketConnectableIF

nocode: g_network_address_parse

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GNetworkAddress);

	/**
	 * Creates a new GSocketConnectable for connecting to the given
	 * hostname and port. May fail and return NULL in case
	 * parsing host_and_port fails.
	 * host_and_port may be in any of a number of recognised formats: an IPv6
	 * address, an IPv4 address, or a domain name (in which case a DNS
	 * lookup is performed). Quoting with [] is supported for all address
	 * types. A port override may be specified in the usual way with a
	 * colon. Ports may be given as decimal numbers or symbolic names (in
	 * which case an /etc/services lookup is performed).
	 * If no port is specified in host_and_port then default_port will be
	 * used as the port number to connect to.
	 * In general, host_and_port is expected to be provided by the user
	 * (allowing them to give the hostname, and a port overide if necessary)
	 * and default_port is expected to be provided by the application.
	 * Since 2.22
	 * Params:
	 * hostAndPort =  the hostname and optionally a port
	 * defaultPort =  the default port if not in host_and_port
	 * Returns: the new GNetworkAddress, or NULL on error
	 * Throws: GException on failure.
	 */
	public static SocketConnectableIF parse(string hostAndPort, ushort defaultPort)
	{
		// GSocketConnectable * g_network_address_parse (const gchar *host_and_port,  guint16 default_port,  GError **error);
		GError* err = null;
		
		auto p = g_network_address_parse(Str.toStringz(hostAndPort), defaultPort, &err);
		
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		if(p is null)
		{
			return null;
		}
		return new NetworkAddress(cast(GNetworkAddress*) p);
	}
code: end
outFile: NetworkAddress

file: GNetworkService.html
struct: GNetworkService
ctorStruct: GSocketConnectable
class: NetworkService
implements: SocketConnectableIF
prefix: g_network_service_
import: glib.Str

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
import: gio.SocketConnectableIF

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GNetworkService);
code: end
outFile: NetworkService

file: gio-GSrvTarget.html
struct: GSrvTarget
class: SrvTarget
prefix: g_srv_target_
import: glib.Str
import: glib.ListG
structWrap: GList* ListG
structWrap: GSrvTarget* SrvTarget
outFile: SrvTarget

###########################################################
### Highlevel network functionallity ######################
###########################################################

file: GSocketClient.html
struct: GSocketClient
class: SocketClient
prefix: g_socket_client_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.SocketAddress
import: gio.SocketConnection
import: gio.SocketConnectableIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
structWrap: GSocketConnectable* SocketConnectableIF
outFile: SocketClient

file: GSocketConnection.html
struct: GSocketConnection
class: SocketConnection
prefix: g_socket_connection_
noprefix: g_tcp_connection_
noprefix: g_unix_connection_
import: glib.ErrorG
import: glib.GException
import: gio.Socket
import: gio.SocketAddress
structWrap: GSocket* Socket
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
outFile: SocketConnection

struct: GTcpConnection
class: TcpConnection
prefix: g_tcp_connection_
strictPrefix: Y
outFile: TcpConnection

struct: GUnixConnection
class: UnixConnection
prefix:  g_unix_connection_
strictPrefix: Y
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
structWrap: GCancellable* Cancellable
outFile: UnixConnection

file: GSocketListener.html
struct: GSocketListener
class: SocketListener
prefix: g_socket_listener_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Socket
import: gio.SocketAddress
import: gio.SocketConnection
structWrap: GObject* ObjectG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
structWrap: GSocket* Socket

out: g_socket_listener_add_address effective_address
out: g_socket_listener_accept source_object
inout: g_socket_listener_accept_finish source_object
out: g_socket_listener_accept_socket source_object
inout: g_socket_listener_accept_socket_finish source_object

outFile: SocketListener

file: GSocketService.html
struct: GSocketService
class: SocketService
prefix: g_socket_service_
outFile: SocketService

file: GThreadedSocketService.html
struct: GThreadedSocketService
ctorStruct: GSocketService
class: ThreadedSocketService
prefix: g_threaded_socket_service_
outFile: ThreadedSocketService

###########################################################
### Utilities #############################################
###########################################################

file: GFilenameCompleter.html
struct: GFilenameCompleter
class: FilenameCompleter
prefix: g_filename_completer_
import: glib.Str
outFile: FilenameCompleter

###########################################################
### Extending GIO #########################################
###########################################################

file: GVfs.html
struct: GVfs
class: Vfs
prefix: g_vfs_
import: glib.Str
import: gio.File
structWrap: GFile* File
structWrap: GVfs* Vfs
outFile: Vfs

file: GIOModule.html
struct: GIOModule
class: IOModule
prefix: g_io_module_
prefix: g_io_
import: glib.Str
import: glib.ListG
structWrap: GList* ListG
outFile: IOModule

file: gio-Extension-Points.html
struct: GIOExtension
class: IOExtension
prefix: g_io_extension_
noprefix: g_io_extension_point_
import: glib.Str
structWrap: GIOExtension* IOExtension
outFile: IOExtension

struct: GIOExtensionPoint
class: IOExtensionPoint
prefix: g_io_extension_point_
strictPrefix: Y
import: glib.Str
import: glib.ListG
import: gio.IOExtension
structWrap: GList* ListG
structWrap: GIOExtension* IOExtension
structWrap: GIOExtensionPoint* IOExtensionPoint
outFile: IOExtensionPoint
