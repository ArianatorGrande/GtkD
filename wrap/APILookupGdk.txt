#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


#
###
#####
# Definitions for wrapping Gdk
#####
###
#


addTypedefs: start

public import gtkc.glibtypes;
public import gtkc.gobjecttypes;
public import gtkc.pangotypes;
public import gtkc.gdkpixbuftypes;

alias void* GdkAtom;
alias void* GdkNativeWindow;

const int GDK_MAX_TIMECOORD_AXES = 128;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
addEnums: end

addStructs: start
addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end


# must start with wrap

wrap: gdk

###########################################################
### Gdk ###################################################
###########################################################

file: gdk-General.html
class: Gdk
prefix: gdk_
import: glib.Str
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Cursor
structWrap: GdkCursor* Cursor
outFile: Gdk

#file: multihead.html
#struct: 
#class: 
#prefix: 
#outFile: 

file: GdkDisplay.html
struct: GdkDisplay
class: Display
prefix: gdk_display_
import: glib.Str
structWrap: GdkDisplay* Display
import: gdk.Screen
structWrap: GdkScreen* Screen
import: glib.ListG
structWrap: GList* ListG
import: gdk.Event
structWrap: GdkEvent* Event
#import: gdk.Screen*
#structWrap: GdkScreen** Screen*
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType
import: gdk.Window
structWrap: GdkWindow* Window
#import: gdk.DisplayPointerHooks
#structWrap: GdkDisplayPointerHooks* DisplayPointerHooks
#import: gdk.Atom
#structWrap: GdkAtom* Atom

out: gdk_display_get_pointer x
out: gdk_display_get_pointer y
out: gdk_display_get_pointer mask
out: gdk_display_get_window_at_pointer win_x
out: gdk_display_get_window_at_pointer win_y
out: gdk_display_get_maximal_cursor_size width
out: gdk_display_get_maximal_cursor_size height

outFile: Display

file: GdkDisplayManager.html
struct: GdkDisplayManager
class: DisplayManager
prefix: gdk_display_manager_
structWrap: GdkDisplayManager* DisplayManager
import: gdk.Display
structWrap: GdkDisplay* Display
import: glib.ListSG
structWrap: GSList* ListSG
import: gdk.Device
structWrap: GdkDevice* Device
outFile: DisplayManager

file: GdkScreen.html
struct: GdkScreen
class: Screen
prefix: gdk_screen_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: cairo.FontOption
structWrap: cairo_font_options_t* FontOption
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Visual
structWrap: GdkVisual* Visual
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Display
structWrap: GdkDisplay* Display
import: glib.ListG
structWrap: GList* ListG
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gdk.Event
structWrap: GdkEvent* Event
import: gobject.Value
structWrap: GValue* Value
outFile: Screen

file: gdk-Points-Rectangles-and-Regions.html

struct: GdkRectangle
class: Rectangle
prefix: gdk_rectangle_
noprefix: gdk_region_
structWrap: GdkRectangle* Rectangle
outFile: Rectangle

struct: GdkRegion
class: Region
prefix: gdk_region_
strictPrefix: Yes
structWrap: GdkRegion* Region
#import: gdk.Point
#structWrap: GdkPoint* Point
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
#import: gdk.Rectangle*
#structWrap: GdkRectangle** Rectangle*
#import: gdk.Span
#structWrap: GdkSpan* Span
outFile: Region

file: gdk-Graphics-Contexts.html
struct: GdkGC
class: GC
prefix: gdk_gc_
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
#import: gdk.GCValues
#structWrap: GdkGCValues* GCValues
import: gdk.Screen
structWrap: GdkScreen* Screen
structWrap: GdkGC* GC
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Font
structWrap: GdkFont* Font
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gdk.Region
structWrap: GdkRegion* Region
import: gdk.Colormap
structWrap: GdkColormap* Colormap
outFile: GC

file: gdk-Drawing-Primitives.html
struct: GdkDrawable
class: Drawable
prefix: gdk_drawable_
prefix: gdk_
import: glib.Str
structWrap: GdkDrawable* Drawable
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gdk.Visual
structWrap: GdkVisual* Visual
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Region
structWrap: GdkRegion* Region
import: gdk.GC
structWrap: GdkGC* GC
#import: gdk.Point
#structWrap: GdkPoint* Point
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
#import: gdk.Segment
#structWrap: GdkSegment* Segment
#import: gdk.Trapezoid
#structWrap: GdkTrapezoid* Trapezoid
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Font
structWrap: GdkFont* Font
#import: gdk.WChar
#structWrap: GdkWChar* WChar
import: gdk.ImageGdk
structWrap: GdkImage* ImageGdk

import: pango.PgFont
structWrap: PangoFont* PgFont
import: pango.PgGlyphString
structWrap: PangoGlyphString* PgGlyphString
import: pango.PgMatrix
structWrap: PangoMatrix* PgMatrix
import: pango.PgLayout
structWrap: PangoLayout* PgLayout

override: getData

out: gdk_drawable_get_size width
out: gdk_drawable_get_size height
 
code: start
	/**
	 * Draws an outlined or filled polygon.
	 * Params:
	 *  gc = a GdkGC.
	 *  filled = TRUE if the polygon should be filled. The polygon is closed
	 *  automatically, connecting the last point to the first point if
	 *  necessary.
	 *  points = an array of GdkPoint structures specifying the points making
	 *  up the polygon.
	 */
	public void drawPolygon(GC gc, int filled, GdkPoint[] points)
	{
		// void gdk_draw_polygon (GdkDrawable *drawable,  GdkGC *gc,  gboolean filled,  GdkPoint *points,  gint npoints);
		gdk_draw_polygon(gdkDrawable, gc.getGCStruct(), filled, points.ptr, points.length);
	}

	/** */
	public void drawPixbuf(Pixbuf pixbuf, int destX, int destY)
	{
		drawPixbuf(null, pixbuf, destX, destY);
	}

	/** */
	public void drawPixbuf(GC gc, Pixbuf pixbuf, int destX, int destY)
	{
		if ( pixbuf is null ) return;
		gdk_draw_pixbuf(gdkDrawable, 
						(gc is null) ? null : gc.getGCStruct(), 
						pixbuf.getPixbufStruct(), 
						0, 0, destX, destY, 
						pixbuf.getWidth(), pixbuf.getHeight(), 
						GdkRgbDither.NORMAL, 
						0, 0);
	}
code: end

outFile: Drawable

file: gdk-Bitmaps-and-Pixmaps.html

struct: GdkPixmap
class: Pixmap
prefix: gdk_pixmap_
noprefix: gdk_bitmap_
import: glib.Str
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
structWrap: GdkPixmap* Pixmap
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Colormap
structWrap: GdkColormap* Colormap

out: gdk_pixmap_create_from_xpm mask
out: gdk_pixmap_create_from_xpm_d mask
out: gdk_pixmap_colormap_create_from_xpm mask
out: gdk_pixmap_colormap_create_from_xpm_d mask

outFile: Pixmap

struct: GdkBitmap
class: Bitmap
prefix: gdk_bitmap_
strictPrefix: Yes
import: glib.Str
structWrap: GdkBitmap* Bitmap
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
outFile: Bitmap

file: gdk-GdkRGB.html
class: RGB
prefix: gdk_
noprefix: gdk_rgb_cmap_
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
import: gdk.GC
structWrap: GdkGC* GC
import: gdk.RgbCmap
structWrap: GdkRgbCmap* RgbCmap
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Visual
structWrap: GdkVisual* Visual
outFile: RGB

struct: GdkRgbCmap
class: RgbCmap
strictPrefix: Y
prefix: gdk_rgb_cmap_

code: start
	/**
	 * Creates a new GdkRgbCmap structure. The cmap maps color indexes to
	 * RGB colors. If n_colors is less than 256, then images containing
	 * color values greater than or equal to n_colors will produce undefined
	 * results, including possibly segfaults.
	 * Params:
	 * colors = The colors, represented as 0xRRGGBB integer values.
	 */
	public this (uint[] colors)
	{
		// GdkRgbCmap* gdk_rgb_cmap_new (guint32 *colors,  gint n_colors);
		auto p = gdk_rgb_cmap_new(cast(uint*)(colors.ptr), colors.length);
		if(p is null)
		{
			throw new ConstructionException("null returned by gdk_rgb_cmap_new(cast(uint*)(colors.ptr), colors.length)");
		}
		this(cast(GdkRgbCmap*) p);
	}
code: end
outFile: RgbCmap

file: gdk-Images.html
struct: GdkImage
class: ImageGdk
prefix: gdk_image_
structWrap: GdkImage* ImageGdk
import: gdk.Visual
structWrap: GdkVisual* Visual
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
import: gdk.Colormap
structWrap: GdkColormap* Colormap
outFile: ImageGdk

## move to GdkPixbuf? no?
## extend GdkPixbuf? Yes?



file: gdk-Pixbufs.html
struct: GdkPixbuf
class: Pixbuf
prefix: gdk_pixbuf_
noprefix: gdk_pixbuf_ref
noprefix: gdk_pixbuf_unref
import: glib.Str
import: glib.ErrorG
import: glib.GException
structWrap: GdkPixbuf* Pixbuf
import: gdkpixbuf.PixbufFormat
structWrap: GdkPixbufFormat* PixbufFormat
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.GC
structWrap: GdkGC* GC
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.ImageGdk
structWrap: GdkImage* ImageGdk

# this will create a new pixbuf but the wrapper will pass the existing pixbuf struct
nocode: gdk_pixbuf_get_from_drawable

code: start
	/**
	 * Transfers image data from a GdkDrawable and converts it to an RGB(A)
	 * representation inside a GdkPixbuf. In other words, copies
	 * image data from a server-side drawable to a client-side RGB(A) buffer.
	 * This allows you to efficiently read individual pixels on the client side.
	 * If the drawable src has no colormap (gdk_drawable_get_colormap()
	 * returns NULL), then a suitable colormap must be specified.
	 * Typically a GdkWindow or a pixmap created by passing a GdkWindow
	 * to gdk_pixmap_new() will already have a colormap associated with
	 * it. If the drawable has a colormap, the cmap argument will be
	 * ignored. If the drawable is a bitmap (1 bit per pixel pixmap),
	 * then a colormap is not required; pixels with a value of 1 are
	 * assumed to be white, and pixels with a value of 0 are assumed to be
	 * black. For taking screenshots, gdk_colormap_get_system() returns
	 * the correct colormap to use.
	 * If the specified destination pixbuf dest is NULL, then this
	 * function will create an RGB pixbuf with 8 bits per channel and no
	 * alpha, with the same size specified by the width and height
	 * arguments. In this case, the dest_x and dest_y arguments must be
	 * specified as 0. If the specified destination pixbuf is not NULL
	 * and it contains alpha information, then the filled pixels will be
	 * set to full opacity (alpha = 255).
	 * If the specified drawable is a pixmap, then the requested source
	 * rectangle must be completely contained within the pixmap, otherwise
	 * the function will return NULL. For pixmaps only (not for windows)
	 * passing -1 for width or height is allowed to mean the full width
	 * or height of the pixmap.
	 * If the specified drawable is a window, and the window is off the
	 * screen, then there is no image data in the obscured/offscreen
	 * regions to be placed in the pixbuf. The contents of portions of the
	 * pixbuf corresponding to the offscreen region are undefined.
	 * If the window you're obtaining data from is partially obscured by
	 * other windows, then the contents of the pixbuf areas corresponding
	 * to the obscured regions are undefined.
	 * If the target drawable is not mapped (typically because it's
	 * iconified/minimized or not on the current workspace), then NULL
	 * will be returned.
	 * If memory can't be allocated for the return value, NULL will be returned
	 * instead.
	 * (In short, there are several ways this function can fail, and if it fails
	 *  it returns NULL; so check the return value.)
	 * This function calls gdk_drawable_get_image() internally and
	 * converts the resulting image to a GdkPixbuf, so the
	 * documentation for gdk_drawable_get_image() may also be relevant.
	 * Params:
	 * 	src = Source drawable.
	 *  cmap = A colormap if src doesn't have one set.
	 *  srcX = Source X coordinate within drawable.
	 *  srcY = Source Y coordinate within drawable.
	 *  destX = Destination X coordinate in pixbuf, or 0 if dest is NULL.
	 *  destY = Destination Y coordinate in pixbuf, or 0 if dest is NULL.
	 *  width = Width in pixels of region to get.
	 *  height = Height in pixels of region to get.
	 * Returns:
	 *  The same pixbuf as dest if it was non-NULL, or a newly-created
	 *  pixbuf with a reference count of 1 if no destination pixbuf was specified, or NULL on error
	 */
	public Pixbuf getFromDrawable(Drawable src, Colormap cmap, int srcX, int srcY, int destX, int destY, int width, int height)
	{
		// GdkPixbuf* gdk_pixbuf_get_from_drawable (GdkPixbuf *dest,  GdkDrawable *src,  GdkColormap *cmap,  int src_x,  int src_y,  int dest_x,  int dest_y,  int width,  int height);
		return new Pixbuf( gdk_pixbuf_get_from_drawable(null, (src is null) ? null : src.getDrawableStruct(), (cmap is null) ? null : cmap.getColormapStruct(), srcX, srcY, destX, destY, width, height) );
	}
	
	/**
	 * SetFromDrawable is different from GetFrom Drawable as it doesn't create a new pixbuf
	 */
	public void setFromDrawable(Drawable src, int srcX, int srcY, int width, int height)
	{
		gdk_pixbuf_get_from_drawable(
					gdkPixbuf,	// gdkPixbuf
					src.getDrawableStruct(), 
					null, // colormap 
					srcX, srcY, 
					0, 0,		// destination x and y 
					width, height);
	}
	
	/**
	 * Creates a new Pixbuf from a drawable.
	 * this is a simplyfied GetFromDrawable
	 */
	this(Drawable src, int srcX, int srcY, int width, int height)
	{
		GdkPixbuf* pb = gdk_pixbuf_get_from_drawable(
					null,	// gdkPixbuf
					src.getDrawableStruct(), 
					null, // colormap 
					srcX, srcY, 
					0, 0,		// destination x and y 
					width, height);
		this(pb); 
	}
	
code: end

openFile: Pixbuf

file: ../gdk-pixbuf/gdk-pixbuf-creating.html
struct: GdkPixbuf
class: Pixbuf

text: start
gdk_pixbuf_get_type ()

GType         gdk_pixbuf_get_type           ();
<hr>
text: end

mergeFile: Pixbuf

file: ../gdk-pixbuf/gdk-pixbuf-gdk-pixbuf.html
mergeFile:  Pixbuf

file: ../gdk-pixbuf/gdk-pixbuf-refcounting.html
mergeFile:  Pixbuf

file: ../gdk-pixbuf/gdk-pixbuf-file-loading.html
noprefix: gdk_pixbuf_get_file_info 
mergeFile:  Pixbuf

file: ../gdk-pixbuf/gdk-pixbuf-file-saving.html
mergeFile:  Pixbuf

file: ../gdk-pixbuf/gdk-pixbuf-scaling.html
mergeFile:  Pixbuf

file: ../gdk-pixbuf/gdk-pixbuf-util.html
closeFile:  Pixbuf

file: gdk-Colormaps-and-Colors.html

struct: GdkColormap
class: Colormap
prefix: gdk_colormap_
prefix: gdk_
noprefix: gdk_color_
import: gdk.Visual
structWrap: GdkVisual* Visual
structWrap: GdkColormap* Colormap
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Screen
structWrap: GdkScreen* Screen
outFile: Colormap

struct: GdkColor
class: Color
prefix: gdk_color_
import: glib.Str
strictPrefix: Yes
structWrap: GdkColor* Color
import: gdk.Colormap
structWrap: GdkColormap* Colormap

override: toString

code: start

	static Color _black;
	static Color _white;

	/**
	 * Creates a new Color
	 */
	this()
	{
		this(new GdkColor);
	}

	/** */
	this(ubyte red, ubyte green, ubyte blue)
	{
		this();
		set8(red, green, blue);
	}
	
	/**
	 * Creates a new Color with RGB values
	 * Params:	
	 *  red =
	 *  green =
	 *  blue =
	 */
	this(guint16 red, guint16 green, guint16 blue)
	{
		this();
		//printf("Color.this red , green , blue = %d %d %d\n", red, green, blue);
		set(red,green,blue);
	}

	/** */
	this(uint rgb)
	{
		this();
		//printf("Color.this uint %X\n",rgb);
		set( cast(ushort)((rgb&0xFFFF)),cast(ushort)((rgb&0xFFFF00000000)>>32),cast(ushort)((rgb&0xFFFF0000)>>16));
	}

	/** */
	this(int rgb)
	{
		this();
		//printf("Color.this int %X\n",rgb);
		set8( cast(ubyte)((rgb&0xFF0000)>>16),cast(ubyte)((rgb&0x00FF00)>>8),cast(ubyte)(rgb&0xFF));
	}

	/** */
	static Color black()
	{
		if ( !_black )
		{
			_black = new Color(cast(ubyte)0,cast(ubyte)0,cast(ubyte)0);
		}
		return _black;
	}

	/** */
	static Color white()
	{
		if ( !_white )
		{
			_white = new Color(cast(ubyte)255,cast(ubyte)255,cast(ubyte)255);
		}
		return _white;
	}
	
	/**
	 * Sets the Color with RGB values
	 * Params:
	 *  red =
	 *  green =
	 *  blue =
	 */
	void set(guint16 red, guint16 green, guint16 blue)
	{
		//printf("Color.set %X %X %X\n",red,green,blue);
		gdkColor.red = red;
		gdkColor.green = green;
		gdkColor.blue = blue;
		gdkColor.pixel = (red&0xFF00 << 8) | (green&0xFF00) | (blue >> 8) ;
		//printf("Color.pixel %X \n",gdkColor.pixel);
		//allocColor();
		//printf("set pixel = %X\n", gdkColor.pixel);
	}

	/** */
	void set8(ubyte red, ubyte green, ubyte blue)
	{
		//printf("Color.set %X %X %X\n",red,green,blue);
		
		gdkColor.red = cast(ushort)(red * 257);
		gdkColor.green = cast(ushort)(green * 257);
		gdkColor.blue = cast(ushort)(blue * 257);
		gdkColor.pixel = (red << 16) | (green << 8 ) | blue;
		//printf("set8 pixel = %X\n", gdkColor.pixel);
	}
	
	/** */
	uint getValue()
	{
		return (gdkColor.red <<32) | (gdkColor.green << 16) | (gdkColor.blue);
	}
	
	/** */
	int getValue24()
	{
		return ((gdkColor.red&0xFF00)<<8 ) | ((gdkColor.green&0xFF00)) | ((gdkColor.blue&0xFF00) >>8);
	}
	
	/** */
	uint getPixelValue()
	{
		return gdkColor.pixel;
	}
	
code: end
outFile: Color

file: gdk-Visuals.html
struct: GdkVisual
class: Visual
prefix: gdk_visual_
#import: gdk.VisualType*
#structWrap: GdkVisualType** VisualType*
import: glib.ListG
structWrap: GList* ListG
structWrap: GdkVisual* Visual
import: gdk.Screen
structWrap: GdkScreen* Screen

nocode: gdk_query_depths

code: start
	/**
	 * This function returns the available bit depths for the default
	 * screen. It's equivalent to listing the visuals
	 * (gdk_list_visuals()) and then looking at the depth field in each
	 * visual, removing duplicates.
	 * The array returned by this function should not be freed.
	 * Params:
	 * depths =  return location for available depths
	 */
	public static void gdkQueryDepths(out int[] depths)
	{
		int* dep = null;
		int count;

		// void gdk_query_depths (gint **depths,  gint *count);
		gdk_query_depths(&dep, &count);

		depths = dep[0 .. count];
	}
code: end
outFile: Visual

file: gdk-Fonts.html
struct: GdkFont
class: Font
prefix: gdk_font_
prefix: gdk_
import: glib.Str
structWrap: GdkFont* Font
import: gdk.Display
structWrap: GdkDisplay* Display
import: pango.PgFontDescription
structWrap: PangoFontDescription* PgFontDescription
#import: gdk.WChar
#structWrap: GdkWChar* WChar

code: start
	/**
	 * Create and loads a font
	 */
	public this(string fontName)
	{
		this(gdk_font_load(Str.toStringz(fontName)));
	}
code: end
outFile: Font

file: gdk-Cursors.html
struct: GdkCursor
class: Cursor
prefix: gdk_cursor_
import: glib.Str
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkCursor* Cursor
outFile: Cursor

file: gdk-Windows.html
struct: GdkWindow
class: Window
prefix: gdk_window_
noprefix: gdk_window_invalidate_maybe_recurse
import: glib.Str
#import: gdk.WindowAttr
#structWrap: GdkWindowAttr* WindowAttr
structWrap: GdkWindow* Window
import: gdk.Region
structWrap: GdkRegion* Region
#import: gdk.Geometry
#structWrap: GdkGeometry* Geometry
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
#import: gdk.Drawable*
#structWrap: GdkDrawable** Drawable*
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdk.Cursor
structWrap: GdkCursor* Cursor
import: glib.ListG
structWrap: GList* ListG
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType
#import: gdk.WMDecoration
#structWrap: GdkWMDecoration* WMDecoration
#import: gdk.PointerHooks
#structWrap: GdkPointerHooks* PointerHooks

out: gdk_window_at_pointer win_x
out: gdk_window_at_pointer win_y

outFile: Window

file: gdk-Events.html
struct: GdkEvent
class: Event
prefix: gdk_event_
import: glib.Str
structWrap: GdkEvent* Event
import: gdk.Window
structWrap: GdkWindow* Window
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gobject.Value
structWrap: GValue* Value

code: start
	/** */
	public static bool isDoubleClick(GdkEventButton* eventButton, int buttonNumber=1)
	{
		return eventButton.button==buttonNumber 
				&& eventButton.type == EventType.DOUBLE_BUTTON_PRESS;
	}

	/** */
	public static bool isTripleClick(GdkEventButton* eventButton, int buttonNumber=1)
	{
		return eventButton.button==buttonNumber 
				&& eventButton.type == EventType.TRIPLE_BUTTON_PRESS;
	}
code: end

outFile: Event

file: gdk-Event-Structures.html
#struct: 
#class: 
#prefix: 
outFile: EventStruct

file: gdk-Keyboard-Handling.html
struct: GdkKeymap
class: Keymap
prefix: gdk_keymap_
import: glib.Str
structWrap: GdkKeymap* Keymap
import: gdk.Display
structWrap: GdkDisplay* Display
#import: gdk.KeymapKey
#structWrap: GdkKeymapKey* KeymapKey
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType
#import: gdk.KeymapKey*
#structWrap: GdkKeymapKey** KeymapKey*

out: gdk_keymap_translate_keyboard_state keyval
out: gdk_keymap_translate_keyboard_state effective_group
out: gdk_keymap_translate_keyboard_state level
out: gdk_keymap_translate_keyboard_state consumed_modifiers
#out: gdk_keymap_get_entries_for_keyval keys
#out: gdk_keymap_get_entries_for_keyval n_keys
#out: gdk_keymap_get_entries_for_keycode keys
#out: gdk_keymap_get_entries_for_keycode n_keys
out: gdk_keyval_convert_case lower
out: gdk_keyval_convert_case upper

code: start
/**
	 * Obtains a list of keycode/group/level combinations that will
	 * generate keyval. Groups and levels are two kinds of keyboard mode;
	 * in general, the level determines whether the top or bottom symbol
	 * on a key is used, and the group determines whether the left or
	 * right symbol is used. On US keyboards, the shift key changes the
	 * keyboard level, and there are no groups. A group switch key might
	 * convert a keyboard between Hebrew to English modes, for example.
	 * GdkEventKey contains a group field that indicates the active
	 * keyboard group. The level is computed from the modifier mask.
	 * The returned array should be freed
	 * with g_free().
	 * Params:
	 * keyval =  a keyval, such as GDK_a, GDK_Up, GDK_Return, etc.
	 * keys =  return location for an array of GdkKeymapKey
	 * Returns: TRUE if keys were found and returned
	 */
	public int getEntriesForKeyval(uint keyval, out GdkKeymapKey[] keys)
	{
		GdkKeymapKey* gdkkeys = null;
		int nKeys;

		// gboolean gdk_keymap_get_entries_for_keyval (GdkKeymap *keymap,  guint keyval,  GdkKeymapKey **keys,  gint *n_keys);
		int i = gdk_keymap_get_entries_for_keyval(gdkKeymap, keyval, &gdkkeys, &nKeys);

		keys = gdkkeys[0 .. nKeys];

		return i;
	}
	
	/**
	 * Returns the keyvals bound to hardware_keycode.
	 * The Nth GdkKeymapKey in keys is bound to the Nth
	 * keyval in keyvals. Free the returned arrays with g_free().
	 * When a keycode is pressed by the user, the keyval from
	 * this list of entries is selected by considering the effective
	 * keyboard group and level. See gdk_keymap_translate_keyboard_state().
	 * Params:
	 * hardwareKeycode =  a keycode
	 * keys =  return location for array of GdkKeymapKey, or NULL
	 * keyvals =  return location for array of keyvals, or NULL
	 * Returns: TRUE if there were any entries
	 */
	public int getEntriesForKeycode(uint hardwareKeycode, out GdkKeymapKey[] keys, uint[] keyvals)
	{
		GdkKeymapKey* gdkkeys = null;
		uint* gdkkeyvals = null;
		int  nEntries;

		// gboolean gdk_keymap_get_entries_for_keycode (GdkKeymap *keymap,  guint hardware_keycode,  GdkKeymapKey **keys,  guint **keyvals,  gint *n_entries);
		int i = gdk_keymap_get_entries_for_keycode(gdkKeymap, hardwareKeycode, &gdkkeys, &gdkkeyvals, &nEntries);

		keys = gdkkeys[0 .. nEntries];
		keyvals = gdkkeyvals[0 .. nEntries];

		return i;
	}
code: end
outFile: Keymap

file: gdk-Selections.html
class: Selection
prefix: gdk_selection_
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Display
structWrap: GdkDisplay* Display
#import: gdk.Atom
#structWrap: GdkAtom* Atom
outFile: Selection

file: gdk-Drag-and-Drop.html
struct: GdkDragContext
class: DragContext
prefix: gdk-drag_context_
structWrap: GdkDragContext* DragContext
import: gdk.Window
structWrap: GdkWindow* Window
#import: gdk.DragProtocol
#structWrap: GdkDragProtocol* DragProtocol
import: gdk.Screen
structWrap: GdkScreen* Screen
import: glib.ListG
structWrap: GList* ListG
import: gdk.Display
structWrap: GdkDisplay* Display

out: gdk_drag_find_window dest_window
out: gdk_drag_find_window protocol
out: gdk_drag_find_window_for_screen dest_window
out: gdk_drag_find_window_for_screen protocol

outFile: DragContext

# no struct
#file: gdk-Properties-and-Atoms.html
#struct: 
#class: 
#prefix: 
#outFile: 

file: gdk-Threads.html
#class: 
#prefix: 
outFile: Threads

file: gdk-Input.html
class: Input
prefix: gdk_input_
outFile: Input

file: gdk-Input-Devices.html
struct: GdkDevice
class: Device
prefix: gdk_device_
import: glib.ListG
structWrap: GList* ListG
structWrap: GdkDevice* Device
import: gdk.Window
structWrap: GdkWindow* Window

out: gdk_device_get_state mask
nocode: gdk_device_get_history

code: start
	/**
	 * Obtains the motion history for a device; given a starting and
	 * ending timestamp, return all events in the motion history for
	 * the device in the given range of time. Some windowing systems
	 * do not support motion history, in which case, FALSE will
	 * be returned. (This is not distinguishable from the case where
	 * motion history is supported and no events were found.)
	 * Params:
	 * window =  the window with respect to which which the event coordinates will be reported
	 * start =  starting timestamp for range of events to return
	 * stop =  ending timestamp for the range of events to return
	 * events =  location to store a newly-allocated array of GdkTimeCoord, or NULL
	 * Returns: TRUE if the windowing system supports motion history and at least one event was found.
	 */
	public int getHistory(Window window, uint start, uint stop, out GdkTimeCoord*[] events)
	{
		int nEvents;
		GdkTimeCoord** coord = null;

		// gboolean gdk_device_get_history (GdkDevice *device,  GdkWindow *window,  guint32 start,  guint32 stop,  GdkTimeCoord ***events,  gint *n_events);
		int i = gdk_device_get_history(gdkDevice, (window is null) ? null : window.getWindowStruct(), start, stop, &coord, &nEvents);

		events = coord[0 .. nEvents];
		return i;
	}
code: end
outFile: Device

#file: gdk-Pango-Interaction.html
#struct: 
#class: 
#prefix: 
#outFile: 

 

file: gdk-X-Window-System-Interaction.html
#struct: GdkDrawable #we're not wrapping a struct ATM
#we're just putting these methods to be static.
class: X11
prefix: gdk_x11_
import: glib.Str
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Window
structWrap: GdkWindow* Window
#more types should added here like atom, visual, image, etc...
#for now we just disable all the stuff with X types in them
#only thing left is XID which is just an uint.
#using noprefix to exclude these functions so no external decleration gets generated
noprefix: gdkx_visual_get
noprefix: gdkx_colormap_get
noprefix: gdk_pixmap_foreign_new
noprefix: gdk_pixmap_foreign_new_for_display
noprefix: gdk_pixmap_foreign_new_for_screen
noprefix: gdk_window_foreign_new_for_display
noprefix: gdk_xid_table_lookup_for_display
noprefix: gdk_window_lookup_for_display
noprefix: gdk_pixmap_lookup_for_display
noprefix: gdk_x11_lookup_xdisplay
noprefix: gdk_net_wm_supports
noprefix: gdk_x11_screen_supports_net_wm_hint
noprefix: gdk_x11_screen_get_window_manager_name
noprefix: gdk_x11_screen_lookup_visual
noprefix: gdk_x11_display_get_user_time
noprefix: gdk_x11_colormap_foreign_new
noprefix: gdk_x11_colormap_get_xcolormap
noprefix: gdk_x11_colormap_get_xdisplay
noprefix: gdk_x11_cursor_get_xcursor
noprefix: gdk_x11_cursor_get_xdisplay
noprefix: gdk_x11_display_get_xdisplay
noprefix: gdk_x11_display_grab
noprefix: gdk_x11_display_ungrab
noprefix: gdk_x11_display_set_cursor_theme
noprefix: gdk_x11_register_standard_event_type
noprefix: gdk_x11_drawable_get_xdisplay
noprefix: gdk_x11_font_get_xdisplay
noprefix: gdk_x11_gc_get_xdisplay
noprefix: gdk_x11_gc_get_xgc
noprefix: gdk_x11_get_default_root_xwindow
noprefix: gdk_x11_get_default_xdisplay
noprefix: gdk_x11_image_get_xdisplay
noprefix: gdk_x11_image_get_ximage
noprefix: gdk_x11_screen_get_screen_number
noprefix: gdk_x11_screen_get_xscreen
noprefix: gdk_x11_visual_get_xvisual
noprefix: gdk_x11_atom_to_xatom
noprefix: gdk_x11_atom_to_xatom_for_display
noprefix: gdk_x11_xatom_to_atom
noprefix: gdk_x11_xatom_to_atom_for_display
noprefix: gdk_x11_get_xatom_by_name
noprefix: gdk_x11_get_xatom_by_name_for_display
noprefix: gdk_x11_get_xatom_name
noprefix: gdk_x11_get_xatom_name_for_display
outFile: X11


############## cairo interaction ###############


file: gdk-Cairo-Interaction.html

prefix: gdk_cairo_
import: cairo.Context
structWrap: cairo_t* Context
structWrap: GdkDrawable* Drawable
structWrap: GdkColor* Color
structWrap: GdkPixbuf* Pixbuf
structWrap: GdkPixmap* Pixmap
structWrap: GdkRectangle* Rectangle
structWrap: GdkRegion* Region

nocode: gdk_cairo_create
nocode: gdk_cairo_set_source_color
nocode: gdk_cairo_set_source_pixbuf
nocode: gdk_cairo_set_source_pixmap
nocode: gdk_cairo_rectangle
nocode: gdk_cairo_region

code: start

	/**
	 * This file is not used, 
	 * 
	 * It is here just to tell you to look at 
	 * cairo.Context class for the methods that where here..
	 */


code: end
outFile: GdkCairo
