#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


#
###
#####
# Definitions for wrapping GObject
#####
###
#


addTypedefs: start

public import gtkc.glibtypes;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
addEnums: end

addStructs: start
addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end



# must start with wrap

addStructs: start
struct GValue
{
	align(4)
	{
		GType		g_type;
		union Data
		{
			gint	v_int;
			guint	v_uint;
			glong	v_long;
			gulong	v_ulong;
			gint64      v_int64;
			guint64     v_uint64;
			gfloat	v_float;
			gdouble	v_double;
			gpointer	v_pointer;
		};
	}
	Data data1;
	Data data2;
};
addStructs: end

wrap: gobject

###########################################################
### GObject ###############################################
###########################################################

file: gobject-Type-Information.html
class: Type
prefix: g_type_
import: glib.Str
import: glib.Quark
import: gobject.Type
#structWrap: GType* Type
#import: gobject.TypeQuery
#structWrap: GTypeQuery* TypeQuery
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
import: gobject.TypePlugin
structWrap: GTypePlugin* TypePlugin
#import: gobject.TypeFundamentalInfo
#structWrap: GTypeFundamentalInfo* TypeFundamentalInfo
#import: gobject.InterfaceInfo
#structWrap: GInterfaceInfo* InterfaceInfo
#import: gobject.TypeInstance
#structWrap: GTypeInstance* TypeInstance
#import: gobject.TypeValueTable
#structWrap: GTypeValueTable* TypeValueTable
outFile: Type

file: GTypePlugin.html
struct: GTypePlugin
class: TypePlugin
prefix: g_type_plugin_
import: glib.Str
import: gobject.Type
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
#import: gobject.TypeValueTable
#structWrap: GTypeValueTable* TypeValueTable
#import: gobject.InterfaceInfo
#structWrap: GInterfaceInfo* InterfaceInfo
outFile: TypePlugin

file: GTypeModule.html
struct: GTypeModule
class: TypeModule
import: glib.Str
prefix: g_type_module_
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
#import: gobject.InterfaceInfo
#structWrap: GInterfaceInfo* InterfaceInfo
import: gobject.Enums
structWrap: GEnumValue* Enums
import: gobject.Flags
structWrap: GFlagsValue* Flags
outFile: TypeModule

file: gobject-The-Base-Object-Type.html
struct: GObject
class: ObjectG
prefix: g_object_
#import: gobject.ObjectClass
#structWrap: GObjectClass* ObjectClass
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
#import: gobject.ParamSpec*
#structWrap: GParamSpec** ParamSpec*
#import: gobject.Parameter
#structWrap: GParameter* Parameter
import: gobject.Value
structWrap: GValue* Value
import: gobject.Closure
structWrap: GClosure* Closure
import: std.gc
import: glib.Str


nocode: g_object_set_data_full

code: start


	/**
	* Sets our main struct and passes store it on the gobject.
	* Add a gabage collector root to the gtk+ struct so it doesn't get collect
	*/
	public this (GObject* gObject)
	{
		this.gObject = gObject;
		if ( gObject !is  null )
		{
			//writefln("ObjectG.this\n");
			setDataFull("GObject",cast(void*)this);
		}
	}
	
	/**
	 * Sets a pointer on this object's has table
	 * Params:
	 *  key = the data identifier
	 *  data = a pointer
	 */
	public: void setDataFull(char[] key, gpointer data)
	{
		//writefln("setData objectG=%X data=%X type %s",gObject,data,key);
		version(Tango) gc.addRoot(data);
		else std.gc.addRoot(data);
		g_object_set_data_full(gObject, Str.toStringz(key), data, cast(GDestroyNotify)&destroyNotify);
	}
	
	extern(C)
	{
		static void destroyNotify(gpointer* data)
		{
			//writefln("objectg.destroy entry");
			//writefln("objectg.destroy");
			//writefln("removing gc.root to %s",data);
			version(Tango) gc.removeRoot(data);
			else std.gc.removeRoot(data);
			//writefln("objectg.destroy exit");
		}
	}

//debug = objectstore;
//
//debug(objectstore)
//{
//	private import std.stdio;
//}
//
//	/**
//	 * Maps Gtk structures to GtkD Objects
//	 */
//	private static ObjectStore objectStore;
//	
//	/**
//	 * Creates the statis ObjectStore object
//	 */
//	static this()
//	{
//		objectStore = new ObjectStore();
//	}
//	
//	/**
//	 * Sets our main struct and passes store it on the gobject.
//	 * Adds a gabage collector root to the gtk+ struct so it doesn't get collect
//	 * adds the object to the objectStore
//	 */
//	public this (GObject* gObject)
//	{
//		this.gObject = gObject;
//		if ( gObject !is  null )
//		{
//			//writefln("ObjectG.this\n");
//			objectStore.putObject(this, gObject);
//			setDestroyNotify("GObject",gObject);
//		}
//	}
//	
//
//	
//	/**
//	 * Maintains the map from Gtk structures to GtkD objects
//	 */
//	private static class ObjectStore
//	{
//		static ObjectG[void*] objectStore;
//		
//		/**
//		 * Puts a new gtk struct to GtkD objects
//		 */
//		void putObject(ObjectG objectG, GObject* gtkStruct)
//		{
//			objectStore[gtkStruct] = objectG;
//			debug(objectstore)
//			{
//				writefln("ObjectStore.putObject gtkStruct = %s (total=%s)", gtkStruct, objectStore.length);
//			}
//		}
//		
//		/**
//		 * Gets a GtkD object from a gtk struct.
//		 * Returns: the GtkD object or null if not found
//		 */
//		ObjectG getObject(GObject* gtkStruct)
//		{
//			ObjectG objectG = null;
//			synchronized ( this )
//			{
//				if ( gtkStruct in objectStore )
//				{
//					objectG = objectStore[gtkStruct];
//				}
//			}
//			debug(objectstore)
//			{
//				//writefln("ObjectStore.removeObject objectStore.length = %s", objectStore.length);
//				//writefln("ObjectStore.getObject gtkStruct = %s", gtkStruct);
//				if ( objectG is null )
//				{
//					writefln("ObjectStore.getObject not found");
//				}
//				else
//				{
//					writefln("ObjectStore.getObject %s (total = %s)", objectG, objectStore.length);
//				}
//			}
//			return objectG;
//		}
//		
//		/**
//		 * Removes an entry from the gtk struct to GtkD object map
//		 */
//		void removeObject(GObject* gtkStruct)
//		{
//			debug(objectstore)
//			{
//				writefln("ObjectStore.removeObject gtkStruct = %s", gtkStruct);
//				ObjectG objectG = getObject(gtkStruct);
//				if ( objectG is null )
//				{
//					writefln("ObjectStore.removeObject not found");
//				}
//				else
//				{
//					writefln("ObjectStore.removeObject %s",
//					objectG);
//				}
//			}
//			objectStore.remove(gtkStruct);
//			//objectStore.rehash;
//			debug(objectstore)
//			{
//				writefln("ObjectStore.removeObject objectStore.length = %s", objectStore.length);
//			}
//		}
//	}
//
//	/**
//	 * Gets a GtkD object from a Gtk Structure if the GtkD object was already created for the structure
//	 */
//	public static ObjectG getStoredObject(GObject* gtkStruct)
//	{
//		return objectStore.getObject(gtkStruct);
//	}
//	
//	/**
//	 * Sets a pointer on this object's has table
//	 * Params:
//	 *  key = the data identifier
//	 *  data = a pointer
//	 */
//	private void setDestroyNotify(char[] key, gpointer data)
//	{
//		//writefln("setData objectG=%X data=%X type %s",gObject,data,key);
//		//std.gc.addRoot(data);
//		
//		g_object_set_data_full(gObject, Str.toStringz(key), data, cast(GDestroyNotify)&destroyNotify);
//	}
//	
//	private extern(C)
//	{
//		static void destroyNotify(gpointer data)
//		{
//			//printf("objectg.destroy entry\n");
//			//printf("objectg.destroy\n");
//			//writefln("removing gc.root to %s",data);
//			//std.gc.removeRoot(data);
//
//			objectStore.removeObject(cast(GObject*)data);
//			//objectStore.removeObject(cast(GObject*)*data);
//			
//			//printf("objectg.destroy exit\n");
//		}
//	}

	/** */
	public void setProperty(char[] propertyName, int value)
	{
		setProperty(propertyName, new Value(value));
	}
	
	/** */
	public void setProperty(char[] propertyName, char[] value)
	{
		setProperty(propertyName, new Value(value));
	}
	
	/** */
	public void setProperty(char[] propertyName, long value)
	{
		//We use g_object_set instead of g_object_set_property, because Value doesn't like longs and ulongs for some reason.
		g_object_set( gObject, Str.toStringz(propertyName), value, null);
	}

	/** */
	public void setProperty(char[] propertyName, ulong value)
	{
		g_object_set( gObject, Str.toStringz(propertyName), value, null);
	}
	
code: end

outFile: ObjectG

file: gobject-Enumeration-and-Flag-Types.html

struct: GEnumValue
class: Enums
prefix: g_enum_
noprefix: g_flags_
import: glib.Str
#import: gobject.EnumValue
#structWrap: GEnumValue* EnumValue
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
outFile: Enums

struct: GFlagsValue
strictPrefix: Y
class: Flags
prefix: g_flags_
noprefix: g_enum_
import: glib.Str
import: gobject.Flags
structWrap: GFlagsValue* Flags
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
outFile: Flags

file: gobject-Boxed-Types.html
class: Boxed
prefix: g_
import: glib.Str
outFile: Boxed

file: gobject-Generic-values.html
struct: GValue
class: Value
nostruct: GValue
prefix: g_value_
import: glib.Str
import: gobject.Value
structWrap: GValue* Value
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gdk.Pixbuf

nocode: g_value_init
nocode: g_value_reset

code: start
	/** */
	public this()
	{
		this(new GValue);
	}

	/** */	
	this(Pixbuf pixbuf)
	{
		GValue* v = new GValue;
		//v.g_type = DUIType.PIXBUF;
		v.g_type = Pixbuf.getType();
		v.data1.v_pointer = cast(void*)(pixbuf.getPixbufStruct());
		this(v);
	}

	/** */
	this(char[] value)
	{
		this();
		init(GType.STRING);
		setString(value);
	}

	/** */
	this(int value)
	{
		this();
		init(GType.INT);
		setInt(value);
	}
	
	/**
	 * Initializes value with the default value of type.
	 * Params:
	 *  value = A zero-filled (uninitialized) GValue structure.
	 *  g_type = Type the GValue should hold values of.
	 * Returns:
	 *  the GValue structure that has been passed in
	 */
	public Value init(GType gType)
	{
		// GValue* g_value_init (GValue *value,  GType g_type);
		g_value_init(gValue, gType);
		return this;
	}
	
	/**
	 * Clears the current value in value and resets it to the default value
	 * (as if the value had just been initialized).
	 * Params:
	 *  value = An initialized GValue structure.
	 * Returns:
	 *  the GValue structure that has been passed in
	 */
	public Value reset()
	{
		// GValue* g_value_reset (GValue *value);
		g_value_reset(gValue);
		return this;
	}
	


code: end

openFile: Value

file: gobject-Standard-Parameter-and-Value-Types.html
#class: Value
#import: gobject.Value
#prefix: g_
closeFile: Value

#file: gobject-Varargs-Value-Collection.html
#class: 
#prefix: 
#outFile: 

file: gobject-GParamSpec.html
struct: GParamSpec
class: ParamSpec
prefix: g_param_spec_
import: glib.Str
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
import: gobject.Value
structWrap: GValue* Value
#import: gobject.ParamSpecTypeInfo
#structWrap: GParamSpecTypeInfo* ParamSpecTypeInfo
#import: gobject.ParamSpecPool
#structWrap: GParamSpecPool* ParamSpecPool
#import: gobject.ParamSpec*
#structWrap: GParamSpec** ParamSpec*
import: glib.ListG
structWrap: GList* ListG
outFile: ParamSpec

file: gobject-Signals.html
class: Signals
prefix: g_signal_
import: glib.Str
import: gobject.Closure
structWrap: GClosure* Closure
import: gobject.Type
#structWrap: GType* Type
#import: gobject.SignalQuery
#structWrap: GSignalQuery* SignalQuery
import: gobject.Value
structWrap: GValue* Value
import: glib.Quark
structWrap: GQuark* Quark
#import: gobject.SignalInvocationHint
#structWrap: GSignalInvocationHint* SignalInvocationHint

code: start
	/** */
	public static uint connectData(void* instanc, char[] detailedSignal, GCallback cHandler, Object data, GClosureNotify destroyData, GConnectFlags connectFlags)
	{
		// gulong g_signal_connect_data (gpointer instance,  const gchar *detailed_signal,  GCallback c_handler,  gpointer data,  GClosureNotify destroy_data,  GConnectFlags connect_flags);
		return g_signal_connect_data(instanc, Str.toStringz(detailedSignal), cHandler, cast(void*)data, destroyData, connectFlags);
	}


code: end

outFile: Signals

file: gobject-Closures.html

struct: GClosure
class: Closure
prefix: g_closure_
noprefix: g_cclosure
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gobject.Closure
structWrap: GClosure* Closure
import: gobject.Value
structWrap: GValue* Value
import: glib.Source
structWrap: GSource* Source
outFile: Closure

struct: GCClosure
class: CClosure
prefix: g_cclosure
strictPrefix: Yes
noprefix: g_closure_
noprefix: g_source_set_closure
import: gobject.Closure
structWrap: GClosure* Closure
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gobject.Value
structWrap: GValue* Value
outFile: CClosure

file: gobject-Value-arrays.html
struct: GValueArray
class: ValueArray
prefix: g_value_array_
import: gobject.Value
structWrap: GValue* Value
import: gobject.ValueArray
structWrap: GValueArray* ValueArray
outFile: ValueArray
