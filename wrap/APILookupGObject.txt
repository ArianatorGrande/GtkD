#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


#
###
#####
# Definitions for wrapping GObject
#####
###
#


addTypedefs: start

public import gtkc.glibtypes;

alias void GTypeCValue;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
addEnums: end

addStructs: start

//We need a corectly warped struct for gtk.TreeModel.

/**
 * An opaque structure used as the base of all interface types.
 */
public struct GTypeInterface
{ 
	GType gType;         /* iface type */ 
	GType gInstanceType;
}

addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end



# must start with wrap

addStructs: start
struct GValue
{
	align(4)
	{
		GType		g_type;
		union Data
		{
			gint	v_int;
			guint	v_uint;
			glong	v_long;
			gulong	v_ulong;
			gint64      v_int64;
			guint64     v_uint64;
			gfloat	v_float;
			gdouble	v_double;
			gpointer	v_pointer;
		};
	}
	Data data1;
	Data data2;
};
addStructs: end

wrap: gobject

###########################################################
### GObject ###############################################
###########################################################

file: gobject-Type-Information.html
class: Type
prefix: g_type_
nostruct: GTypeInterface
import: glib.Str
#structWrap: GType* Type
#import: gobject.TypeQuery
#structWrap: GTypeQuery* TypeQuery
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
import: gobject.TypePlugin
structWrap: GTypePlugin* TypePlugin
#import: gobject.TypeFundamentalInfo
#structWrap: GTypeFundamentalInfo* TypeFundamentalInfo
#import: gobject.InterfaceInfo
#structWrap: GInterfaceInfo* InterfaceInfo
#import: gobject.TypeInstance
#structWrap: GTypeInstance* TypeInstance
#import: gobject.TypeValueTable
#structWrap: GTypeValueTable* TypeValueTable

out: g_type_query query
array: g_type_children Return n_children
array: g_type_interfaces Return n_interfaces
array: g_type_interface_prerequisites Return n_prerequisites

outFile: Type

file: GTypePlugin.html
struct: GTypePlugin
class: TypePlugin
prefix: g_type_plugin_
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
#import: gobject.TypeValueTable
#structWrap: GTypeValueTable* TypeValueTable
#import: gobject.InterfaceInfo
#structWrap: GInterfaceInfo* InterfaceInfo
outFile: TypePlugin

file: GTypeModule.html
struct: GTypeModule
class: TypeModule
prefix: g_type_module_
import: glib.Str
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
#import: gobject.InterfaceInfo
#structWrap: GInterfaceInfo* InterfaceInfo
import: gobject.Enums
structWrap: GEnumValue* Enums
import: gobject.Flags
structWrap: GFlagsValue* Flags
outFile: TypeModule

file: gobject-The-Base-Object-Type.html
struct: GObject
class: ObjectG
prefix: g_object_
#import: gobject.ObjectClass
#structWrap: GObjectClass* ObjectClass
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
#import: gobject.ParamSpec*
#structWrap: GParamSpec** ParamSpec*
#import: gobject.Parameter
#structWrap: GParameter* Parameter
import: gobject.Value
structWrap: GValue* Value
import: gobject.Closure
structWrap: GClosure* Closure
import: std.gc
import: glib.Str

array: g_object_class_list_properties Return n_properties
array: g_object_interface_list_properties Return n_properties_p
array: g_object_newv parameters n_parameters
nocode: g_object_set_data_full

code: start


	/**
	* Sets our main struct and passes store it on the gobject.
	* Add a gabage collector root to the gtk+ struct so it doesn't get collect
	*/
	public this (GObject* gObject)
	{
		this.gObject = gObject;
		if ( gObject !is  null )
		{
			//writefln("ObjectG.this\n");

			//Check if there already is a D object for this gtk struct
			void* ptr = getDObject(gObject);
			if( ptr !is null )
			{
				this = cast(ObjectG)ptr;
				return;
			}

			objectGSetDataFull("GObject",cast(void*)this);
		}
	}
	
	/**
	 * Sets a pointer on this object's has table
	 * Params:
	 *  key = the data identifier
	 *  data = a pointer
	 */
	public void objectGSetDataFull(string key, gpointer data)
	{
		//writefln("setData objectG=%X data=%X type %s",gObject,data,key);
		version(Tango) GC.addRoot(data);
		else std.gc.addRoot(data);
		g_object_set_data_full(gObject, Str.toStringz(key), data, cast(GDestroyNotify)&destroyNotify);
	}
	
	extern(C)
	{
		static void destroyNotify(gpointer* data)
		{
			//writefln("objectg.destroy entry");
			//writefln("objectg.destroy");
			//writefln("removing gc.root to %s",data);
			version(Tango) GC.removeRoot(data);
			else std.gc.removeRoot(data);
			//writefln("objectg.destroy exit");
		}
	}

	/**
	 * Gets a D Object from the objects table of associations.
	 * Params:
	 *  object = GObject containing the associations.
	 * Returns: the D Object if found, or NULL if no such Object exists.
	 */
	public static void* getDObject(GObject* obj)
	{
		//gpointer g_object_get_data(GObject *object, const gchar *key);
		return g_object_get_data(obj, Str.toStringz("GObject"));
	}

	/** */
	public void setProperty(string propertyName, int value)
	{
		setProperty(propertyName, new Value(value));
	}
	
	/** */
	public void setProperty(string propertyName, string value)
	{
		setProperty(propertyName, new Value(value));
	}
	
	/** */
	public void setProperty(string propertyName, long value)
	{
		//We use g_object_set instead of g_object_set_property, because Value doesn't like longs and ulongs for some reason.
		g_object_set( gObject, Str.toStringz(propertyName), value, null);
	}

	/** */
	public void setProperty(string propertyName, ulong value)
	{
		g_object_set( gObject, Str.toStringz(propertyName), value, null);
	}
code: end

outFile: ObjectG

file: gobject-Enumeration-and-Flag-Types.html

struct: GEnumValue
class: Enums
prefix: g_enum_
noprefix: g_flags_
import: glib.Str
structWrap: GEnumValue* Enums
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
out: g_enum_complete_type_info info
outFile: Enums

struct: GFlagsValue
strictPrefix: Y
class: Flags
prefix: g_flags_
import: glib.Str
structWrap: GFlagsValue* Flags
#import: gobject.TypeInfo
#structWrap: GTypeInfo* TypeInfo
outFile: Flags

file: gobject-Boxed-Types.html
class: Boxed
prefix: g_
import: glib.Str
outFile: Boxed

file: gobject-Generic-values.html
struct: GValue
class: Value
nostruct: GValue
prefix: g_value_
import: glib.Str
structWrap: GValue* Value
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
import: gdk.Pixbuf

nocode: g_value_init
nocode: g_value_reset

code: start
	/** */
	public this()
	{
		this(new GValue);
	}

	/** */	
	this(Pixbuf pixbuf)
	{
		GValue* v = new GValue;
		//v.g_type = DUIType.PIXBUF;
		v.g_type = Pixbuf.getType();
		v.data1.v_pointer = cast(void*)(pixbuf.getPixbufStruct());
		this(v);
	}

	/** */
	this(string value)
	{
		this();
		init(GType.STRING);
		setString(value);
	}

	/** */
	this(int value)
	{
		this();
		init(GType.INT);
		setInt(value);
	}
	
	/**
	 * Initializes value with the default value of type.
	 * Params:
	 *  value = A zero-filled (uninitialized) GValue structure.
	 *  g_type = Type the GValue should hold values of.
	 * Returns:
	 *  the GValue structure that has been passed in
	 */
	public Value init(GType gType)
	{
		// GValue* g_value_init (GValue *value,  GType g_type);
		g_value_init(gValue, gType);
		return this;
	}
	
	/**
	 * Clears the current value in value and resets it to the default value
	 * (as if the value had just been initialized).
	 * Params:
	 *  value = An initialized GValue structure.
	 * Returns:
	 *  the GValue structure that has been passed in
	 */
	public Value reset()
	{
		// GValue* g_value_reset (GValue *value);
		g_value_reset(gValue);
		return this;
	}
	


code: end

openFile: Value

file: gobject-Standard-Parameter-and-Value-Types.html
#class: Value
#import: gobject.Value
#prefix: g_
closeFile: Value

#file: gobject-Varargs-Value-Collection.html
#class: 
#prefix: 
#outFile: 

file: gobject-GParamSpec.html
struct: GParamSpec
class: ParamSpec
prefix: g_param_spec_
noprefix: g_param_spec_pool_
import: glib.Str
structWrap: GParamSpec* ParamSpec
import: gobject.Value
structWrap: GValue* Value
#import: gobject.ParamSpecTypeInfo
#structWrap: GParamSpecTypeInfo* ParamSpecTypeInfo
#import: gobject.ParamSpecPool
#structWrap: GParamSpecPool* ParamSpecPool
import: glib.ListG
structWrap: GList* ListG
outFile: ParamSpec

struct: GParamSpecPool
class: ParamSpecPool
prefix: g_param_spec_pool_
strictPrefix: Y
import: glib.Str
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
import: glib.ListG
structWrap: GList* ListG

array: g_param_spec_pool_list Return n_pspecs_p
outFile: ParamSpecPool

file: gobject-Signals.html
class: Signals
prefix: g_signal_
import: glib.Str
import: gobject.Closure
structWrap: GClosure* Closure
#import: gobject.SignalQuery
#structWrap: GSignalQuery* SignalQuery
import: gobject.Value
structWrap: GValue* Value
import: glib.Quark
structWrap: GQuark* Quark
#import: gobject.SignalInvocationHint
#structWrap: GSignalInvocationHint* SignalInvocationHint

array: g_signal_newv param_types n_params
array: g_signal_list_ids Return n_ids
out: g_signal_parse_name signal_id_p

code: start
	/** */
	public static uint connectData(void* instanc, string detailedSignal, GCallback cHandler, Object data, GClosureNotify destroyData, GConnectFlags connectFlags)
	{
		// gulong g_signal_connect_data (gpointer instance,  const gchar *detailed_signal,  GCallback c_handler,  gpointer data,  GClosureNotify destroy_data,  GConnectFlags connect_flags);
		return g_signal_connect_data(instanc, Str.toStringz(detailedSignal), cHandler, cast(void*)data, destroyData, connectFlags);
	}


code: end

outFile: Signals

file: gobject-Closures.html

struct: GClosure
class: Closure
prefix: g_closure_
noprefix: g_cclosure_
import: gobject.ObjectG
structWrap: GObject* ObjectG
structWrap: GClosure* Closure
import: gobject.Value
structWrap: GValue* Value
import: glib.Source
structWrap: GSource* Source
outFile: Closure

struct: GCClosure
class: CClosure
prefix: g_cclosure_
strictPrefix: Yes
import: gobject.Closure
structWrap: GClosure* Closure
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gobject.Value
structWrap: GValue* Value
outFile: CClosure

file: gobject-Value-arrays.html
struct: GValueArray
class: ValueArray
prefix: g_value_array_
import: gobject.Value
structWrap: GValue* Value
structWrap: GValueArray* ValueArray
outFile: ValueArray
