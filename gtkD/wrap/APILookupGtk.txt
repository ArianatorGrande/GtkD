#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#


#
###
#####
# Definitions for wrapping Gtk
#####
###
#

# must start with wrap



addTypedefs: start
public import gtkc.glibtypes;
public import gtkc.gobjecttypes;
public import gtkc.pangotypes;
public import gtkc.atktypes;
public import gtkc.gdkpixbuftypes;
public import gtkc.gdktypes;
alias void GtkAccelGroupEntry;
alias void GtkContainerClass;

//alias GTokenType.G_TOKEN_LAST G_TOKEN_LAST;";
//alias GtkSignalRunType.G_SIGNAL_RUN_FIRST G_SIGNAL_RUN_FIRST;
//alias GtkSignalRunType.G_SIGNAL_RUN_LAST G_SIGNAL_RUN_LAST;
//alias GtkSignalRunType.G_SIGNAL_NO_RECURSE G_SIGNAL_NO_RECURSE;
//alias GtkSignalRunType.G_SIGNAL_ACTION G_SIGNAL_ACTION;
//alias GtkSignalRunType.G_SIGNAL_NO_HOOKS G_SIGNAL_NO_HOOKS;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
addEnums: end

addStructs: start

	struct GtkTextIter {
		/* GtkTextIter is an opaque datatype; ignore all these fields.
		* Initialize the iter with gtk_text_buffer_get_iter_*
		* functions
		*/
		/*< private >*/
		gpointer dummy1;
		gpointer dummy2;
		gint dummy3;
		gint dummy4;
		gint dummy5;
		gint dummy6;
		gint dummy7;
		gint dummy8;
		gpointer dummy9;
		gpointer dummy10;
		gint dummy11;
		gint dummy12;
		/* padding */
		gint dummy13;
		gpointer dummy14;
	}

addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end



wrap: gtk

###########################################################
### Core Reference ########################################
###########################################################


file: gtk-General.html

#struct: 
class: GtkD
#prefix: 
prefix: gtk_
noprefix: gtk_true
noprefix: gtk_false
noprefix: gtk_timeout_
noprefix: gtk_idle_
#import: g.OptionEntry
#structWrap: GOptionEntry* OptionEntry
#import: g.Error*
#structWrap: GError** Error*
#import: g.OptionGroup
#structWrap: GOptionGroup* OptionGroup
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType
import: glib.Str
import: gtkc.gtk
import: gthread.Thread;
import: gdk.Threads;



code: start

	/**
	 * Call this function before using any other GTK+ functions in your GUI applications.
	 */
	public static void init(char[][] args)
	{
		char** argv = (new char*[args.length]).ptr;
		int argc = 0;
		foreach (char[] p; args)
		{
			argv[argc++] = cast(char*)p;
		}
		
		init(&argc,&argv);
	}
	
	/**
	 * This initiates GtkD to supports multi threaded programs.
	 * read full documantation at http://gtk.org/faq/#AEN482
	 * from the FAQ:
	 * "There is a single global lock that you must acquire with 
	 * gdk_threads_enter() before making any GDK calls, 
	 * and release with gdk_threads_leave() afterwards throughout your code."
	 * This is to be used on any call to GDK not executed from the main thread.
	 */
	public static void initMultiThread(char[][] args)
	{
		Thread.init(null);
		gdkThreadsInit();
		init(args);
	}
	
code: end
outFile: GtkD

class: Timeout
prefix: gtk_timeout_
strictPrefix: Y
code: start
	/** Holds all timeout delegates */
	bit delegate()[] timeoutListeners;
	/** our gtk timeout ID */
	uint timeoutID;

	 
	/**
	 * Creates a new timeout cycle.
	 * Params:
	 *    	interval = 	the timeout in milieconds
	 *    	delegate() = 	the delegate to be executed
	 *    	fireNow = 	When true the delegate will be executed emmidiatly
	 * Returns: 
	 */
	this(uint interval, bit delegate() dlg, bit fireNow=false)
	{
		timeoutListeners ~= dlg;
		timeoutID = gtk_timeout_add(interval, cast(GtkFunction)&timeoutCallback, this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = 0;
			}
		}
	}

	public void stop()
	{
		if ( timeoutID > 0 )
		{
			gtk_timeout_remove(timeoutID);
		}
		timeoutListeners.length = 0;
	}
	
	/**
	 * Removes the timeout from gtk
	 * Returns: 
	 */
	~this()
	{
		stop();
	}
	
	/**
	 * Adds a new delegate to this timeout cycle
	 * Params:
	 *    	delegate() = 	
	 *    	fireNow = 	
	 */
	public void addListener(bit delegate() dlg, bit fireNow=false)
	{
		timeoutListeners ~= dlg;
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = timeoutListeners.length - 1;
			}
		}
	}

	/**
	 * The callback execution from glib
	 * Params:
	 *    	timeout = 	
	 * Returns: 
	 */
	extern(C) static bit timeoutCallback(Timeout timeout)
	{
		return timeout.callAllListeners();
	}
	
	/**
	 * Executes all delegates on the execution list
	 * Returns: 
	 */
	private bit callAllListeners()
	{
		bit runAgain = false;
		
		int i = 0;
		
		while ( i<timeoutListeners.length )
		{
			if ( !timeoutListeners[i]() )
			{
				timeoutListeners = timeoutListeners[0..i] ~ timeoutListeners[i+1..timeoutListeners.length];
			}
			else
			{
				runAgain = true;
				++i;
			}
		}
		return runAgain;
	}
code: end
outFile: Timeout

class: Idle
prefix: gtk_idle_
strictPrefix: Y
code: start
	/** Holds all idle delegates */
	bit delegate()[] idleListeners;
	/** our gtk idle ID */
	uint idleID;

	/**
	 * Creates a new idle cycle.
	 * Params:
	 *    	interval = 	the idle in milieconds
	 *    	delegate() = 	the delegate to be executed
	 *    	fireNow = 	When true the delegate will be executed emmidiatly
	 * Returns: 
	 */
	this(bit delegate() dlg, bit fireNow=false)
	{
		idleListeners ~= dlg;
		idleID = gtk_idle_add(cast(GtkFunction)&idleCallback, this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = 0;
			}
		}
	}

	public void stop()
	{
		if ( idleID > 0 )
		{
			gtk_idle_remove(idleID);
		}
		idleListeners.length = 0;
	}
	
	/**
	 * Removes the idle from gtk
	 * Returns: 
	 */
	~this()
	{
		stop();
	}
	
	/**
	 * Adds a new delegate to this idle cycle
	 * Params:
	 *    	delegate() = 	
	 *    	fireNow = 	
	 */
	public void addListener(bit delegate() dlg, bit fireNow=false)
	{
		idleListeners ~= dlg;
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = idleListeners.length - 1;
			}
		}
	}

	/**
	 * The callback execution from glib
	 * Params:
	 *    	idle = 	
	 * Returns: 
	 */
	extern(C) static bit idleCallback(Idle idle)
	{
		return idle.callAllListeners();
	}
	
	/**
	 * Executes all delegates on the execution list
	 * Returns: 
	 */
	private bit callAllListeners()
	{
		bit runAgain = false;
		
		int i = 0;
		
		while ( i<idleListeners.length )
		{
			if ( !idleListeners[i]() )
			{
				idleListeners = idleListeners[0..i] ~ idleListeners[i+1..idleListeners.length];
			}
			else
			{
				runAgain = true;
				++i;
			}
		}
		return runAgain;
	}
code: end
outFile: Idle


file: gtk-Keyboard-Accelerators.html
struct:  GtkAccelGroup
class: AccelGroup
prefix: gtk_accel_group_
prefix: gtk_
import: glib.Str
import: gobject.Closure
structWrap: GClosure* Closure
#import: gtk.AccelGroupEntry
#structWrap: GtkAccelGroupEntry* AccelGroupEntry
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListSG
structWrap: GSList* ListSG
#import: gtk.AccelKey
#structWrap: GtkAccelKey* AccelKey
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType
outFile: AccelGroup

file: gtk-Accelerator-Maps.html
struct:  GtkAccelMap
class: AccelMap
prefix: gtk_accel_map_
prefix: gtk_
import: glib.Str
#import: gtk.AccelKey
#structWrap: GtkAccelKey* AccelKey
#import: g.Scanner
#structWrap: GScanner* Scanner
import: gtk.AccelMap
structWrap: GtkAccelMap* AccelMap
outFile: AccelMap

file: gtk-Clipboards.html
struct: GtkClipboard
class: Clipboard
prefix: gtk_clipboard_
prefix: gtk_
import: glib.Str
import: gtk.Clipboard
structWrap: GtkClipboard* Clipboard
import: gdk.Display
structWrap: GdkDisplay* Display
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData
#import: gdk.Atom*
#structWrap: GdkAtom** Atom*
outFile: Clipboard

file: gtk-Drag-and-Drop.html
struct: GdkDragContext
class: DragAndDrop
prefix: gtk_drag_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.DragContext
structWrap: GdkDragContext* DragContext
#import: gtk.TargetList
#structWrap: GtkTargetList* TargetList
import: gdk.Event
structWrap: GdkEvent* Event
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: glib.Str
outFile: DragAndDrop

file: GtkIconTheme.html

struct: GtkIconTheme
class: IconTheme
prefix: gtk_icon_theme_
noprefix: gtk_icon_info_
prefix: gtk_
import: glib.Str
import: gtk.IconTheme
structWrap: GtkIconTheme* IconTheme
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.IconInfo
structWrap: GtkIconInfo* IconInfo
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
#import: g.Error*
#structWrap: GError** Error*
import: glib.ListG
structWrap: GList* ListG
outFile: IconTheme

struct: GtkIconInfo
class: IconInfo
prefix: gtk_icon_info_
strictPrefix: Y
import: glib.Str
import: gtk.IconInfo
structWrap: GtkIconInfo* IconInfo
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
outFile: IconInfo

file: gtk-Stock-Items.html
struct: GtkStockItem
class: StockItem
prefix: gtk_stock_
prefix: gtk_
import: glib.Str
import: gtk.StockItem
structWrap: GtkStockItem* StockItem
import: glib.ListSG
structWrap: GSList* ListSG
outFile: StockItem

file: gtk-Themeable-Stock-Images.html
struct: GtkIconSource
class: IconSource
prefix: gtk_icon_
prefix: gtk_
import: glib.Str
#import: gtk.IconSource
#structWrap: GtkIconSource* IconSource
#import: gtk.IconFactory
#structWrap: GtkIconFactory* IconFactory
#import: gtk.IconSet
#structWrap: GtkIconSet* IconSet
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Style
structWrap: GtkStyle* Style
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Settings
structWrap: GtkSettings* Settings
outFile: IconSource

file: gtk-Resource-Files.html
struct: GtkRcStyle
class: RcStyle
prefix: gtk_rc_
prefix: gtk_
#import: g.Scanner
#structWrap: GScanner* Scanner
import: glib.Str
import: gtk.Style
structWrap: GtkStyle* Style
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gdk.Color
structWrap: GdkColor* Color
#import: gtk.StateType
#structWrap: GtkStateType* StateType
#import: gtk.PathPriorityType
#structWrap: GtkPathPriorityType* PathPriorityType
import: gtk.RcStyle
structWrap: GtkRcStyle* RcStyle
outFile: RcStyle

file: GtkSettings.html
struct: GtkSettings
class: Settings
prefix: gtk_settings_
prefix: gtk_
import: glib.Str
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gdk.Screen
structWrap: GdkScreen* Screen
#import: g.ParamSpec
#structWrap: GParamSpec* ParamSpec
import: glib.StringG
structWrap: GString* StringG
import: gobject.Value
structWrap: GValue* Value
#import: gtk.SettingsValue
#structWrap: GtkSettingsValue* SettingsValue
outFile: Settings

file: gtk-Bindings.html
struct: GtkBindingSet
class: BindingSet
prefix: gtk_binding_set_
prefix: gtk_bindings_
prefix: gtk_
import: glib.Str
import: gtk.BindingSet
structWrap: GtkBindingSet* BindingSet
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gdk.EventKey
#structWrap: GdkEventKey* EventKey
import: glib.ListSG
structWrap: GSList* ListSG
import: glib.Str;
#import: g.Scanner
#structWrap: GScanner* Scanner
outFile: BindingSet

file: gtk-Standard-Enumerations.html
#struct: 
class: StandardEnumerations
#prefix: 
#prefix: gtk_
outFile: StandardEnumerations

file: gtk-Graphics-Contexts.html
#struct: 
class: GCs
prefix: gtk_gc_
prefix: gtk_
import: gdk.GC
structWrap: GdkGC* GC
import: gdk.Colormap
structWrap: GdkColormap* Colormap
#import: gdk.GCValues
#structWrap: GdkGCValues* GCValues
outFile: GCs

file: GtkStyle.html
struct: GtkStyle
class: Style
prefix: gtk_style_
prefix: gtk_
import: glib.Str
import: gtk.Style
structWrap: GtkStyle* Style
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
#import: gtk.IconSet
#structWrap: GtkIconSet* IconSet
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.IconSource
structWrap: GtkIconSource* IconSource
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Font
structWrap: GdkFont* Font
#import: gdk.Point
#structWrap: GdkPoint* Point
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
#import: gtk.Border
#structWrap: GtkBorder* Border
outFile: Style

file: gtk-Selections.html
#struct: 
class: Selections
prefix: gtk_
import: glib.Str
#import: gtk.TargetList
#structWrap: GtkTargetList* TargetList
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Display
structWrap: GdkDisplay* Display
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: glib.Str
outFile: Selections

file: gtk-Feature-Test-Macros.html
#struct: 
class: Version
prefix: gtk_
import: glib.Str
outFile: Version

file: gtk-Signals.html
#struct: 
class: Signals
prefix: gtk_signal_
prefix: gtk_
import: glib.Str
#import: gtk.Type
#structWrap: GtkType* Type
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gtk.Arg
#structWrap: GtkArg* Arg
import: glib.Str
outFile: Signals

file: gtk-Types.html
struct: GtkType
class: Types
prefix: gtk_type_
prefix: gtk_
import: glib.Str
#import: gtk.TypeInfo
#structWrap: GtkTypeInfo* TypeInfo
#import: gtk.EnumValue
#structWrap: GtkEnumValue* EnumValue
#import: gtk.FlagValue
#structWrap: GtkFlagValue* FlagValue
outFile: Types

###########################################################
### Windows ###############################################
###########################################################

file: GtkDialog.html
struct: GtkDialog
class: Dialog
prefix: gtk_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Screen
structWrap: GdkScreen* Screen

code: start

	public Widget addButton(StockID stockID, int responseId)
	{
		return addButton(StockDesc[stockID], responseId);
	}
	

	public void addButtons(char[][] buttonsText, ResponseType[] responses)
	{
		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}
	
	public void addButtons(StockID[] stockIDs, ResponseType[] responses)
	{
		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}
	
code: end
outFile: Dialog

file: GtkInvisible.html
struct: GtkInvisible
class: Invisible
prefix: gtk_invisible_
prefix: gtk_
import: gdk.Screen
structWrap: GdkScreen* Screen
outFile: Invisible

file: GtkMessageDialog.html
struct: GtkMessageDialog
class: MessageDialog
prefix: gtk_message_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window

nocode: gtk_message_dialog_new
nocode: gtk_message_dialog_new_with_markup

code: start
	/**
	 * Creates a new message dialog, which is a simple dialog with an icon
	 * indicating the dialog type (error, warning, etc.) and some text the
	 * user may want to see. When the user clicks a button a "response"
	 * signal is emitted with response IDs from GtkResponseType. See
	 * GtkDialog for more details.
	 * parent:
	 *  transient parent, or NULL for none
	 * flags:
	 *  flags
	 * type:
	 *  type of message
	 * buttons:
	 *  set of buttons to use
	 * message_format:
	 *  printf()-style format string, or NULL
	 * message:
	 *  the message - should be null, any formatting should be done prior to call this constructor
	 *  arguments for message_format
	 * Returns:
	 *  a new GtkMessageDialog
	 */
	public this (Window parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, char[] messageFormat, char[] message=null )
	{
		this(parent, flags, type, buttons, false, messageFormat, message );
	}
	
	/**
	 * Creates a new message dialog, which is a simple dialog with an icon
	 * indicating the dialog type (error, warning, etc.) and some text which
	 * is marked up with the Pango text markup language.
	 * When the user clicks a button a "response" signal is emitted with
	 * response IDs from GtkResponseType. See GtkDialog for more details.
	 * 
	 * If Markup is true special XML characters in the printf() arguments passed to this
	 * function will automatically be escaped as necessary.
	 * (See g_markup_printf_escaped() for how this is implemented.)
	 * Usually this is what you want, but if you have an existing
	 * Pango markup string that you want to use literally as the
	 * label, then you need to use gtk_message_dialog_set_markup()
	 * instead, since you can't pass the markup string either
	 * as the format (it might contain '%' characters) or as a string
	 * argument.
	 *  GtkWidget *dialog;
	 *  dialog = gtk_message_dialog_new (main_application_window,
	 *  GTK_DIALOG_DESTROY_WITH_PARENT,
	 *  GTK_MESSAGE_ERROR,
	 *  GTK_BUTTONS_CLOSE,
	 *  NULL);
	 *  gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog),
	 *  markup);
	 * parent:
	 *  transient parent, or NULL for none
	 * flags:
	 *  flags
	 * type:
	 *  type of message
	 * buttons:
	 *  set of buttons to use
	 * message_format:
	 *  printf()-style format string, or NULL
	 * message:
	 *  the message - should be null, any formatting should be done prior to call this constructor
	 * ...:
	 *  arguments for message_format
	 * Returns:
	 *  a new GtkMessageDialog
	 * Since 2.4
	 */
	public this (Window parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, bit markup, char[] messageFormat, char[] message=null )
	{
		if ( markup )
		{
			// GtkWidget* gtk_message_dialog_new_with_markup  (GtkWindow *parent,  GtkDialogFlags flags,  GtkMessageType type,  GtkButtonsType buttons,  const gchar *message_format,  ...);
			this(
				cast(GtkMessageDialog*)gtk_message_dialog_new_with_markup(
						parent is null ? null : parent.getWindowStruct(), 
						flags, 
						type, 
						buttons, 
						Str.toStringz(messageFormat),
						Str.toStringz(message),	// this should be null
						null
						)
			);
		}
		else
		{
			// GtkWidget* gtk_message_dialog_new (GtkWindow *parent,  GtkDialogFlags flags,  GtkMessageType type,  GtkButtonsType buttons,  const gchar *message_format,  ...);
			this(
				cast(GtkMessageDialog*)gtk_message_dialog_new(
						parent is null ? null : parent.getWindowStruct(), 
						flags, 
						type, 
						buttons, 
						Str.toStringz(messageFormat),
						Str.toStringz(message),	// this should be null
						null
						)
			);
		}
	}
	
code: end

outFile: MessageDialog

file: 
class: PopupBox
import: gtk.MessageDialog;
import: gtk.Window;

code: start
	/**
	 * Create an information popup dialog.
	 * @param message The message to show on the dialog
	 * @param title The title of the dialog
	 */
	public static void information(char[] message, char[] title)
	{
		information(null, message, title);
	}
	
	/**
	 * Create an information popup dialog.
	 * @param parent The parent window of this popup dialog
	 * @param message The message to show on the dialog
	 * @param title The title of the dialog
	 */
	public static void information(Window parent, char[] message, char[] title)
	{
		MessageDialog d = new MessageDialog(parent, cast(GtkDialogFlags)0,
										MessageType.INFO,
										ButtonsType.OK ,
										message);
		d.setTitle(title);
		//d.addButton("gtk-dialog-info",GtkResponseType.GTK_RESPONSE_OK);
		d.run();
		d.destroy();
	}
	
	
	/**
	 * Create an error popup dialog.
	 * @param message The message to show on the dialog
	 * @param title The title of the dialog
	 */
	public static void error(char[] message, char[] title)
	{
		error(null, message, title);
	}
	
	/**
	 * Create an error popup dialog.
	 * @param parent The parent window of this popup dialog
	 * @param message The message to show on the dialog
	 * @param title The title of the dialog
	 */
	public static void error(Window parent, char[] message, char[] title)
	{
		MessageDialog d = new MessageDialog(parent, cast(GtkDialogFlags)0,
										MessageType.ERROR,
										ButtonsType.CANCEL ,
										message);
		d.setTitle(title);
		//d.addButton("gtk-dialog-error",ResponseType.GTK_RESPONSE_CANCEL);
		d.run();
		d.destroy();
	}
	
	
	
	/**
	 * Create an 'yes' or 'no' popup dialog.
	 * @param message The message to show on the dialog
	 * @param title The title of the dialog
	 */
	public static bool yesNo(char[] message, char[] title)
	{
		return yesNo(null, message, title);
	}
	
	/**
	 * Create an 'yes' or 'no' popup dialog.
	 * @param parent The parent window of this popup dialog
	 * @param message The message to show on the dialog
	 * @param title The title of the dialog
	 */
	public static bool yesNo(Window parent, char[] message, char[] title)
	{
		MessageDialog d = new MessageDialog(
				parent, cast(GtkDialogFlags)0,
				MessageType.QUESTION,
				ButtonsType.NONE ,
				message);
		d.setTitle(title);
		d.addButton("gtk-no",ResponseType.GTK_RESPONSE_NO);
		d.addButton("gtk-yes",ResponseType.GTK_RESPONSE_YES);
		int responce = d.run();
		d.destroy();
		return responce == ResponseType.GTK_RESPONSE_YES;
	}

	
	/**
	 * Create an 'yes', 'no' or 'cancel' popup dialog.
	 * @param message The message to show on the dialog
	 * @param title The title of the dialog
	 */
	public static ResponseType yesNoCancel(char[] message, char[] title)
	{
		return yesNoCancel(null, message, title);
	}
	
	/**
	 * Create an 'yes', 'no' or 'cancel' popup dialog.
	 * @param parent The parent window of this popup dialog
	 * @param message The message to show on the dialog
	 * @param title The title of the dialog
	 */
	public static ResponseType yesNoCancel(Window parent, char[] message, char[] title)
	{
		MessageDialog d = new MessageDialog(
				parent, cast(GtkDialogFlags)0,
				MessageType.QUESTION,
				ButtonsType.NONE ,
				message);
		d.setTitle(title);
		d.addButton("gtk-no",ResponseType.GTK_RESPONSE_NO);
		d.addButton("gtk-yes",ResponseType.GTK_RESPONSE_YES);
		d.addButton("gtk-cancel",ResponseType.GTK_RESPONSE_CANCEL);
		ResponseType responce = cast(ResponseType)d.run();
		d.destroy();
		return responce;
	}
code: end
outFile: PopupBox

file: GtkWindow.html
struct: GtkWindow
class: Window
prefix: gtk_window_
prefix: gtk_
import: glib.Str
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gdk.Geometry
#structWrap: GdkGeometry* Geometry
import: gtk.Window
structWrap: GtkWindow* Window
import: gdk.Screen
structWrap: GdkScreen* Screen
import: glib.ListG
structWrap: GList* ListG
#import: gdk.EventKey
#structWrap: GdkEventKey* EventKey
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Window

code: start
	/**
	 * Creates a top level window with a title
	 * Params:
	 * 		title:	The Window title
	 */
	public this(char[] title)
	{
		this(GtkWindowType.TOPLEVEL);
		setTitle(title);
	}

	/**
	 * Move the window to an absolute position.
	 * just calls move(int, int).
	 * convinience because GdkEvent structs return the position coords as doubles
	 */
	public void move(double x, double y)
	{
		move(cast(int)x, cast(int)y);
	}
	

code: end

outFile: Window

file: 
import: gtk.Widget
import: gtk.Window
import: gtk.GtkD
import: gdk.Event
	

code: start

/**
 * A top Level window that will stop the main event cycle when it's closed.
 * Closing the last of the windows of class "MainWindow" will end the application.
 */
public class MainWindow : Window
{

	private static int countTotalMainWindows = 0;

	/**
	 * Creates a new MainWindow with a title
	 */
	public this(char[] title)
	{
		super(title);
		countTotalMainWindows++;
		//printf("MainWindows.this count = %d\n", countTotalMainWindows);
		addOnDelete(&windowDelete);
	}
	
	/**
	 * Executed when the user tries to close the window
	 * @return true to refuse to close the window
	 */
	protected int windowDelete(Event event, Widget widget)
	{
		--countTotalMainWindows;
		//printf("MainWindows.windowDelete count = %d\n", countTotalMainWindows);
		if ( exit(0, false) || countTotalMainWindows==0 )
		{
			GtkD.mainQuit();
			return false;
		}
		return false;
	}
	
	/**
	 * Allows the application to close and decide if it can exit
	 * @param code the code reason to exit
	 * @param force if true the application must expect to be closed even against it's will
	 * @return false to refuse to exit
	 */
	protected bit exit(int code, bit force)
	{
		return force;
	}
}

code: end
outFile: MainWindow

file: GtkWindowGroup.html
struct: GtkWindowGroup
class: WindowGroup
prefix: gtk_window_group_
prefix: gtk_
import: gtk.Window
structWrap: GtkWindow* Window
outFile: WindowGroup

file: GtkAboutDialog.html
struct: GtkAboutDialog
class: AboutDialog
prefix: gtk_about_dialog_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Window
structWrap: GtkWindow* Window
outFile: AboutDialog

file: GtkAssistant.html
struct: GtkAssistant
class: Assistant
prefix: gtk_assistant_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Assistant



###########################################################
### Display Widgets #######################################
###########################################################

file: GtkAccelLabel.html
struct: GtkAccelLabel
class: AccelLabel
prefix: gtk_accel_label_
prefix: gtk_
import: glib.Str
import: gobject.Closure
structWrap: GClosure* Closure
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: AccelLabel

file: GtkImage.html
struct: GtkImage
class: Image
prefix: gtk_image_
prefix: gtk_
import: glib.Str
#import: gtk.IconSet*
#structWrap: GtkIconSet** IconSet*
#import: gtk.IconSize
#structWrap: GtkIconSize* IconSize
#import: gdk.ImageGdk*
#structWrap: GdkImage** ImageGdk*
#import: gdk.Bitmap*
#structWrap: GdkBitmap** Bitmap*
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
#import: gdk.Pixmap*
#structWrap: GdkPixmap** Pixmap*
#import: gdk.PixbufAnimation
#structWrap: GdkPixbufAnimation* PixbufAnimation
#import: gtk.IconSet
#structWrap: GtkIconSet* IconSet
import: gdk.ImageGdk
structWrap: GdkImage* ImageGdk
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap

nocode: gtk_image_new_from_stock
nocode: gtk_image_new_from_icon_name

code: start
// this will be an enum 
	/**
	 * Creates a GtkImage displaying a stock icon. Sample stock icon
	 * names are GTK_STOCK_OPEN, GTK_STOCK_EXIT. Sample stock sizes
	 * are GTK_ICON_SIZE_MENU, GTK_ICON_SIZE_SMALL_TOOLBAR. If the stock
	 * icon name isn't known, the image will be empty.
	 * You can register your own stock icon names, see
	 * gtk_icon_factory_add_default() and gtk_icon_factory_add().
	 * stock_id:
	 *  a stock icon name
	 * size:
	 *  a stock icon size
	 * Returns:
	 *  a new GtkImage displaying the stock icon
	 */
	public this (StockID stockID, GtkIconSize size)
	{
		// GtkWidget* gtk_image_new_from_stock (const gchar *stock_id,  GtkIconSize size);
		this(cast(GtkImage*)gtk_image_new_from_stock(StockDesc[stockID].ptr, size) );
	}
	
	/**
	 * Creates a GtkImage displaying an icon from the current icon theme.
	 * If the icon name isn't known, a "broken image" icon will be
	 * displayed instead. If the current icon theme is changed, the icon
	 * will be updated appropriately.
	 * icon_name:
	 *  an icon name
	 * size:
	 *  a stock icon size
	 * Returns:
	 *  a new GtkImage displaying the themed icon
	 * Since 2.6
	 */
	public this (char[] iconName, GtkIconSize size)
	{
		// GtkWidget* gtk_image_new_from_icon_name (const gchar *icon_name,  GtkIconSize size);
		this(cast(GtkImage*)gtk_image_new_from_icon_name(Str.toStringz(iconName), size) );
	}
	
code: end

outFile: Image

file: GtkLabel.html
struct: GtkLabel
class: Label
prefix: gtk_label_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
nocode: gtk_label_new
nocode: gtk_label_new_with_mnemonic
code: start
	/**
	 * Creates a new GtkLabel, containing the text in str.
	 * If characters in str are preceded by an underscore, they are
	 * underlined. If you need a literal underscore character in a label, use
	 * '__' (two underscores). The first underlined character represents a 
	 * keyboard accelerator called a mnemonic. The mnemonic key can be used 
	 * to activate another widget, chosen automatically, or explicitly using
	 * gtk_label_set_mnemonic_widget().
	 * If gtk_label_set_mnemonic_widget()
	 * is not called, then the first activatable ancestor of the GtkLabel
	 * will be chosen as the mnemonic widget. For instance, if the
	 * label is inside a button or menu item, the button or menu item will
	 * automatically become the mnemonic widget and be activated by
	 * the mnemonic.
	 * str:
	 *  The text of the label, with an underscore in front of the
	 *  mnemonic character
	 * mnemonic: when false uses the literal text passed in without mnemonic
	 * Returns:
	 *  the new GtkLabel
	 */
	public this (char[] str, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_label_new_with_mnemonic (const gchar *str);
			this(cast(GtkLabel*)gtk_label_new_with_mnemonic(Str.toStringz(str)) );
		}
		else
		{
			// GtkWidget* gtk_label_new (const gchar *str);
			this(cast(GtkLabel*)gtk_label_new(Str.toStringz(str)) );
		}
	}
code: end
outFile: Label

file: GtkProgressBar.html
struct: GtkProgressBar
class: ProgressBar
prefix: gtk_progress_bar_
prefix: gtk_
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: ProgressBar

file: GtkStatusbar.html
struct: GtkStatusbar
class: Statusbar
import: glib.Str
prefix: gtk_statusbar_
prefix: gtk_
outFile: Statusbar

###########################################################
### Buttons and Toggles ###################################
###########################################################

file: GtkButton.html
struct: GtkButton
class: Button
prefix: gtk_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Image
import: gtk.Button

nocode: gtk_button_new_with_mnemonic
nocode: gtk_button_new_with_label
nocode: gtk_button_new_from_stock

code: start


	private static IconSize currentIconSize = IconSize.BUTTON;

	/** An arbitrary string to be used by the application */
	private char[] action;

	public static void setIconSize(IconSize iconSize)
	{
		currentIconSize = iconSize;
	}
	public static IconSize getIconSize()
	{
		return currentIconSize;
	}

	public void setActionName(char[] action)
	{
		this.action = action.dup;
	}
	
	public char[] getActionName()
	{
		return action;
	}

	/**
	 * Creates a new GtkButton containing a label.
	 * If characters in label are preceded by an underscore, they are underlined.
	 * If you need a literal underscore character in a label, use '__' (two
	 * underscores). The first underlined character represents a keyboard
	 * accelerator called a mnemonic.
	 * Pressing Alt and that key activates the button.
	 * label:
	 *  The text of the button, with an underscore in front of the
	 *  mnemonic character
	 * Returns:
	 *  a new GtkButton
	 */
	public this (char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_button_new_with_mnemonic (const gchar *label);
			this(cast(GtkButton*)gtk_button_new_with_mnemonic(Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_button_new_with_label (const gchar *label);
			this(cast(GtkButton*)gtk_button_new_with_label(Str.toStringz(label)) );
		}
	}
	
	/**
	 * Creates a new GtkButton containing the image and text from a stock item.
	 * Some stock ids have preprocessor macros like GTK_STOCK_OK and
	 * GTK_STOCK_APPLY.
	 * If stock_id is unknown, then it will be treated as a mnemonic
	 * label (as for gtk_button_new_with_mnemonic()).
	 * stock_id:
	 *  the name of the stock item
	 * Returns:
	 *  a new GtkButton
	 */
	public this (StockID stockID, bool hideLabel=false)
	{
		// GtkWidget* gtk_button_new_from_stock (const gchar *stock_id);
		if ( hideLabel )
		{
			this();
			Image image = new Image(stockID,currentIconSize);
			add(image);
		}
		else
		{
			this(cast(GtkButton*)gtk_button_new_from_stock(StockDesc[stockID].ptr) );
		}
		
	}
	
	public this(StockID stockID, void delegate(Button) dlg, bool hideLabel=false)
	{
		this(stockID, hideLabel);
		addOnClicked(dlg);
	}
	

	public this(char[] label, void delegate(Button) dlg, bit mnemonic=true)
	{
		this(label, mnemonic);
		addOnClicked(dlg);
	}

	public this(char[] label, void delegate(Button) dlg, char[] action)
	{
		this(label);
		setActionName(action);
		addOnClicked(dlg);
	}
	

code: end
outFile: Button

file: GtkCheckButton.html
struct: GtkCheckButton
class: CheckButton
import: glib.Str
import: gtk.Button
import: glib.Str
prefix: gtk_check_button_
prefix: gtk_

nocode: gtk_check_button_new_with_label
nocode: gtk_check_button_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkCheckButton with a GtkLabel to the right of it.
	 * If mnemonic is true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the check button.
	 * label:
	 *  The text of the button, with an underscore in front of the
	 *  mnemonic character
	 * label:
	 * the text for the check button.
	 * Returns:
	 * a GtkWidget.
	 */
	public this (char[] label, bool mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_check_button_new_with_mnemonic  (const gchar *label);
			this(cast(GtkCheckButton*)gtk_check_button_new_with_mnemonic(Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_check_button_new_with_label (const gchar *label);
			this(cast(GtkCheckButton*)gtk_check_button_new_with_label(Str.toStringz(label)) );
		}
	}
	
	public this(char[] label, void delegate(CheckButton) onClicked, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnClicked(cast(void delegate(Button))onClicked);
	}
	
code: end

outFile: CheckButton

file: GtkRadioButton.html
struct: GtkRadioButton
class: RadioButton
prefix: gtk_radio_button_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG

nocode: gtk_radio_button_new_with_label
nocode: gtk_radio_button_new_with_mnemonic
nocode: gtk_radio_button_new_with_label_from_widget
nocode: gtk_radio_button_new_with_mnemonic_from_widget

code: start
	/**
	 * Creates a new GtkRadioButton with a text label.
	 * If mnemonic if true the label will be created using
	 * gtk_label_new_with_mnemonic(), so underscores in label indicate the
	 * mnemonic for the button.
	 * an existing radio button group, or NULL if you are creating a new
	 * group.
	 * label:
	 * the text label to display next to the radio button.
	 * Returns:
	 * a new radio button.
	 */
	public this (ListSG group, char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_button_new_with_mnemonic  (GSList *group,  const gchar *label);
			this(cast(GtkRadioButton*)gtk_radio_button_new_with_mnemonic(
						group is null ? null : group.getListSGStruct(), 
						Str.toStringz(label)) 
						);
		}
		else
		{
			// GtkWidget* gtk_radio_button_new_with_label (GSList *group,  const gchar *label);
			this(cast(GtkRadioButton*)gtk_radio_button_new_with_label(
						group is null ? null : group.getListSGStruct(), 
						Str.toStringz(label)) 
						);
		}
	}
	
	/**
	 * Creates a new GtkRadioButton with a text label, adding it to the same group
	 * as group.
	 * It mnemonic it true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the button.
	 * group:
	 * an existing GtkRadioButton.
	 * label:
	 * a text string to display next to the radio button.
	 * Returns:
	 * a new radio button.
	 */
	public this (RadioButton radioButton, char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_button_new_with_mnemonic_from_widget  (GtkRadioButton *group,  const gchar *label);
			this(cast(GtkRadioButton*)gtk_radio_button_new_with_mnemonic_from_widget(
						radioButton.getRadioButtonStruct(),
						Str.toStringz(label))
						);
		}
		else
		{
			// GtkWidget* gtk_radio_button_new_with_label_from_widget  (GtkRadioButton *group,  const gchar *label);
			this(cast(GtkRadioButton*)gtk_radio_button_new_with_label_from_widget(
						radioButton.getRadioButtonStruct(), 
						Str.toStringz(label))
						);
		}
	}
code: end
outFile: RadioButton

file: GtkToggleButton.html
struct: GtkToggleButton
class: ToggleButton
prefix: gtk_toggle_button_
prefix: gtk_
import: glib.Str

nocode: gtk_toggle_button_new_with_label
nocode: gtk_toggle_button_new_with_mnemonic

code: start
	/**
	 * Creates a new toggle button with a text label.
	 * If mnemonic is true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the button.
	 * label:
	 * a string containing the message to be placed in the toggle button.
	 * Returns:
	 * a new toggle button.
	 */
	public this (char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_toggle_button_new_with_mnemonic  (const gchar *label);
			this(cast(GtkToggleButton*)gtk_toggle_button_new_with_mnemonic(Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_toggle_button_new_with_label  (const gchar *label);
			this(cast(GtkToggleButton*)gtk_toggle_button_new_with_label(Str.toStringz(label)) );
		}
	}
code: end

outFile: ToggleButton

###########################################################
### numeric/text Data Entry ###############################
###########################################################

file: GtkEntry.html
struct: GtkEntry
class: Entry
prefix: gtk_entry_
prefix: gtk_
import: glib.Str
import: gtk.EntryCompletion
structWrap: GtkEntryCompletion* EntryCompletion

code: start
	public this (char[] text)
	{
		this();
		setText(text);
	}
	
	public this (char[] text, int max)
	{
		this(max);
		setText(text);
	}
code: end

outFile: Entry

file: GtkEntryCompletion.html
struct: GtkEntryCompletion
class: EntryCompletion
prefix: gtk_entry_completion_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
outFile: EntryCompletion

file: GtkHScale.html
struct: GtkHScale
class: HScale
prefix: gtk_hscale_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: HScale

file: GtkVScale.html
struct: GtkVScale
class: VScale
prefix: gtk_vscale_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: VScale

file: GtkSpinButton.html
struct: GtkSpinButton
class: SpinButton
prefix: gtk_spin_button_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: SpinButton

file: GtkEditable.html
struct: GtkEditable
class: Editable
prefix: gtk_editable_
prefix: gtk_
import: glib.Str
outFile: Editable

###########################################################
### Multiline Text Editor #################################
###########################################################

file: gtk-GtkTextIter.html
struct: GtkTextIter
class: TextIter
nostruct: GtkTextIter
prefix: gtk_text_iter_
prefix: gtk_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: glib.ListSG
structWrap: GSList* ListSG
#import: gtk.TextChildAnchor
#structWrap: GtkTextChildAnchor* TextChildAnchor
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor

code: start
	public this()
	{
		this(new GtkTextIter);
	}
	
code: end
outFile: TextIter

file: GtkTextMark.html
struct: GtkTextMark
class: TextMark
prefix: gtk_text_mark_
prefix: gtk_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
outFile: TextMark

file: GtkTextBuffer.html
struct: GtkTextBuffer
class: TextBuffer
prefix: gtk_text_buffer_
prefix: gtk_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
#import: gtk.TextMark
#structWrap: GtkTextMark* TextMark
#import: gtk.TextIter
#structWrap: GtkTextIter* TextIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgTabArray
structWrap: PangoTabArray* PgTabArray
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: gtk.TextTagTable
structWrap: GtkTextTagTable* TextTagTable
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor
import: gtk.TextMark
structWrap: GtkTextMark* TextMark
import: gtk.Clipboard
structWrap: GtkClipboard* Clipboard
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: std.stdarg



nocode: gtk_text_buffer_set_text
nocode: gtk_text_buffer_insert_with_tags
nocode: gtk_text_buffer_insert_with_tags_by_name
nocode: gtk_text_buffer_create_tag

code: start

	/**
	 * Deletes current contents of buffer, and inserts text instead. If
	 * len is -1, text must be nul-terminated. text must be valid UTF-8.
	 * buffer:
	 *  a GtkTextBuffer
	 * text:
	 *  UTF-8 text to insert
	 * len:
	 *  length of text in bytes
	 */
	public void setText(char[] text)
	{
		// void gtk_text_buffer_set_text (GtkTextBuffer *buffer,  const gchar *text,  gint len);
		gtk_text_buffer_set_text(gtkTextBuffer, Str.toStringz(text), text.length);
	}
	
		/**
	 * Inserts len bytes of text at position iter. If len is -1,
	 * text must be nul-terminated and will be inserted in its
	 * entirety. Emits the "insert_text" signal; insertion actually occurs
	 * in the default handler for the signal. iter is invalidated when
	 * insertion occurs (because the buffer contents change), but the
	 * default signal handler revalidates it to point to the end of the
	 * inserted text.
	 * buffer:
	 *  a GtkTextBuffer
	 * iter:
	 *  a position in the buffer
	 * text:
	 *  UTF-8 format text to insert
	 * len:
	 *  length of text in bytes, or -1
	 */
	public void insert(TextIter iter, char[] text)
	{
		// void gtk_text_buffer_insert (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len);
		gtk_text_buffer_insert(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), text.length);
	}
	
	/**
	 * Simply calls gtk_text_buffer_insert(), using the current
	 * cursor position as the insertion point.
	 * buffer:
	 *  a GtkTextBuffer
	 * text:
	 *  some text in UTF-8 format
	 * len:
	 *  length of text, in bytes
	 */
	public void insertAtCursor(char[] text)
	{
		// void gtk_text_buffer_insert_at_cursor  (GtkTextBuffer *buffer,  const gchar *text,  gint len);
		gtk_text_buffer_insert_at_cursor(gtkTextBuffer, Str.toStringz(text), text.length);
	}
	
	/**
	 * Like gtk_text_buffer_insert(), but the insertion will not occur if
	 * iter is at a non-editable location in the buffer. Usually you
	 * want to prevent insertions at ineditable locations if the insertion
	 * results from a user action (is interactive).
	 * default_editable indicates the editability of text that doesn't
	 * have a tag affecting editability applied to it. Typically the
	 * result of gtk_text_view_get_editable() is appropriate here.
	 * buffer:
	 *  a GtkTextBuffer
	 * iter:
	 *  a position in buffer
	 * text:
	 *  some UTF-8 text
	 * len:
	 *  length of text in bytes, or -1
	 * default_editable:
	 *  default editability of buffer
	 * Returns:
	 *  whether text was actually inserted
	 */
	public int insertInteractive(TextIter iter, char[] text, int defaultEditable)
	{
		// gboolean gtk_text_buffer_insert_interactive  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  gboolean default_editable);
		return gtk_text_buffer_insert_interactive(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), text.length, defaultEditable);
	}
	
	/**
	 * Calls gtk_text_buffer_insert_interactive() at the cursor
	 * position.
	 * default_editable indicates the editability of text that doesn't
	 * have a tag affecting editability applied to it. Typically the
	 * result of gtk_text_view_get_editable() is appropriate here.
	 * buffer:
	 *  a GtkTextBuffer
	 * text:
	 *  text in UTF-8 format
	 * len:
	 *  length of text in bytes, or -1
	 * default_editable:
	 *  default editability of buffer
	 * Returns:
	 *  whether text was actually inserted
	 */
	public int insertInteractiveAtCursor(char[] text, int defaultEditable)
	{
		// gboolean gtk_text_buffer_insert_interactive_at_cursor  (GtkTextBuffer *buffer,  const gchar *text,  gint len,  gboolean default_editable);
		return gtk_text_buffer_insert_interactive_at_cursor(gtkTextBuffer, Str.toStringz(text), text.length, defaultEditable);
	}

	/**
	 * Inserts text into buffer at iter, applying the list of tags to
	 * the newly-inserted text. The last tag specified must be NULL to
	 * terminate the list. Equivalent to calling gtk_text_buffer_insert(),
	 * then gtk_text_buffer_apply_tag() on the inserted text;
	 * gtk_text_buffer_insert_with_tags() is just a convenience function.
	 * buffer:
	 *  a GtkTextBuffer
	 * iter:
	 *  an iterator in buffer
	 * text:
	 *  UTF-8 text
	 * len:
	 *  length of text, or -1
	 * first_tag:
	 *  first tag to apply to text
	 * ...:
	 *  NULL-terminated list of tags to apply
	 */
	public void insertWithTags(TextIter iter, char[] text, ... )
	{
		for (int i = 0; (i<_arguments.length) && (_arguments[i] == typeid(TextTag)); i++)
		{
			TextTag tag = va_arg!(TextTag)(_argptr);
			// void gtk_text_buffer_insert_with_tags  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  GtkTextTag *first_tag,  ...);
			gtk_text_buffer_insert_with_tags(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), text.length, (tag is null) ? null : tag.getTextTagStruct(), null);
		}
	}
	
	/**
	 * Same as gtk_text_buffer_insert_with_tags(), but allows you
	 * to pass in tag names instead of tag objects.
	 * buffer:
	 *  a GtkTextBuffer
	 * iter:
	 *  position in buffer
	 * text:
	 *  UTF-8 text
	 * len:
	 *  length of text, or -1
	 * first_tag_name:
	 *  name of a tag to apply to text
	 * ...:
	 *  more tag names
	 */
	public void insertWithTagsByName(TextIter iter, char[] text, ... )
	{
		for (int i = 0; (i<_arguments.length) && (_arguments[i] == typeid(char[])); i++)
		{
			char[] tagName = va_arg!(char[])(_argptr);
			// void gtk_text_buffer_insert_with_tags_by_name  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  const gchar *first_tag_name,  ...);
			gtk_text_buffer_insert_with_tags_by_name(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), text.length, Str.toStringz(tagName), null);
		}
	}
	
	/**
	 * Create a new tag for this buffer
	 * @param tagName can be null for no name
	 * @param propertyName
	 * @param propertyValue
	 */
	TextTag createTag(char[] tagName, char[] propertyName, int propertyValue, 
									   char[] propertyName1, char[] propertyValue1)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer,
				Str.toStringz(tagName), 
				Str.toStringz(propertyName),propertyValue,
				Str.toStringz(propertyName1),
				Str.toStringz(propertyValue1),
					null)
		);
			
	}
	/**
	 * Create a new tag for this buffer
	 * @param tagName can be null for no name
	 * @param propertyName
	 * @param propertyValue
	 */
	TextTag createTag(char[] tagName, char[] propertyName, int propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, 
				Str.toStringz(tagName),
				Str.toStringz(propertyName),propertyValue,null)
		);
			
	}

	/**
	 * Create a new tag for this buffer
	 * @param tagName can be null for no name
	 * @param propertyName
	 * @param propertyValue
	 */
	TextTag createTag(char[] tagName, char[] propertyName, double propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),propertyValue,null)
		);
			
	}
	
	/**
	 * Create a new tag for this buffer
	 * @param tagName can be null for no name
	 * @param propertyName
	 * @param propertyValue
	 * @param propertyName2
	 * @param propertyValue2
	 */
	TextTag createTag(char[] tagName, char[] propertyName, int propertyValue, char[] propertyName2, int propertyValue2)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName), propertyValue, Str.toStringz(propertyName2), propertyValue2, null)
		);
	}

	TextTag createTag(char[] tagName, char[] propertyName, int propertyValue, char[] propertyName2, int propertyValue2, char[] propertyName3, int propertyValue3, char[] propertyName4, int propertyValue4, char[] propertyName5, int propertyValue5)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName), propertyValue, Str.toStringz(propertyName2), propertyValue2, Str.toStringz(propertyName3), propertyValue3, Str.toStringz(propertyName4), propertyValue4, Str.toStringz(propertyName5), propertyValue5, null)
		);
	}
	/**
	 * Create a new tag for this buffer
	 * @param tagName can be null for no name
	 * @param propertyName
	 * @param propertyValue
	 */
	TextTag createTag(char[] tagName, char[] propertyName, char[] propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),Str.toStringz(propertyValue),null)
		);
			
	}

	/**
	 * Create a new tag for this buffer
	 * @param tagName can be null for no name
	 * @param propertyName
	 * @param propertyValue
	 * @return 
	 */
	TextTag createTag(char[] tagName, char[] propertyName, Bitmap propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),propertyValue.getBitmapStruct(),null)
		);
			
	}

	/**
	 * Obtain the entire text 
	 * @return The text char[]
	 */
	char[] getText()
	{
		TextIter start = new TextIter();
		TextIter end = new TextIter();
		getBounds(start,end);
		return Str.toString(gtk_text_buffer_get_slice(gtkTextBuffer, start.getTextIterStruct(), end.getTextIterStruct(), true));
	}

	/**
	 * Create a new tag for this buffer
	 * @param tagName can be null for no name
	 * @param propertyName
	 * @param propertyValue
	 * @param propertyName2
	 * @param propertyValue2
	 */
	TextTag createTag(char[] tagName, 
			char[] propertyName, char[] propertyValue, 
			char[] propertyName2, int propertyValue2)
	{
		return new TextTag(
		gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), 
			Str.toStringz(propertyName), Str.toStringz(propertyValue), 
			Str.toStringz(propertyName2), propertyValue2, null)
		);
	}
	

code: end

outFile: TextBuffer

file: GtkTextTag.html

struct: GtkTextTag
class: TextTag
prefix: gtk_text_tag_
noprefix: gtk_text_attributes_
prefix: gtk_
import: glib.Str
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
outFile: TextTag

struct: GtkTextAttributes
class: TextAttributes
prefix: gtk_text_attributes_
strictPrefix: Y
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
outFile: TextAttributes

file: GtkTextTagTable.html
struct: GtkTextTagTable
class: TextTagTable
prefix: gtk_text_tag_
prefix: gtk_
import: glib.Str
import: gtk.TextTagTable
structWrap: GtkTextTagTable* TextTagTable
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
outFile: TextTagTable

file: GtkTextView.html

struct: GtkTextView
class: TextView
prefix: gtk_text_view_
prefix: gtk_
noprefix: gtk_text_child_anchor_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
import: gtk.TextMark
structWrap: GtkTextMark* TextMark
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgTabArray
structWrap: PangoTabArray* PgTabArray
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor
import: glib.ListG
structWrap: GList* ListG

#text: start
#gtk_text_view_get_type ()
#
#GType         gtk_text_view_get_type           ();
#<hr>
#text: end


code: start

	/**
	 * Get the text line at the pixel y
	 */
	char[] getLineTextAt(gint y)
	{
		
		TextIter iter = new TextIter();
		int windowX;
		int windowY;
		bufferToWindowCoords(TextWindowType.TEXT, 0, y, &windowX, &windowY);

		gtk_text_view_get_line_at_y(gtkTextView, iter.getTextIterStruct(), y+y-windowY, null);
		
		TextIter iterEnd = new TextIter();
		TextBuffer buffer = getBuffer();
		buffer.getIterAtOffset(iterEnd, iter.getOffset()+iter.getCharsInLine());
		return buffer.getText(iter, iterEnd, false);
	}

	/**
	 * Simply appends some on the cursor position
	 * @param text the text to append
	 */
	void insertText(char[] text)
	{
		TextBuffer buf = getBuffer();
		buf.insertAtCursor(text);
	}

	/**
	 * Simply appends some text to this view
	 * @param text the text to append
	 */
	void appendText(char[] text, bool ensureVisible=true)
	body
	{
		TextBuffer buf = getBuffer();
		TextIter iter = new TextIter();
		buf.getEndIter(iter);
		buf.insert(iter, text);
		if ( ensureVisible )
		{
			gdouble within_margin = 0.0;
			bit use_align = false;
			gdouble xalign = 0.0;
			gdouble yalign = 0.0;
			scrollToMark(buf.createMark("",iter,true), within_margin, use_align, xalign, yalign);
		}
	}


code: end

outFile: TextView

struct: GtkTextChildAnchor
class: TextChildAnchor
import: glib.Str
prefix: gtk_text_child_anchor_
strictPrefix: Y
outFile: TextChildAnchor

###########################################################
### Tree, List and Icon Grid Widgets ######################
###########################################################

file: GtkTreeModel.html

struct: GtkTreeModel
class: TreeModel
prefix: gtk_tree_model_
noprefix: gtk_tree_row_reference_
noprefix: gtk_tree_path_
noprefix: gtk_tree_iter_
import: glib.Str
#noprefix: gtk_
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gobject.Value
structWrap: GValue* Value

interfaceCode: start
	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the string from the value object
	 */
	char[] getValueString(TreeIter iter, int column);

	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the int from the value object
	 */
	int getValueInt(TreeIter iter, int column);

	void setValue(TreeIter iter, int column, char[] value);

	void setValue(TreeIter iter, int column, int value);

interfaceCode: end

nocode: gtk_tree_model_get_iter

code: start
	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the string from the value object
	 */
	char[] getValueString(TreeIter iter, int column)
	{
		Value value = new Value();
		getValue(iter, column, value);
		return value.getString();
	}

	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the int from the value object
	 */
	int getValueInt(TreeIter iter, int column)
	{
		Value value = new Value();
		getValue(iter, column, value);
		return value.getInt();
	}

		/**
	 * Sets iter to a valid iterator pointing to path.
	 * tree_model:
	 *  A GtkTreeModel.
	 * iter:
	 *  The uninitialized GtkTreeIter.
	 * path:
	 *  The GtkTreePath.
	 * Returns:
	 *  TRUE, if iter was set.
	 */
	public int getIter(TreeIter iter, TreePath path)
	{
		// gboolean gtk_tree_model_get_iter (GtkTreeModel *tree_model,  GtkTreeIter *iter,  GtkTreePath *path);
		iter.setModel(this);
		return gtk_tree_model_get_iter(gtkTreeModel, (iter is null) ? null : iter.getTreeIterStruct(), (path is null) ? null : path.getTreePathStruct());
	}

code: end

#interface: TreeModelIF
outFile: TreeModel

struct: GtkTreeIter
class: TreeIter
strictPrefix: Y
prefix: gtk_tree_iter_
#prefix: gtk_
import: glib.Str
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gtk.TreeModel
import: gtk.TreePath
import: gtk.TreeIterError
import: gobject.Value;

code: start

	/**
	 * this will be set only when the iter
	 * is created from the model.
	 */
	GtkTreeModel *gtkTreeModel; 

	public void setModel(GtkTreeModel *gtkTreeModel)
	{
		this.gtkTreeModel = gtkTreeModel;
	}
       
	public void setModel(TreeModel treeModel)
	{
		this.gtkTreeModel = treeModel.getTreeModelStruct();
	}
	   
	public this(TreeModel treeModel, TreePath treePath)
	{
		this();
		setModel(treeModel);
		if ( gtk_tree_model_get_iter_from_string(
				treeModel.getTreeModelStruct(),
				getTreeIterStruct(), Str.toStringz(treePath.toString())) )
		{
			// ???
		}
	}
	
	/**
	* creates a new tree iteractor.
	* used TreeView.createIter and TreeView.append() to create iteractor for a tree or list
	*/
	this()
	{
		this(new GtkTreeIter);
	}

	
	/**
	 * Get Value
	 * @param iter
	 * @param column
	 * @param value
	 */
	void getValue(int column, Value value)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValue","Tree model not set");
		}
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
	}

	/**
	 * Get the value of a column as a string
	 * @para column the column number
	 * @return a string representing the value of the column
	 */
	char[] getValueString(int column)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValueString","Tree model not set");
		}
		Value value = new Value();
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
		//printf("TreeIter.getValuaString = %.*s\n", value.getString().toString());
		return value.getString();
	}

	/**
	 * Get the value of a column as an int
	 * @para column the column number
	 * @return a string representing the value of the column
	 */
	int getValueInt(int column)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValueInt", "Tree model not set");
		}
		Value value = new Value();
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
		return value.getInt();
	}

	TreePath getTreePath()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getTreePath","Tree model not set");
		}
		return new TreePath(gtk_tree_model_get_path(gtkTreeModel, gtkTreeIter));
	}

		/**
	 * This return the path visible to the user.
	 */
	char[] getVisiblePath(char[] separator)
	{
		char[] vPath;
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getVisiblePath", "Tree model not set");
		}

		vPath = getValueString(0);
		TreeIter parent = getParent();
		while ( parent !is  null )
		{
			//printf("TreeIter.getVisiblePath parent = %.*s\n",parent.getValueString(0).toString());
			vPath = parent.getValueString(0) ~ separator ~ vPath;
			parent = parent.getParent();
		}
		
		//printf("TreeIter.getVisiblePath = %.*s\n", vPath.toString());
		
		return vPath;
	}
	
	/**
	 * Gets the parent of this iter
	 * @param child
	 * @return the parent iter or null if can't get parent or an error occured
	 */
	TreeIter getParent()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getParent", "Tree model not set");
		}
		TreeIter parent = new TreeIter();
		bool gotParent = gtk_tree_model_iter_parent(gtkTreeModel, parent.getTreeIterStruct(), gtkTreeIter) == 0 ? false : true;
		if ( !gotParent )
		{
			return null;
		}
		parent.setModel(gtkTreeModel);
		return parent;
	}


	TreeIter getGrandParent()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getGrandParent", "Tree model not set");
		}
		TreeIter grandParent = this;
		TreeIter parent = grandParent.getParent();
		while ( parent !is null )
		{
			grandParent = parent;
			parent = grandParent.getParent();
		}
		
		return grandParent;
	}



	

code: end

outFile: TreeIter



struct: GtkTreePath
class: TreePath
strictPrefix: Y
prefix: gtk_tree_path_
#prefix: gtk_
import: glib.Str
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: glib.Str

nocode: gtk_tree_path_new
nocode: gtk_tree_path_new_first

code: start
	/**
	 * Creates a new GtkTreePath. This structure refers to a row.
	 * if firstRow is true this is the string representation of this path is "0"
	 * Returns:
	 *  A newly created GtkTreePath.
	 */
	public this (bit firstRow=false)
	{
		if ( firstRow )
		{
			// GtkTreePath* gtk_tree_path_new_first (void);
			this(cast(GtkTreePath*)gtk_tree_path_new_first() );
		}
		else
		{
			// GtkTreePath* gtk_tree_path_new (void);
			this(cast(GtkTreePath*)gtk_tree_path_new() );
		}
	}
code: end
outFile: TreePath

struct: GtkTreeRowReference
class: TreeRowReference
strictPrefix: Y
prefix: gtk_tree_row_reference_
#prefix: gtk_
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gobject.ObjectG
structWrap: GObject* ObjectG
#import: gtk.TreeRowReference
#structWrap: GtkTreeRowReference* TreeRowReference
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
outFile: TreeRowReference

file:
class: TreeIterError
extend: Error
code: start
/**
 * A TreeIter error.
 * thrown<br>
 * - trying to access a method that requires a tree model and the tree model was never set
 */
	public this(char[] method, char[] message)
	{
		super("TreeIter."~method~" : "~message);
	}

code: end
outFile: TreeIterError


file: GtkTreeSelection.html
struct: GtkTreeSelection
class: TreeSelection
prefix: gtk_tree_selection_
prefix: gtk_
import: gtk.TreeView
structWrap: GtkTreeView* TreeView
#import: gtk.TreeModel*
#structWrap: GtkTreeModel** TreeModel*
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: glib.ListG
structWrap: GList* ListG
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gtk.TreeModel
import: gtk.TreeIter

nocode: gtk_tree_selection_get_selected
nocode: gtk_tree_selection_get_selected_rows

code: start
	/**
	 * Sets iter to the currently selected node if selection is set to
	 * GTK_SELECTION_SINGLE or GTK_SELECTION_BROWSE. iter may be NULL if you
	 * just want to test if selection has any selected nodes. model is filled
	 * with the current model as a convenience. This function will not work if you
	 * use selection is GTK_SELECTION_MULTIPLE.
	 * selection:
	 *  A GtkTreeSelection.
	 * model:
	 *  A pointer to set to the GtkTreeModel, or NULL.
	 * iter:
	 *  The GtkTreeIter, or NULL.
	 * Returns:
	 *  TRUE, if there is a selected node.
	 */
	int getSelected(TreeModel model, TreeIter iter)
	{
		GtkTreeModel* m = model.getTreeModelStruct();
		return gtk_tree_selection_get_selected(gtkTreeSelection, &m, iter.getTreeIterStruct())==0 ? false : true;
	}
	
	/**
	 * Creates a list of path of all selected rows. Additionally, if you are
	 * planning on modifying the model after calling this function, you may
	 * want to convert the returned list into a list of GtkTreeRowReferences.
	 * To do this, you can use gtk_tree_row_reference_new().
	 * To free the return value, use:
	 * g_list_foreach (list, gtk_tree_path_free, NULL);
	 * g_list_free (list);
	 * selection:
	 *  A GtkTreeSelection.
	 * model:
	 *  A pointer to set to the GtkTreeModel, or NULL.
	 * Returns:
	 *  A GList containing a GtkTreePath for each selected row.
	 * Since 2.2
	 */
	TreePath[] getSelectedRows(TreeModel model)
	{
		//printf("getSelectedRows(model) 1\n");
		GtkTreeModel* m = model.getTreeModelStruct();
		//printf("getSelectedRows(model) 2\n");
		ListG list = new ListG(
			gtk_tree_selection_get_selected_rows(gtkTreeSelection, &m)
		);
		//printf("getSelectedRows(model) 3\n");
		TreePath[] paths;
		//printf("getSelectedRows(model) 4 list.length() = %d\n",list.length());
		for ( int i=0 ; i<list.length() ; i++ )
		{
			//printf("getSelectedRows(model) 5\n");
			paths ~= new TreePath(cast(GtkTreePath*)list.nthData(i));
		}
		//printf("getSelectedRows(model) 6\n");
		return paths;
	}

code: end


outFile: TreeSelection

file: GtkTreeViewColumn.html
struct: GtkTreeViewColumn
class: TreeViewColumn
prefix: gtk_tree_view_column_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: glib.Str
nocode: gtk_tree_view_column_new_with_attributes

code: start
	/**
	 * Creates a new Tree view column
	 * @param header th column header text
	 * @param renderer the rederer for the column cells
	 * @param type the type of data to be displayed (shouldn't this be on the renderer?)
	 * @param column the column number
	 */
	this(char [] header, CellRenderer renderer, char [] type, int column)
	{
		this(gtk_tree_view_column_new_with_attributes(
				Str.toStringz(header), 
				renderer.getCellRendererStruct(), 
				Str.toStringz(type),
				column,
				null)
			);
	}


code: end

outFile: TreeViewColumn

file: GtkTreeView.html
struct: GtkTreeView
class: TreeView
prefix: gtk_tree_view_
prefix: gtk_
import: glib.Str
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: gtk.TreeSelection
structWrap: GtkTreeSelection* TreeSelection
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.TreeViewColumn
structWrap: GtkTreeViewColumn* TreeViewColumn
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.TreePath*
#structWrap: GtkTreePath** TreePath*
#import: gtk.TreeViewColumn*
#structWrap: GtkTreeViewColumn** TreeViewColumn*
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gdk.Window
structWrap: GdkWindow* Window
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
#import: gtk.TreeViewDropPosition
#structWrap: GtkTreeViewDropPosition* TreeViewDropPosition
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gtk.TreeIter

code: start
	/**
	 * Expands the row of the iter.
	 * @param iter
	 * @param openAll
	 * @return
	 */
	int expandRow(TreeIter iter, TreeModel model, int openAll)
	{
		return expandRow(model.getPath(iter), openAll);
	}

		/**
	 * Finds the path at the point (x, y), relative to widget coordinates. That
	 * is, x and y are relative to an events coordinates. x and y must come
	 * from an event on the tree_view only where event->window ==
	 * gtk_tree_view_get_bin (). It is primarily for things
	 * like popup menus. If path is non-NULL, then it will be filled with the
	 * GtkTreePath at that point. This path should be freed with gtk_tree_path_free().
	 * If column is non-NULL, then it will be filled with the column at that point.
	 * cell_x and cell_y return the coordinates relative to the cell background
	 * (i.e. the background_area passed to gtk_cell_renderer_render()). This
	 * function is only meaningful if tree_view is realized.
	 * tree_view:
	 *  A GtkTreeView.
	 * x:
	 *  The x position to be identified.
	 * y:
	 *  The y position to be identified.
	 * path:
	 *  A pointer to a GtkTreePath pointer to be filled in, or NULL
	 * column:
	 *  A pointer to a GtkTreeViewColumn pointer to be filled in, or NULL
	 * cell_x:
	 *  A pointer where the X coordinate relative to the cell can be placed, or NULL
	 * cell_y:
	 *  A pointer where the Y coordinate relative to the cell can be placed, or NULL
	 * Returns:
	 *  TRUE if a row exists at that coordinate.
	 */
	int getPathAtPos(gint x, gint y, inout TreePath path, inout TreeViewColumn column, out gint cellX, out gint cellY)
	{
		GtkTreePath* p = path.getTreePathStruct();
		GtkTreeViewColumn* c = column.getTreeViewColumnStruct();

		int result = gtk_tree_view_get_path_at_pos(gtkTreeView, x, y, &p, &c, &cellX, &cellY)
			== 0 ? false : true;

		path = new TreePath(p);
		column = new TreeViewColumn(c);

		return result;
	}
	

	
	/**
	 * gets the first selected iter or null if no rows are selected
	 */
	TreeIter getSelectedIter()
	{
		TreeIter iter = new TreeIter();
		TreeSelection selection = getSelection();
		TreeModel model = getModel();
		TreePath[] paths = selection.getSelectedRows(model);
		if ( paths.length > 0 )
		{
			model.getIter(iter,paths[0]);
		}
		return iter;
	}
	
	TreeIter[] getSelectedIters()
	{
		TreeIter[] iters;
		
		TreeIter iter = new TreeIter();
		TreeSelection selection = getSelection();
		TreeModel model = getModel();
		TreePath[] paths = selection.getSelectedRows(model);
		foreach ( TreePath p; selection.getSelectedRows(model) )
		{
			//iters.length = iters.length+1;
			//iters[iters.length-1] = model.getIter(iter,p);
			// iters ~= model.getIter(iter,p); >>> compile error can only concatenate arrays ???
			if ( model.getIter(iter,p) )
			{
				iters ~= iter;
				iter = new TreeIter();
			}
		}
		
		//printf("TreeView.getSelectedIters iters.lenght = %d\n", iters.length);
		return iters;
	}

	/**
	 * Inserts a column and sets it's attributes
	 * @param position
	 * @param title
	 * @param renderer
	 * @param editable
	 * @return number of columns including the new one
	 */
	gint insertEditableColumn(int position, char[] title, CellRenderer renderer, bit editable)
	{
		// OK, this is a trick because of my ignorance on how to pass variable argument lists
		if ( position < 0 )
		{
			position = getColumns().length();
		}
		int tot = gtk_tree_view_insert_column_with_attributes(
			gtkTreeView, 
			position, 
			Str.toStringz(title),
			renderer.getCellRendererStruct(),
			Str.toStringz("text"),position,//v1.getV(),
			Str.toStringz("editable"),2,0);//v.getV(),0);
		return tot;
	}


	
code: end

outFile: TreeView

file: gtk-GtkTreeView-drag-and-drop.html
struct: GtkTreeDragSource
class: TreeDragSource
prefix: gtk_tree_drag_
prefix: gtk_
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData
#import: gtk.TreeDragDest
#structWrap: GtkTreeDragDest* TreeDragDest
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
outFile: TreeDragSource

file: GtkCellView.html
struct: GtkCellView
class: CellView
prefix: gtk_cell_view_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.Requisition
#structWrap: GtkRequisition* Requisition
import: gdk.Color
structWrap: GdkColor* Color
import: glib.ListG
structWrap: GList* ListG

nocode: gtk_cell_view_new_with_text
nocode: gtk_cell_view_new_with_markup

code: start
	/**
	 * Creates a new GtkCellView widget, adds a GtkCellRendererText
	 * to it, and makes its show text.
	 * If markup is true the text can be marked up with the Pango text
	 * markup language.
	 * text:
	 *  the text to display in the cell view
	 * Returns:
	 *  A newly created GtkCellView widget.
	 * Since 2.6
	 */
	public this (char[] text, bit markup=true)
	{
		if ( markup )
		{
			// GtkWidget* gtk_cell_view_new_with_markup (const gchar *markup);
			this(cast(GtkCellView*)gtk_cell_view_new_with_markup(Str.toStringz(text)) );
		}
		else
		{
			// GtkWidget* gtk_cell_view_new_with_text (const gchar *text);
			this(cast(GtkCellView*)gtk_cell_view_new_with_text(Str.toStringz(text)) );
		}
	}
code: end

outFile: CellView

file: GtkIconView.html
struct: GtkIconView
class: IconView
prefix: gtk_icon_view_
prefix: gtk_
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.TreePath*
#structWrap: GtkTreePath** TreePath*
#import: gtk.CellRenderer*
#structWrap: GtkCellRenderer** CellRenderer*
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
#import: gtk.IconViewDropPosition
#structWrap: GtkIconViewDropPosition* IconViewDropPosition
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
outFile: IconView

file: GtkTreeSortable.html
struct: GtkTreeSortable
class: TreeSortable
prefix: gtk_tree_sortable_
prefix: gtk_
#import: gtk.SortType
#structWrap: GtkSortType* SortType
outFile: TreeSortable

file: GtkTreeModelSort.html
struct: GtkTreeModelSort
class: TreeModelSort
import: glib.Str
prefix: gtk_tree_model_sort_
prefix: gtk_
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
outFile: TreeModelSort

file: GtkTreeModelFilter.html
struct: GtkTreeModelFilter
class: TreeModelFilter
prefix: gtk_tree_model_filter_
prefix: gtk_
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gobject.Type
#structWrap: GType* Type
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
outFile: TreeModelFilter

file: GtkCellLayout.html
struct: GtkCellLayout
class: CellLayoutT
template: TStruct
prefix: gtk_cell_layout_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.Str
interface: CellLayoutIF
outFile: CellLayoutT

file: GtkCellRenderer.html
struct: GtkCellRenderer
class: CellRenderer
prefix: gtk_cell_renderer_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.CellEditable
structWrap: GtkCellEditable* CellEditable
outFile: CellRenderer

file: GtkCellEditable.html
struct: GtkCellEditable
class: CellEditable
prefix: gtk_cell_editable_
prefix: gtk_
import: gdk.Event
structWrap: GdkEvent* Event
outFile: CellEditable

file: GtkCellRendererCombo.html
struct: GtkCellRenderer
realStruct: GtkCellRendererCombo
class: CellRendererCombo
prefix: gtk_cell_renderer_combo_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererCombo

file: GtkCellRendererPixbuf.html
struct: GtkCellRenderer
realStruct: GtkCellRendererPixbuf
class: CellRendererPixbuf
prefix: gtk_cell_renderer_pixbuf_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererPixbuf

file: GtkCellRendererProgress.html
struct: GtkCellRenderer
realStruct: GtkCellRendererProgress
class: CellRendererProgress
prefix: gtk_cell_renderer_progress_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererProgress

file: GtkCellRendererText.html
struct: GtkCellRenderer
realStruct: GtkCellRendererText
class: CellRendererText
prefix: gtk_cell_renderer_text_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererText

file: GtkCellRendererToggle.html
struct: GtkCellRenderer
realStruct: GtkCellRendererToggle
class: CellRendererToggle
prefix: gtk_cell_renderer_toggle_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererToggle


file:
code: start
	/**
	 * TreeNode interface
	 */
	public interface TreeNode
	{
		char[] getNodeValue(int column);
		int columnCount();
	}
code: end
outFile: TreeNode

file: GtkListStore.html
struct: GtkListStore
class: ListStore
extend: GtkTreeModel
prefix: gtk_list_store_
prefix: gtk_
import: gtk.TreeModel
import: glib.Str
#import: gobject.Type
#structWrap: GType* Type
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gobject.Value
structWrap: GValue* Value
import: glib.Str

nocode: gtk_list_store_set

code: start

	/**
	 * Non-vararg creation function. Used primarily by language bindings.
	 * n_columns:
	 *  number of columns in the list store
	 * types:
	 *  an array of GType types for the columns, from first to last
	 * Returns:
	 *  a new GtkListStore
	 */
	public this (GType[] types)
	{
		// GtkListStore* gtk_list_store_newv (gint n_columns,  GType *types);
		this(cast(GtkListStore*)gtk_list_store_newv(types.length, cast(GType*)(types.ptr)) );
	}
	
	/**
	 * Creates a top level iteractor.
	 * I don't think lists have but the top level iteractor
	 */
	TreeIter createIter()
	{
		GtkTreeIter* iter = new GtkTreeIter;
		gtk_list_store_append(getListStoreStruct(), iter);
		return new TreeIter(iter);
	}
	
	/**
	 * sets the values for one row
	 * @param iter the row iteractor
	 * @param columns an arrays with the columns to set
	 * @param values an arrays with the values
	 */
	void set(TreeIter iter, int [] columns, char*[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_list_store_set(
					gtkListStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					values[i],-1);
		}
	}

	void set(TreeIter iter, int [] columns, char[][] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_list_store_set(
					gtkListStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					Str.toStringz(values[i]),-1);
		}
	}

	void setValue(TreeIter iter, int column, char[] value)
	{
		Value v = new Value(value);
		gtk_list_store_set_value(gtkListStore, iter.getTreeIterStruct(), column, v.getValueStruct());
		//gtk_list_store_set_value(obj(), iter.getIter(), column, (GValue*)cChar(value));
	}
	
	void setValue(TreeIter iter, int column, int value)
	{
		Value v = new Value(value);
		gtk_list_store_set_value(gtkListStore, iter.getTreeIterStruct(), column, v.getValueStruct());
	}

code: end
outFile: ListStore

file: GtkTreeStore.html
struct: GtkTreeStore
class: TreeStore
extend: GtkTreeModel
prefix: gtk_tree_store_
prefix: gtk_
import: glib.Str
#import: gobject.Type
#structWrap: GType* Type
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gobject.Value
structWrap: GValue* Value
import: gtk.TreeNode
import: gdk.Pixbuf;
import: gobject.Value;
import: glib.Str
import: gtk.TreeModel

nocode: gtk_tree_store_set

code: start

	/**
	 * Non-vararg creation function. Used primarily by language bindings.
	 * n_columns:
	 *  number of columns in the list store
	 * types:
	 *  an array of GType types for the columns, from first to last
	 * Returns:
	 *  a new GtkListStore
	 */
	public this (GType[] types)
	{
		// GtkListStore* gtk_list_store_newv (gint n_columns,  GType *types);
		this(cast(GtkTreeStore*)gtk_tree_store_newv(
				types.length, cast(GType*)(types.ptr)) 
			);
	}
	
	

	/**
	 * Creates a top level iteractor.
	 * I don't think lists have but the top level iteractor
	 */
	TreeIter createIter(TreeIter parent=null)
	{
		GtkTreeIter* iter = new GtkTreeIter;
		gtk_tree_store_append(getTreeStoreStruct(), iter, (parent is null) ? null : parent.getTreeIterStruct());
		return new TreeIter(iter);
	}
	
	/**
	 * Sets one value into one cells.
	 * @param iter the tree iteractor, effectivly the row
	 * @param column to column number to set
	 * @param value the value
	 * \todo confirm we need to destroy the Value instance
	 */
	void setValue(TreeIter iter, int column, char[] value)
	{
		gtk_tree_store_set(gtkTreeStore, iter.getTreeIterStruct(), column, Str.toStringz(value) , -1);
	}

	void setValue(TreeIter iter, int column, int value)
	{
		gtk_tree_store_set(gtkTreeStore, iter.getTreeIterStruct(), column, (new Value(value)).getValueStruct() , -1);
	}


	
	/**
	 * \todo confirm we need to destroy the Value instance
	 */
	void setValue(TreeIter iter, int column, Pixbuf pixbuf)
	{
		Value v = new Value(pixbuf);
		gtk_tree_store_set_value(gtkTreeStore, iter.getTreeIterStruct(), column, v.getValueStruct());
	}


	/**
	 * sets the values for one row
	 * @param iter the row iteractor
	 * @param columns an arrays with the columns to set
	 * @param values an arrays with the values
	 */
	void set(TreeIter iter, int [] columns, char*[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_tree_store_set(
					gtkTreeStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					values[i],-1);
		}
	}

	void set(TreeIter iter, int [] columns, char[][] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_tree_store_set(
					gtkTreeStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					Str.toStringz(values[i]),-1);
		}
	}

	/**
	 * Sets an iteractor values from a tree node.
	 * This is the way to add a new row to the tree,
	 * the iteractor is either a top level iteractor created from createIter()
	 * or a nested iteractor created from append()
	 * @param iter the iteractor to set
	 * @param treeNode the tree node
	 * @see createIter()
	 * @see append()
	 */
	void set(TreeIter iter, TreeNode treeNode)
	{
		int[] cols;
		char[][] vals;
		for ( int i=0 ; i<treeNode.columnCount() ; i++ )
		{
			//printf(">>>>>>>>>>>>> requesting value for %d\n",i);
			cols ~= i;
			char[] value = treeNode.getNodeValue(i);
			if ( value  is  null )
			{
				vals ~= "";
			}
			else
			{
				vals ~= value;
			}
		}
		set(iter, cols, vals);				
	}


	/**
	 * Creates and prepends a new row to tree_store. If parent is non-NULL, then it will prepend
	 * the new row before the first child of parent, otherwise it will prepend a row
	 * to the top level. iter will be changed to point to this new row. The row
	 * will be empty after this function is called. To fill in values, you need to
	 * call gtk_tree_store_set() or gtk_tree_store_set_value().
	 * parent:
	 *  A valid GtkTreeIter, or NULL
	 */
	public TreeIter prepend(TreeIter parent)
	{
		TreeIter iter = new TreeIter();
		// void gtk_tree_store_prepend (GtkTreeStore *tree_store,  GtkTreeIter *iter,  GtkTreeIter *parent);
		gtk_tree_store_prepend(gtkTreeStore, iter.getTreeIterStruct(), (parent is null) ? null : parent.getTreeIterStruct());
		return iter;
	}
	
	/**
	 * Creates and appends a new row to tree_store. If parent is non-NULL, then it will append the
	 * new row after the last child of parent, otherwise it will append a row to
	 * the top level. iter will be changed to point to this new row. The row will
	 * be empty after this function is called. To fill in values, you need to call
	 * gtk_tree_store_set() or gtk_tree_store_set_value().
	 * parent:
	 *  A valid GtkTreeIter, or NULL
	 */
	public TreeIter append(TreeIter parent)
	{
		TreeIter iter = new TreeIter();
		// void gtk_tree_store_append (GtkTreeStore *tree_store,  GtkTreeIter *iter,  GtkTreeIter *parent);
		gtk_tree_store_append(gtkTreeStore, 
			iter.getTreeIterStruct(), 
			(parent is null) ? null : parent.getTreeIterStruct());
		return iter;
	}
code: end

outFile: TreeStore


###########################################################
### Menus, Combo Box, Toolbar #############################
###########################################################

file: GtkComboBox.html

struct: GtkComboBox
class: ComboBox
implements: CellLayoutIF
import: atk.ObjectAtk
structWrap: AtkObject* ObjectAtk
prefix: gtk_combo_box_
prefix: gtk_
#noprefix: gtk_combo_box_new_text
#noprefix: gtk_combo_box_append_text
#noprefix: gtk_combo_box_insert_text
#noprefix: gtk_combo_box_prepend_text
#noprefix: gtk_combo_box_remove_text
import: glib.Str
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gtk.CellRenderer
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

nocode: gtk_combo_box_new
nocode:gtk_combo_box_new_text

code: start

	private int count = 0;
	public int maxCount = 0;
	

	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkComboBox);

	/**
	 * Creates a new empty GtkComboBox.
	 * If text is true then
	 * constructs a new text combo box, which is a
	 * GtkComboBox just displaying strings. If you use this function to create
	 * a text combo box, you should only manipulate its data source with the
	 * following convenience functions: gtk_combo_box_append_text(),
	 * gtk_combo_box_insert_text(), gtk_combo_box_prepend_text() and
	 * gtk_combo_box_remove_text().
	 * Returns:
	 *  A new GtkComboBox.
	 * Since 2.4
	 */
	public this (bit text=true)
	{
		if ( text )
		{
			// GtkWidget* gtk_combo_box_new_text (void);
			this(cast(GtkComboBox*)gtk_combo_box_new_text() );
		}
		else
		{
			// GtkWidget* gtk_combo_box_new (void);
			this(cast(GtkComboBox*)gtk_combo_box_new() );
		}
	}

	public void setActiveText(char[] text, bool insert=false)
	{
		int currActive = getActive();
		int active = 0;
		setActive(active);
		bool found = false;
		while ( !found && active==getActive)
		{
			found = text==getActiveText();
			++active;
		}
		if ( !found )
		{
			if ( insert )
			{
				appendText(text);
				setActive(active);
			}
			else
			{
				//setActive(currActive);
				setActive(-1);
			}
		}
	}


	int getIndex(char[] text)
	{
		TreeIter iter = new TreeIter();
		TreeModel model = getModel();
		iter.setModel(model);
		int index = 0;
		bit found = false;
		bit end = false;
		if ( model.getIterFirst(iter) )
		{
			while ( !end && iter !is  null && !found )
			{
				found = iter.getValueString(0) == text;
				if ( !found )
				{
					end = !model.iterNext(iter);
					++index;
				}
			}
		}
		else
		{
			end = true;
		}
		return end ? -1 : index;
	}

	void prependOrReplaceText(char[] text)
	{
		int index = getIndex(text);
		if ( index > 0 )
		{
			removeText(index);
			prependText(text);
		}
		else if ( index == -1 )
		{
			prependText(text);
		}
	}


code: end
outFile: ComboBox

#struct: GtkComboBox
#class: ComboBoxText
#import: atk.ObjectAtk
#structWrap: AtkObject* ObjectAtk
#filterIn: gtk_combo_box_new_text
#filterIn: gtk_combo_box_append_text
#filterIn: gtk_combo_box_insert_text
#filterIn: gtk_combo_box_prepend_text
#filterIn: gtk_combo_box_remove_text
#strictPrefix: Y
#outFile: ComboBoxText

file: GtkComboBoxEntry.html

struct: GtkComboBoxEntry
class: ComboBoxEntry
implements: CellLayoutIF
prefix: gtk_combo_box_entry_
#noprefix: gtk_combo_box_entry_new_text
#noprefix: gtk_combo_box_append_text
#noprefix: gtk_combo_box_insert_text
#noprefix: gtk_combo_box_prepend_text
#noprefix: gtk_combo_box_remove_text
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModel
import: glib.Str
import: gtk.CellRenderer
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

nocode: gtk_combo_box_entry_new
nocode: gtk_combo_box_entry_new_text

code: start

	mixin CellLayoutT!(GtkComboBoxEntry);
	/**
	 * Creates a new GtkComboBoxEntry which has a GtkEntry as child. After
	 * construction, you should set a model using gtk_combo_box_set_model() and a
	 * text_column * using gtk_combo_box_entry_set_text_column().
	 * Returns:
	 *  A new GtkComboBoxEntry.
	 * Since 2.4
	 */
	public this (bit text=true)
	{
		if ( text )
		{
			// GtkWidget* gtk_combo_box_entry_new_text (void);
			this(cast(GtkComboBoxEntry*)gtk_combo_box_entry_new_text() );
		}
		else
		{
			// GtkWidget* gtk_combo_box_entry_new (void);
			this(cast(GtkComboBoxEntry*)gtk_combo_box_entry_new() );
		}
		
	}
code: end
outFile: ComboBoxEntry


#struct: GtkComboBoxEntry
#class: ComboBoxEntryText
#filterIn: gtk_combo_box_entry_new_text
#filterIn: gtk_combo_box_append_text
#filterIn: gtk_combo_box_insert_text
#filterIn: gtk_combo_box_prepend_text
#filterIn: gtk_combo_box_remove_text
#strictPrefix: Y
#outFile: ComboBoxEntryText

file: GtkMenu.html
struct: GtkMenu
class: Menu
prefix: gtk_menu_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListG
structWrap: GList* ListG
import: gtk.MenuItem

code: start
	public void append(Widget widget)
	{
		super.append(widget);
	}

	/**
	 * Popups up this menu
	 * @param button ??? you can pass a button number here
	 * @param activateTime ??? you can pass the time from an event here
	 */
	void popup(guint button, guint32 activateTime)
	{
		popup(null, null, null, null, button, activateTime);
	}
	
	/**
	 * Creates and append a submenu to this menu.
	 * This menu item that actualy has the sub menu is also created.
	 * @param label the sub menu item label
	 * @return the new menu
	 */
	Menu appendSubmenu(char[] label)
	{
		MenuItem item = new MenuItem(label);
		append(item);
		Menu submenu = new Menu();
		item.setSubmenu(submenu);
		return submenu;
	}

	void appendSubmenu(char[] label, Menu submenu)
	{
		MenuItem item = new MenuItem(label);
		append(item);
		item.setSubmenu(submenu);
	}

	Menu prependSubmenu(char[] label)
	{
		MenuItem item = new MenuItem(label);
		prepend(item);
		Menu submenu = new Menu();
		item.setSubmenu(submenu);
		return submenu;
	}


code: end
outFile: Menu

file: GtkMenuBar.html
struct: GtkMenuBar
class: MenuBar
prefix: gtk_menu_bar_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Menu;
import: gtk.MenuItem;
structWrap: GtkMenu* Menu
structWrap: GtkMenuItem* MenuItem
code: start
	Menu append(char[] label, bool rightJustify=false)
	{
		MenuItem item = new MenuItem(label);
		super.append(item);
		item.setRightJustified(rightJustify);
		Menu menu= new Menu();
		item.setSubmenu(menu);
		return menu;
	}

	public void append(Widget widget)
	{
		super.append(widget);
	}
code: end
outFile: MenuBar

file: GtkMenuItem.html
struct: GtkMenuItem
class: MenuItem
prefix: gtk_menu_item_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
# method conflict with parent method
nocode: gtk_menu_item_activate
nocode: gtk_menu_item_new_with_label
nocode: gtk_menu_item_new_with_mnemonic
# replace the method
# TODO create a method rename instead of replacing the entire code
code: start
	
	/** store the action code passed in by the applcation */
	private char[] actionLabel;
	
	/** Gets the application set action code */
	public char[] getActionName()
	{
		if ( actionLabel is null )
		{
			actionLabel = "";
		}
		return actionLabel;
	}
	
	/**
	 * Creates a new menu item with a label and a listener and a action.
	 * used for backward compatibily with DUI.
	 */
	this(char[] label, void delegate(MenuItem)dlg, char[] action)
	{
		this(label);
		this.actionLabel = action;
		addOnActivate(dlg);
	}
	

	
	/**
	 * Creates a new Item associated with a "activate" delegate and with a action code
	 */
	public this(void delegate(MenuItem) dlg, char[] label, char[] action, bit mnemonic=true)
	{
		this(label, mnemonic);
		this.actionLabel = action;
		addOnActivate(dlg);
	}

	/**
	 * Creates a new Item associated with a "activate" delegate
	 */
	public this(void delegate(MenuItem) dlg, char[] label, bit mnemonic=true)
	{
		this(label, mnemonic);
		addOnActivate(dlg);
	}

	/**
	 * Creates a new GtkMenuItem whose child is a GtkLabel.
	 * If mnemonic is true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the menu item.
	 * label:
	 * the text for the label
	 * Returns:
	 * the newly created GtkMenuItem
	 */
	public this (char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_menu_item_new_with_mnemonic (const gchar *label);
			this(cast(GtkMenuItem*)gtk_menu_item_new_with_mnemonic(Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_menu_item_new_with_label (const gchar *label);
			this(cast(GtkMenuItem*)gtk_menu_item_new_with_label(Str.toStringz(label)) );
		}
		setName(label);
	}

	/**
	 * Emits the "activate" signal on the given item
	 * menu_item:
	 * the menu item
	 */
	public void itemActivate()
	{
		// void gtk_menu_item_activate (GtkMenuItem *menu_item);
		gtk_menu_item_activate(gtkMenuItem);
	}
	
code: end
outFile: MenuItem

file: GtkMenuShell.html
struct: GtkMenuShell
class: MenuShell
prefix: gtk_menu_shell_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: MenuShell

file: GtkImageMenuItem.html
struct: GtkImageMenuItem
class: ImageMenuItem
prefix: gtk_image_menu_item_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup

nocode: gtk_image_menu_item_new_with_label
nocode: gtk_image_menu_item_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkImageMenuItem containing a label.
	 * If mnemonic it true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the menu item.
	 * label:
	 *  the text of the menu item.
	 * Returns:
	 *  a new GtkImageMenuItem.
	 */
	public this (char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_image_menu_item_new_with_mnemonic  (const gchar *label);
			this(cast(GtkImageMenuItem*)gtk_image_menu_item_new_with_mnemonic(Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_image_menu_item_new_with_label  (const gchar *label);
			this(cast(GtkImageMenuItem*)gtk_image_menu_item_new_with_label(Str.toStringz(label)) );
		}
	}
code: end

outFile: ImageMenuItem

file: GtkRadioMenuItem.html
struct: GtkRadioMenuItem
class: RadioMenuItem
prefix: gtk_radio_menu_item_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG

nocode: gtk_radio_menu_item_new_with_label
nocode: gtk_radio_menu_item_new_with_mnemonic
nocode: gtk_radio_menu_item_new_with_mnemonic_from_widget
nocode: gtk_radio_menu_item_new_with_label_from_widget

code: start
	/**
	 * Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
	 * The new GtkRadioMenuItem is added to the same group as group.
	 * If mnemonic is true the label will be
	 * created using gtk_label_new_with_mnemonic(), so underscores in label
	 * indicate the mnemonic for the menu item.
	 * group:
	 *  an existing GtkRadioMenuItem
	 * label:
	 *  the text for the label
	 * Returns:
	 *  The new GtkRadioMenuItem
	 * Since 2.4
	 */
	public this (RadioMenuItem radioMenuItem, char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_menu_item_new_with_mnemonic_from_widget  (GtkRadioMenuItem *group,  const gchar *label);
			this(cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_mnemonic_from_widget(
				radioMenuItem.getRadioMenuItemStruct(), Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_radio_menu_item_new_with_label_from_widget  (GtkRadioMenuItem *group,  const gchar *label);
			this(cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_label_from_widget(
				radioMenuItem.getRadioMenuItemStruct(), Str.toStringz(label)) );
		}
	}
	
	/**
	 * Creates a new GtkRadioMenuItem containing a label. T
	 * The new GtkRadioMenuItem is added to the same group as group.
	 * group:
	 *  An existing GtkRadioMenuItem
	 * label:
	 *  the text of the button, with an underscore in front of the
	 *  mnemonic character
	 * Returns:
	 *  The new GtkRadioMenuItem
	 * Since 2.4
	 */
	public this (char[] label)
	{
	}
	
	/**
	 * Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
	 * If mnemonic is true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the menu item.
	 * group:
	 * the group to which the radio menu item is to be attached
	 * label:
	 * the text for the label
	 * Returns:
	 * a new GtkRadioMenuItem
	 */
	public this (ListSG group, char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_menu_item_new_with_mnemonic  (GSList *group,  const gchar *label);
			this(cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_mnemonic(
				group is null ? null : group.getListSGStruct(), Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_radio_menu_item_new_with_label  (GSList *group,  const gchar *label);
			this(cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_label(
				group is null ? null : group.getListSGStruct(), Str.toStringz(label)) );
		}
	}
code: end
outFile: RadioMenuItem

file: GtkCheckMenuItem.html
struct: GtkCheckMenuItem
class: CheckMenuItem
prefix: gtk_check_menu_item_
prefix: gtk_
import: glib.Str

nocode: gtk_check_menu_item_new_with_label
nocode: gtk_check_menu_item_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkCheckMenuItem with a label.
	 * If mnemonic it true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the menu item.
	 * label:
	 * the string to use for the label.
	 * Returns:
	 * a new GtkCheckMenuItem.
	 */
	public this (char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_check_menu_item_new_with_mnemonic  (const gchar *label);
			this(cast(GtkCheckMenuItem*)gtk_check_menu_item_new_with_mnemonic(Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_check_menu_item_new_with_label  (const gchar *label);
			this(cast(GtkCheckMenuItem*)gtk_check_menu_item_new_with_label(Str.toStringz(label)) );
		}
	}
code: end

outFile: CheckMenuItem

file: GtkSeparatorMenuItem.html
struct: GtkSeparatorMenuItem
class: SeparatorMenuItem
prefix: gtk_separator_menu_item_
prefix: gtk_
outFile: SeparatorMenuItem

file: GtkTearoffMenuItem.html
struct: GtkTearoffMenuItem
class: TearoffMenuItem
prefix: gtk_tearoff_menu_item_
prefix: gtk_
outFile: TearoffMenuItem

file: GtkToolbar.html
struct: GtkToolbar
class: Toolbar
prefix: gtk_toolbar_
prefix: gtk_
import: glib.Str
import: gtk.Widget
import: gtk.Button
import: gtk.ToolItem
structWrap: GtkWidget* Widget
nocode: gtk_toolbar_get_style

code: start
	/**
	 * Retrieves whether the toolbar has text, icons, or both . See
	 * gtk_toolbar_set_style().
	 * toolbar:
	 *  a GtkToolbar
	 * Returns:
	 *  the current style of toolbar
	 */
	public GtkToolbarStyle toolbarGetStyle()
	{
		// GtkToolbarStyle gtk_toolbar_get_style (GtkToolbar *toolbar);
		return gtk_toolbar_get_style(gtkToolbar);
	}

	public void insert (ToolItem toolItem, int pos=-1)
	{
		gtk_toolbar_insert(gtkToolbar, toolItem.getToolItemStruct(), pos);
	}
	
	public Widget insertStock(StockID stockId, char[] tooltipText, char[] tooltipPrivateText, GtkSignalFunc callback, void* userData, int position)
	{
		return insertStock(getId(stockId), tooltipText, tooltipPrivateText, callback, userData, position);
	}

	public Widget insertStock(char[] stockId, char[] tooltipText, char[] tooltipPrivateText, int position)
	{
		return insertStock(stockId, tooltipText, tooltipPrivateText, null, null, position);
	}
	
	public Widget insertStock(StockID stockId, char[] tooltipText, char[] tooltipPrivateText, int position)
	{
		return insertStock(getId(stockId), tooltipText, tooltipPrivateText, null, null, position);
	}

	Button insertButton(StockID stockID,
			char[] tooltipText, char[] tooltipPrivateText,
			gint position)
	{
		Button button = new Button(
				cast(GtkButton*)gtk_toolbar_insert_stock(
					gtkToolbar,
					Str.toStringz(StockDesc[stockID]),
					Str.toStringz(tooltipText), 
					Str.toStringz(tooltipPrivateText), 
					null, null, 
					position)
			);
		return button;
	}

code: end
outFile: Toolbar

file: GtkToolItem.html
struct: GtkToolItem
class: ToolItem
prefix: gtk_tool_item_
prefix: gtk_
import: glib.Str
import: gtk.Tooltips
structWrap: GtkTooltips* Tooltips
import: gtk.Widget
structWrap: GtkWidget* Widget

code: start
	/**
	 * Sets this widget tooltip
	 * @param tipText the tooltip
	 * @param tipPrivate a private text
	 */
	void setTooltip(char[] tipText, char[] tipPrivate)
	{
		Tooltips tt = new Tooltips();
		tt.setTip(this, tipText, tipPrivate);
	}

code: end

outFile: ToolItem

file: GtkSeparatorToolItem.html
struct: GtkSeparatorToolItem
ctorStruct: GtkToolItem
class: SeparatorToolItem
prefix: gtk_separator_tool_item_
prefix: gtk_
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
outFile: SeparatorToolItem

file: GtkToolButton.html
struct: GtkToolButton
ctorStruct: GtkToolItem
class: ToolButton
prefix: gtk_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
#structWrap: GtkToolItem* ToolItem
import: gtk.Widget
structWrap: GtkWidget* Widget

code: start
	/** An arbitrary string to be used by the application */
	private char[] action;

	public void setActionName(char[] action)
	{
		this.action = action.dup;
	}
	
	public char[] getActionName()
	{
		return action;
	}

	public this (StockID stockID)
	{
		this(StockDesc[stockID]);
	}
	

code: end

outFile: ToolButton

file: GtkMenuToolButton.html
struct: GtkMenuToolButton
ctorStruct: GtkToolItem
class: MenuToolButton
prefix: gtk_menu_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Tooltips
structWrap: GtkTooltips* Tooltips
import: gtk.Menu


nocode: gtk_menu_tool_button_new
nocode: gtk_menu_tool_button_new_from_stock
nocode: gtk_menu_tool_button_get_menu

code: start
	/**
	 * Creates a new GtkMenuToolButton using icon_widget as icon and
	 * label as label.
	 * icon_widget:
	 *  a widget that will be used as icon widget, or NULL
	 * label:
	 *  a string that will be used as label, or NULL
	 * Returns:
	 *  the new GtkMenuToolButton
	 * Since 2.6
	 */
	public this(Widget iconWidget, char[] label)
	{
		// GtkToolItem* gtk_menu_tool_button_new (GtkWidget *icon_widget,  const gchar *label);
		this( cast(GtkMenuToolButton*)gtk_menu_tool_button_new(
			(iconWidget is null) ? null : iconWidget.getWidgetStruct(), 
			Str.toStringz(label))
		);
	}
	
	/**
	 * Creates a new GtkMenuToolButton.
	 * The new GtkMenuToolButton will contain an icon and label from
	 * the stock item indicated by stock_id.
	 * stock_id:
	 *  the name of a stock item
	 * Returns:
	 *  the new GtkMenuToolButton
	 * Since 2.6
	 */
	public this(StockID stockId)
	{
		// GtkToolItem* gtk_menu_tool_button_new_from_stock  (const gchar *stock_id);
		this( 
			cast(GtkMenuToolButton*)gtk_menu_tool_button_new_from_stock(
			Str.toStringz(StockDesc[stockId]))
		);
	}

	/**
	 * Gets the GtkMenu associated with GtkMenuToolButton.
	 * button:
	 *  a GtkMenuToolButton
	 * Returns:
	 *  the GtkMenu associated with GtkMenuToolButton
	 * Since 2.6
	 */
	public Menu getMenu()
	{
		// GtkWidget* gtk_menu_tool_button_get_menu (GtkMenuToolButton *button);
		return new Menu( cast(GtkMenu*)gtk_menu_tool_button_get_menu(gtkMenuToolButton) );
	}
	
	/**
	 * Sets the toolTip for the arrow
	 * Params:
	 *    	tipText = 	
	 *    	tipPrivate = 	
	 */
	public void setArrowTooltip(char[] tipText, char[] tipPrivate)
	{
		Tooltips tooltips = new Tooltips();
		gtk_menu_tool_button_set_arrow_tooltip(
			gtkMenuToolButton, 
			(tooltips is null) ? null : tooltips.getTooltipsStruct(), 
			Str.toStringz(tipText), 
			Str.toStringz(tipPrivate)
			);
	}

code: end

outFile: MenuToolButton

file: GtkToggleToolButton.html
struct: GtkToggleToolButton
ctorStruct: GtkToolItem
class: ToggleToolButton
prefix: gtk_toggle_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
outFile: ToggleToolButton

file: GtkRadioToolButton.html
struct: GtkRadioToolButton
ctorStruct: GtkToolItem
class: RadioToolButton
prefix: gtk_radio_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: glib.ListSG
structWrap: GSList* ListSG
outFile: RadioToolButton

###########################################################
### Action-based menus and toolbars #######################
###########################################################

file: GtkUIManager.html
struct: GtkUIManager
class: UIManager
prefix: gtk_ui_manager_
prefix: gtk_
import: glib.Str
import: gtk.ActionGroup
structWrap: GtkActionGroup* ActionGroup
import: glib.ListG
structWrap: GList* ListG
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG
structWrap: GSList* ListSG
import: gtk.Action
structWrap: GtkAction* Action
outFile: UIManager

file: GtkActionGroup.html
struct: GtkActionGroup
class: ActionGroup
prefix: gtk_action_group_
prefix: gtk_
import: glib.Str
import: gtk.Action
structWrap: GtkAction* Action
import: glib.ListG
structWrap: GList* ListG
#import: gtk.ActionEntry
#structWrap: GtkActionEntry* ActionEntry
#import: gtk.ToggleActionEntry
#structWrap: GtkToggleActionEntry* ToggleActionEntry
#import: gtk.RadioActionEntry
#structWrap: GtkRadioActionEntry* RadioActionEntry
outFile: ActionGroup

file: GtkAction.html
struct: GtkAction
class: Action
prefix: gtk_action_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG
structWrap: GSList* ListSG
import: gobject.Closure
structWrap: GClosure* Closure
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
outFile: Action

file: GtkToggleAction.html
struct: GtkToggleAction
class: ToggleAction
prefix: gtk_toggle_action_
prefix: gtk_
import: glib.Str
outFile: ToggleAction

file: GtkRadioAction.html
struct: GtkRadioAction
class: RadioAction
prefix: gtk_radio_action_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG
outFile: RadioAction

###########################################################
###  Selectors (File/Font/Color/Input Devices) ############
###########################################################

file: GtkColorButton.html
struct: GtkColorButton
class: ColorButton
prefix: gtk_color_button_
prefix: gtk_
import: glib.Str
import: gdk.Color
structWrap: GdkColor* Color
outFile: ColorButton

file: GtkColorSelection.html
struct: GtkColorSelection
class: ColorSelection
prefix: gtk_color_selection_
prefix: gtk_
import: glib.Str
import: gdk.Color
structWrap: GdkColor* Color
outFile: ColorSelection

file: GtkColorSelectionDialog.html
struct: GtkColorSelectionDialog
class: ColorSelectionDialog
prefix: gtk_color_selection_dialog_
prefix: gtk_
import: glib.Str
outFile: ColorSelectionDialog

file: GtkFileSelection.html
struct: GtkFileSelection
class: FileSelection
prefix: gtk_file_selection_
prefix: gtk_
import: glib.Str
outFile: FileSelection

file: GtkFileChooser.html
struct: GtkFileChooser
class: FileChooser
prefix: gtk_file_chooser_
prefix: gtk_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window
import: glib.ListSG
structWrap: GSList* ListSG
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.FileFilter
structWrap: GtkFileFilter* FileFilter
outFile: FileChooser

file: GtkFileChooserButton.html
struct: GtkFileChooserButton
class: FileChooserButton
prefix: gtk_file_chooser_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG;
import: gtk.Widget;
import: gtk.FileFilter;
import: gtk.FileChooser;

code: start

	private FileChooser fileChooser;

	public FileChooser getFileChooser()
	{
		if ( fileChooser is null )
		{
			fileChooser = new FileChooser(cast(GtkFileChooser*)getFileChooserButtonStruct());
		}
		return fileChooser;
	}
code: end
outFile: FileChooserButton

file: GtkFileChooserDialog.html
struct: GtkFileChooserDialog
class: FileChooserDialog
prefix: gtk_file_chooser_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window
import: glib.ListSG;
import: gtk.Widget;
import: gtk.FileFilter;
import: gtk.FileChooser;
import: glib.Str
nocode: gtk_file_chooser_dialog_new
nocode: gtk_file_chooser_dialog_new_with_backend

code: start

	private FileChooser fileChooser;

	public FileChooser getFileChooser()
	{
		if ( fileChooser is null )
		{
			fileChooser = new FileChooser(cast(GtkFileChooser*)getFileChooserDialogStruct());
		}
		return fileChooser;
	}

	/**
	 * Creates a new GtkFileChooserDialog. This function is analogous to
	 * gtk_dialog_new_with_buttons().
	 * title:
	 *  Title of the dialog, or NULL
	 * parent:
	 *  Transient parent of the dialog, or NULL
	 * action:
	 *  Open or save mode for the dialog
	 * first_button_text:
	 *  stock ID or text to go in the first button, or NULL
	 * ...:
	 *  response ID for the first button, then additional (button, id) pairs, ending with NULL
	 * Returns:
	 *  a new GtkFileChooserDialog
	 * Since 2.4
	 */
	this(char[] title, Window parent, FileChooserAction action,  char[][] buttonsText=null, ResponseType[] responses=null)
	{
		if ( buttonsText  is  null )
		{
			buttonsText ~= "OK";
			buttonsText ~= "Cancel";
		}
		if ( responses  is  null )
		{
			responses ~= ResponseType.GTK_RESPONSE_OK;
			responses ~= ResponseType.GTK_RESPONSE_CANCEL;
		}

		this(
			cast(GtkFileChooserDialog*)gtk_file_chooser_dialog_new(
				Str.toStringz(title),
				parent.getWindowStruct(),
				action,
				null,
				0));
		addButtons(buttonsText, responses);
	}

	/**
	 * Creates a new GtkFileChooserDialog with a specified backend. This is
	 * especially useful if you use gtk_file_chooser_set_local_only() to allow
	 * non-local files and you use a more expressive vfs, such as gnome-vfs,
	 * to load files.
	 * title:
	 *  Title of the dialog, or NULL
	 * parent:
	 *  Transient parent of the dialog, or NULL
	 * action:
	 *  Open or save mode for the dialog
	 * backend:
	 *  The name of the specific filesystem backend to use.
	 * first_button_text:
	 *  stock ID or text to go in the first button, or NULL
	 * ...:
	 *  response ID for the first button, then additional (button, id) pairs, ending with NULL
	 * Returns:
	 *  a new GtkFileChooserDialog
	 * Since 2.4
	 * See Also
	 *  GtkFileChooser, GtkDialog
	 */
	public this (char[] title, Window parent, GtkFileChooserAction action, char[] backend,  char[][] buttonsText=null, ResponseType[] responses=null)
	{
		// GtkWidget* gtk_file_chooser_dialog_new_with_backend  (const gchar *title,  GtkWindow *parent,  GtkFileChooserAction action,  const gchar *backend,  const gchar *first_button_text,  ...);
		this(
			cast(GtkFileChooserDialog*)gtk_file_chooser_dialog_new_with_backend(
				Str.toStringz(title), 
				parent.getWindowStruct(), 
				action, 
				Str.toStringz(backend), 
				null,
				0
				));
		if ( buttonsText  is  null )
		{
			buttonsText ~= "OK";
			buttonsText ~= "Cancel";
		}
		if ( responses  is  null )
		{
			responses ~= ResponseType.GTK_RESPONSE_OK;
			responses ~= ResponseType.GTK_RESPONSE_CANCEL;
		}

		addButtons(buttonsText, responses);
	}
	
//	this(char[] title, Window parent, FileChooserAction action,  StockID[] buttons=null, ResponseType[] responses=null)
//	{
//		if ( buttons  is  null )
//		{
//			buttons ~= STOCK_OK;
//			buttons ~= STOCK_CANCEL;
//		}
//		if ( responses  is  null )
//		{
//			responses ~= ResponseType.GTK_RESPONSE_OK;
//			responses ~= ResponseType.GTK_RESPONSE_CANCEL;
//		}
//
//		this(gtk_file_chooser_dialog_new(
//				title.toStringz(),
//				parent.getWindowStruct(),
//				action,
//				null,
//				0));
//		addButtons(buttons, responses);
//	}

code: end
outFile: FileChooserDialog

file: GtkFileChooserWidget.html
struct: GtkFileChooserWidget
class: FileChooserWidget
prefix: gtk_file_chooser_widget_
prefix: gtk_
import: glib.Str
import: glib.ListSG;
import: gtk.Widget;
import: gtk.FileFilter;
import: gtk.FileChooser;

code: start
	private FileChooser fileChooser;

	public FileChooser getFileChooser()
	{
		if ( fileChooser is null )
		{
			fileChooser = new FileChooser(cast(GtkFileChooser*)getFileChooserWidgetStruct());
		}
		return fileChooser;
	}
code: end
outFile: FileChooserWidget

file: gtk-gtkfilefilter.html
struct:  GtkFileFilter
class: FileFilter
prefix: gtk_file_filter_
prefix: gtk_
import: glib.Str
outFile: FileFilter

file: GtkFontButton.html
struct: GtkFontButton
class: FontButton
prefix: gtk_font_button_
prefix: gtk_
import: glib.Str
outFile: FontButton

file: GtkFontSelection.html
struct: GtkFontSelection
class: FontSelection
prefix: gtk_font_selection_
prefix: gtk_
import: glib.Str
import: gdk.Font
structWrap: GdkFont* Font
outFile: FontSelection

file: GtkFontSelectionDialog.html
struct: GtkFontSelectionDialog
class: FontSelectionDialog
prefix: gtk_font_selection_dialog_
prefix: gtk_
import: glib.Str
import: gdk.Font
structWrap: GdkFont* Font
outFile: FontSelectionDialog

file: GtkInputDialog.html
struct: GtkInputDialog
class: InputDialog
prefix: gtk_input_dialog_
prefix: gtk_
outFile: InputDialog

###########################################################
### Layout Containers #####################################
###########################################################

file: GtkAlignment.html
struct: GtkAlignment
class: Alignment
prefix: gtk_alignment_
prefix: gtk_
import: gtk.Widget

code: start
	public static Alignment center(Widget widget)
	{
		Alignment a = new Alignment(0.5, 0.5, 0, 0);
		a.add(widget);
		return a;
	}
	
	public static Alignment north(Widget widget)
	{
		Alignment a = new Alignment(0.5, 0.0, 0, 0);
		a.add(widget);
		return a;
	}
	
	public static Alignment south(Widget widget)
	{
		Alignment a = new Alignment(0.5, 1.0, 0, 0);
		a.add(widget);
		return a;
	}
	
	public static Alignment east(Widget widget)
	{
		Alignment a = new Alignment(1.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}
	
	public static Alignment west(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}
	
code: end
outFile: Alignment

file: GtkAspectFrame.html
struct: GtkAspectFrame
class: AspectFrame
prefix: gtk_aspect_frame_
prefix: gtk_
import: glib.Str
outFile: AspectFrame

file: GtkHBox.html
struct: GtkHBox
class: HBox
prefix: gtk_hbox_
prefix: gtk_
outFile: HBox

file: GtkVBox.html
struct: GtkVBox
class: VBox
prefix: gtk_vbox_
prefix: gtk_
outFile: VBox

file: GtkHButtonBox.html
struct: GtkHButtonBox
class: HButtonBox
prefix: gtk_hbutton_box_
prefix: gtk_
code: start
	/**
	 * Creates a new HButtonBox and sets comon parameters
	 */
	static ButtonBox createActionBox()
	{
		ButtonBox bBox = new HButtonBox();
		bBox.setLayout(ButtonBoxStyle.END);
		bBox.setBorderWidth(5);
		bBox.setSpacing(7);
		return bBox;
	}
	
code: end
outFile: HButtonBox

file: GtkVButtonBox.html
struct: GtkVButtonBox
class: VButtonBox
prefix: gtk_vbutton_box_
prefix: gtk_
code: start
    /**
     * Creates a new vertical button box and sets standart values for it's comon parameters
     * @return a new vertical button box
     */
	static ButtonBox createActionBox()
	{
		ButtonBox bBox = new VButtonBox();
		bBox.setLayout(ButtonBoxStyle.START);
		bBox.setBorderWidth(5);
		bBox.setSpacing(7);
		return bBox;
	}
code: end
outFile: VButtonBox

file: GtkFixed.html
struct: GtkFixed
class: Fixed
prefix: gtk_fixed_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Fixed

file: GtkHPaned.html
struct: GtkHPaned
class: HPaned
prefix: gtk_hpaned_
prefix: gtk_
structWrap: GtkWidget* Widget
import: gtk.Widget

code: start
	/**
	 * Creates a new HPaned and adds two widgets as it's children
	 * @param child1
	 * @param child2
	 */
	this(Widget child1, Widget child2)
	{
		this();
		add1(child1);
		add2(child2);
	}
	
code: end
outFile: HPaned

file: GtkVPaned.html
struct: GtkVPaned
class: VPaned
prefix: gtk_vpaned_
prefix: gtk_
import: gtk.Widget

code: start
	/**
	 * Creates a new HPaned and adds two widgets as it's children
	 * @param child1
	 * @param child2
	 */
	this(Widget child1, Widget child2)
	{
		this();
		add1(child1);
		add2(child2);
	}
	
code: end
outFile: VPaned

file: GtkLayout.html
struct: GtkLayout
class: Layout
prefix: gtk_layout_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Layout

file: GtkNotebook.html
struct: GtkNotebook
class: Notebook
prefix: gtk_notebook_
prefix: gtk_
import: glib.Str
import: gtk.Label
import: gtk.Widget
structWrap: GtkWidget* Widget
code: start
/** The GtkNotebookTab is not documented */
public enum GtkNotebookTab
{
  GTK_NOTEBOOK_TAB_FIRST,
  GTK_NOTEBOOK_TAB_LAST
}
alias GtkNotebookTab NotebookTab;

	/**
	 * Append a page with a widget and a text for a label
	 */
	public int appendPage(Widget child, char[] tabLabel)
	{
		return appendPage(child, new Label(tabLabel));
	}

	void setCurrentPage(Widget child)
	{
		gtk_notebook_set_current_page(gtkNotebook,gtk_notebook_page_num(gtkNotebook, child.getWidgetStruct()));
	}
	


code: end
outFile: Notebook

file: GtkTable.html
struct: GtkTable
class: Table
import: gtk.Widget
structWrap: GtkWidget* Widget
prefix: gtk_table_
prefix: gtk_

nocode: gtk_table_new

code: start

	int row;
	int col;
	int maxRows;
	int maxCols;

	public AttachOptions defaultXOption = AttachOptions.SHRINK;
	public AttachOptions defaultYOption = AttachOptions.SHRINK;
	
	/**
	 * Removes all children and resizes the table to 1,1
	 */
	void removeAll()
	{
		super.removeAll();
		resize(1,1);
	}
	
	/**
	 * Used to create a new table widget. An initial size must be given by
	 * specifying how many rows and columns the table should have, although
	 * this can be changed later with gtk_table_resize(). rows and columns
	 * must both be in the range 0 .. 65535.
	 * rows:
	 * The number of rows the new table should have.
	 * columns:
	 * The number of columns the new table should have.
	 * homogeneous:
	 * If set to TRUE, all table cells are resized to the size of the cell
	 * containing the largest widget.
	 * Returns:
	 * A pointer to the the newly created table widget.
	 */
	public this (uint rows, uint columns, int homogeneous)
	{
		// GtkWidget* gtk_table_new (guint rows,  guint columns,  gboolean homogeneous);
		this(cast(GtkTable*)gtk_table_new(rows, columns, homogeneous) );
		row = 0;
		col = 0;
		maxRows = rows;
		maxCols = columns;
	}
	

	/**
	 * Attach a new widget creating a new row if necessary
	 */
	void attach(Widget child)
	{
		attach(child, col, col + 1, row, row + 1,
				defaultXOption, defaultYOption,
				getDefaultColSpacing(), getDefaultRowSpacing());
		++col;
		if (col >= maxCols)
		{
			col = 0;
			++row;
		}
	}


code: end
outFile: Table

file: GtkExpander.html
struct: GtkExpander
class: Expander
prefix: gtk_expander_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_expander_new
nocode: gtk_expander_new_with_mnemonic

code: start
	/**
	 * Creates a new expander using label as the text of the label.
	 * If mnemonic os true 
	 * If characters in label are preceded by an underscore, they are underlined.
	 * If you need a literal underscore character in a label, use '__' (two
	 * underscores). The first underlined character represents a keyboard
	 * accelerator called a mnemonic.
	 * label:
	 *  the text of the label
	 * Returns:
	 *  a new GtkExpander widget.
	 * Since 2.4
	 */
	public this (char[] label, bit mnemonic=true)
	{
		if ( mnemonic )
		{
			// GtkWidget* gtk_expander_new_with_mnemonic (const gchar *label);
			this(cast(GtkExpander*)gtk_expander_new_with_mnemonic(Str.toStringz(label)) );
		}
		else
		{
			// GtkWidget* gtk_expander_new (const gchar *label);
			this(cast(GtkExpander*)gtk_expander_new(Str.toStringz(label)) );
		}
	}
code: end

outFile: Expander

###########################################################
### Ornaments #############################################
###########################################################

file: GtkFrame.html
struct: GtkFrame
class: Frame
prefix: gtk_frame_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
code: start
/**
 * Creates frame with label and set it's child widget
 */
public this(Widget widget, char[] label)
{
	this(label);
	add(widget);
}
code: end

outFile: Frame

file: GtkHSeparator.html
struct: GtkHSeparator
class: HSeparator
prefix: gtk_hseparator_
prefix: gtk_
outFile: HSeparator

file: GtkVSeparator.html
struct: GtkVSeparator
class: VSeparator
prefix: gtk_vseparator_
prefix: gtk_
outFile: VSeparator

###########################################################
### Scrolling #############################################
###########################################################

file: GtkHScrollbar.html
struct: GtkHScrollbar
class: HScrollbar
prefix: gtk_hscrollbar_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: HScrollbar

file: GtkVScrollbar.html
struct: GtkVScrollbar
class: VScrollbar
prefix: gtk_vscrollbar_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: VScrollbar

file: GtkScrolledWindow.html
struct: GtkScrolledWindow
class: ScrolledWindow
prefix: gtk_scrolled_window_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment


nocode: gtk_scrolled_window_new
code: start

	public this()
	{
		this(null, null);
	}
	
	public this(Widget widget)
	{
		this();
		addWithViewport(widget);
	}
	
	/**
	 * Creates a new scrolled window. The two arguments are the scrolled
	 * window's adjustments; these will be shared with the scrollbars and the
	 * child widget to keep the bars in sync with the child. Usually you want
	 * to pass NULL for the adjustments, which will cause the scrolled window
	 * to create them for you.
	 * hadjustment:
	 * Horizontal adjustment.
	 * vadjustment:
	 * Vertical adjustment.
	 * Returns:
	 * New scrolled window.
	 */
	public this (Adjustment hadjustment, Adjustment vadjustment)
	{
		// GtkWidget* gtk_scrolled_window_new (GtkAdjustment *hadjustment,  GtkAdjustment *vadjustment);
		this(cast(GtkScrolledWindow*)gtk_scrolled_window_new(
				hadjustment is null ? null : hadjustment.getAdjustmentStruct(), 
				vadjustment is null ? null : vadjustment.getAdjustmentStruct()) 
				);
	}

	/**
	 * Creates a new Scrolled window and set the policy type
	 * @param hPolicy the horizontal policy
	 * @param vPolicy the vertical policy
	 */
	this(PolicyType hPolicy, PolicyType vPolicy)
	{
		this();
		setPolicy(hPolicy, vPolicy);
	}
code: end
outFile: ScrolledWindow

###########################################################
### Miscellaneous #########################################
###########################################################

file: GtkAdjustment.html
struct: GtkAdjustment
class: Adjustment
prefix: gtk_adjustment_
prefix: gtk_
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
outFile: Adjustment

file: GtkArrow.html
struct: GtkArrow
class: Arrow
prefix: gtk_arrow_
prefix: gtk_
outFile: Arrow

file: GtkCalendar.html
struct: GtkCalendar
class: Calendar
prefix: gtk_calendar_
prefix: gtk_
outFile: Calendar

file: GtkDrawingArea.html
struct: GtkDrawingArea
class: DrawingArea
prefix: gtk_drawing_area_
prefix: gtk_

code: start
	/**
	 * Create a new DrawingArea and sets the SizeRequest
	 * Params:
	 *    	width = 	
	 *    	height = 	
	 * Returns: 
	 */
	this(int width, int height)
	{
		this();
		setSizeRequest(width, height);
	}
	
code: end

outFile: DrawingArea

file: GtkEventBox.html
struct: GtkEventBox
class: EventBox
prefix: gtk_event_box_
prefix: gtk_
outFile: EventBox

file: GtkHandleBox.html
struct: GtkHandleBox
class: HandleBox
prefix: gtk_handle_box_
prefix: gtk_
outFile: HandleBox

file: GtkIMContextSimple.html
struct: GtkIMContextSimple
class: IMContextSimple
prefix: gtk_im_context_simple_
prefix: gtk_
import: gtk.IMContext
structWrap: GtkIMContext* IMContext
outFile: IMContextSimple

file: GtkIMMulticontext.html
struct: GtkIMMulticontext
class: IMMulticontext
prefix: gtk_im_multicontext_
prefix: gtk_
import: gtk.IMContext
structWrap: GtkIMContext* IMContext
import: gtk.MenuShell
structWrap: GtkMenuShell* MenuShell
outFile: IMMulticontext

file: GtkSizeGroup.html
struct: GtkSizeGroup
class: SizeGroup
prefix: gtk_size_group_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: SizeGroup

file: GtkTooltips.html
struct: GtkTooltips
class: Tooltips
prefix: gtk_tooltips_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gtk.TooltipsData
#structWrap: GtkTooltipsData* TooltipsData
import: gtk.Window
structWrap: GtkWindow* Window
outFile: Tooltips

file: GtkViewport.html
struct: GtkViewport
class: Viewport
prefix: gtk_viewport_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: Viewport

file: GtkAccessible.html
struct: GtkAccessible
class: Accessible
prefix: gtk_accessible_
prefix: gtk_
outFile: Accessible

###########################################################
### Abstract Base Classes #################################
###########################################################

file: GtkBin.html
struct: GtkBin
class: Bin
prefix: gtk_bin_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Bin

file: GtkBox.html
struct: GtkBox
class: Box
import: gtk.Widget
structWrap: GtkWidget* Widget
prefix: gtk_box_
prefix: gtk_
#import: gtk.PackType
#structWrap: GtkPackType* PackType
outFile: Box

file: GtkButtonBox.html
struct: GtkButtonBox
class: ButtonBox
prefix: gtk_button_box_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Button
import: gtk.HButtonBox
import: gtk.VButtonBox
code: start
	static ButtonBox createActionBox(
			void delegate(Button) onClicked, 
			StockID[] stocks, 
			char[][] actions,
			bool vertical=false
		)
	{
		ButtonBox bBox;
		if ( vertical )
		{
			bBox = VButtonBox.createActionBox();
		}
		else
		{
			bBox = HButtonBox.createActionBox();
		}

		Button button;
		for( int i=0 ; i<stocks.length && i<actions.length ; i++)
		{
			button =  new Button(stocks[i]);
			bBox.packEnd(button, false, false, 7);
			button.setActionName(actions[i]);
			button.addOnClicked(onClicked);
		}
		return bBox;
	}
	
	static ButtonBox createOkBox(void delegate(Button) onClicked)
	{
		static StockID[] stocks = [StockID.OK];
		char[][] actions;
		actions ~= "action.ok";
		return createActionBox(onClicked, stocks, actions);
	}

	static ButtonBox createOkCancelBox(void delegate(Button) onClicked)
	{
		static StockID[] stocks = [StockID.OK, StockID.CANCEL];
		char[][] actions;
		actions ~= "action.ok";
		actions ~= "action.cancel";
		return createActionBox(onClicked, stocks, actions);
	}
code: end
outFile: ButtonBox

file: GtkContainer.html
struct: GtkContainer
class: Container
structWrap: GtkContainerClass* Container
structWrap: GtkWidget* Widget
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
prefix: gtk_container_
prefix: gtk_
import: glib.ListG
structWrap: GList* ListG
import: gobject.Value
structWrap: GValue* Value
#import: gdk.EventExpose
#structWrap: GdkEventExpose* EventExpose
#import: gobject.ParamSpec
#structWrap: GParamSpec* ParamSpec
#import: g.ObjectClass
#structWrap: GObjectClass* ObjectClass

code: start

	/**
	 * Removes all widgets from the container
	 */
	void removeAll()
	{
		ListG children = new ListG(gtk_container_get_children(getContainerStruct()));
		for ( int i=children.length()-1 ; i>=0 ; i-- )
		{
			gtk_container_remove(getContainerStruct(), cast(GtkWidget*)children.nthData(i));
		}
	}

code: end
outFile: Container

file: GtkItem.html
struct: GtkItem
class: Item
prefix: gtk_item_
prefix: gtk_
outFile: Item

file: GtkMisc.html
struct: GtkMisc
class: Misc
prefix: gtk_misc_
prefix: gtk_
outFile: Misc

file: GtkObject.html
struct: GtkObject
class: ObjectGtk
prefix: gtk_object_
prefix: gtk_
import: glib.Str

code: star
	public static char[] getId(StockID id)
	{
		return StockDesc[id];
	}
code: end

outFile: ObjectGtk

file: GtkPaned.html
struct: GtkPaned
class: Paned
prefix: gtk_paned_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget

code: start

	public void add(Widget child1, Widget child2)
	{
		add1(child1);
		add2(child2);
	}

code: end
outFile: Paned

file: GtkRange.html
struct: GtkRange
class: Range
prefix: gtk_range_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: Range

file: GtkScale.html
struct: GtkScale
class: Scale
prefix: gtk_scale_
prefix: gtk_
outFile: Scale

file: GtkScrollbar.html
struct: GtkScrollbar
class: Scrollbar
prefix: gtk_scrollbar_
prefix: gtk_
outFile: Scrollbar

file: GtkSeparator.html
struct: GtkSeparator
class: Separator
prefix: gtk_separator
prefix: gtk_
outFile: Separator

file: GtkWidget.html
struct: GtkWidget
class: Widget
import: glib.Str
import: atk.ObjectAtk
structWrap: AtkObject* ObjectAtk
prefix: gtk_widget_
prefix: gtk_
# This function is exactly the same as calling g_object_ref(), and exists mostly for historical reasons.
noprefix: gtk_widget_ref
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
#import: gtk.Requisition
#structWrap: GtkRequisition* Requisition
#import: gtk.Allocation
#structWrap: GtkAllocation* Allocation
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListG
structWrap: GList* ListG
import: gdk.Event
structWrap: GdkEvent* Event
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Visual
structWrap: GdkVisual* Visual
import: gtk.Style
structWrap: GtkStyle* Style
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gtk.RcStyle
structWrap: GtkRcStyle* RcStyle
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
#import: gtk.WidgetClass
#structWrap: GtkWidgetClass* WidgetClass
#import: g.ParamSpec
#structWrap: GParamSpec* ParamSpec
import: gdk.Region
structWrap: GdkRegion* Region
import: gobject.Value
structWrap: GValue* Value
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gtk.Clipboard
structWrap: GtkClipboard* Clipboard
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtkc.gdk
import: gdk.Cursor

import: pango.PgLayout
structWrap: PangoLayout* PgLayout
import: pango.PgContext
structWrap: PangoContext* PgContext
import: pango.PgFontDescription
structWrap: PangoFontDescription* PgFontDescription
import: gdk.Drawable
import: gtk.Tooltips

code: start

	public int getWidth()
	{
		int width;
		gtk_widget_get_size_request(gtkWidget, &width, null);
		return width;
	}
	public int getHeight()
	{
		int height;
		gtk_widget_get_size_request(gtkWidget, null, &height);
		return height;
	}
	
	/**
	 * Gets the drawable for this widget
	 * return:
	 * 		The drawable for this widget
	 */
	Drawable getDrawable()
	{
		
//		ubyte *p = cast(ubyte*)getStruct();
//
//		for ( int i=0 ; i<120 ; i+=4 )
//		{
//			printf("(%d) %X %x %x %x %x\n", i,p,*(p+0), *(p+1), *(p+2), *(p+3));
//			p+=4;
//		}
//		
//		int* pt =cast(int*)getStruct();
//		
//		printf("pt=%X strcut=%X\n", pt, getStruct());
//		printf("*pt=%X\n", *pt);
//		pt+=52/4;
//		printf("pt+52=%X strcut.window=%X\n", pt, getWidgetStruct().window);
//		printf("*pt+52=%X\n", *pt);
//		
//		//return new Drawable(cast(GdkDrawable*)(getWidgetStruct().window));
		int* pt =cast(int*)getStruct();
		pt += 52/4;
		return new Drawable(cast(GdkDrawable*)(*pt));
	}
/**
	 * Gets the Window for this widget
	 * return:
	 * 		The window for this widget
	 */
	Window getWindow()
	{
		
		//		ubyte *p = cast(ubyte*)getStruct();
		//
		//		for ( int i=0 ; i<120 ; i+=4 )
		//		{
			//			printf("(%d) %X %x %x %x %x\n", i,p,*(p+0), *(p+1), *(p+2), *(p+3));
			//			p+=4;
		//		}
		//
		//		int* pt =cast(int*)getStruct();
		//
		//		printf("pt=%X strcut=%X\n", pt, getStruct());
		//		printf("*pt=%X\n", *pt);
		//		pt+=52/4;
		//		printf("pt+52=%X strcut.window=%X\n", pt, getWidgetStruct().window);
		//		printf("*pt+52=%X\n", *pt);
		//
		//		//return new Drawable(cast(GdkDrawable*)(getWidgetStruct().window));
		int* pt =cast(int*)getStruct();
		pt += 52/4;
		return new Window(cast(GdkWindow*)(*pt));
	}
	/**
	 * Sets  the cursor.
	 * @param cursor the new cursor
	 * \bug the cursor changes to the parent widget also
	 */
	void setCursor(Cursor cursor)
	{
		int* pt =cast(int*)getStruct();
		pt += 52/4;
		gdk_window_set_cursor(cast(GdkWindow*)(*pt), cursor.getCursorStruct());
	}
	
	/**
	 * Resets the cursor.
	 * don't know if this is implemented by GTK+. Seems that it's not
	 * \bug does nothing
	 */
	public void resetCursor()
	{
		int* pt =cast(int*)getStruct();
		pt += 52/4;
		gdk_window_set_cursor(cast(GdkWindow*)(*pt), null);
	}

	/**
	 * Modifies the font for this widget.
	 * This just calls modifyFont(new PgFontDescription(PgFontDescription.fromString(family ~ " " ~ size)));
	 */
	public void modifyFont(char[] family, int size)
	{
		if ( size < 0 ) size = -size;	// hack to workaround leds bug - TO BE REMOVED
		modifyFont(new PgFontDescription(
			PgFontDescription.fromString(
			family ~ " " ~ std.string.toString(size))));
	}
	
	/**
	 * Sets this widget tooltip
	 * @param tipText the tooltip
	 * @param tipPrivate a private text
	 */
	void setTooltip(char[] tipText, char[] tipPrivate)
	{
		Tooltips tt = new Tooltips();
		tt.setTip(this, tipText, tipPrivate);
	}



code: end

outFile: Widget

file: GtkIMContext.html
struct: GtkIMContext
class: IMContext
prefix: gtk_im_context_
prefix: gtk_
import: glib.Str
import: gdk.Window
structWrap: GdkWindow* Window
#import: gtk.EventKey
#structWrap: GdkEventKey* EventKey
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
outFile: IMContext

###########################################################
### Cross-process Embedding ###############################
###########################################################

file: GtkPlug.html
struct: GtkPlug
class: Plug
prefix: gtk_plug_
prefix: gtk_
import: gdk.Display
structWrap: GdkDisplay* Display
outFile: Plug

file: GtkSocket.html
struct: GtkSocket
class: Socket
prefix: gtk_socket_
prefix: gtk_
outFile: Socket

###########################################################
### Special-purpose features ##############################
###########################################################

file: GtkCurve.html
struct: GtkCurve
class: Curve
prefix: gtk_curve_
prefix: gtk_
outFile: Curve

file: GtkGammaCurve.html
struct: GtkGammaCurve
class: GammaCurve
prefix: gtk_gamma_curve_
prefix: gtk_
outFile: GammaCurve

file: GtkRuler.html
struct: GtkRuler
class: Ruler
prefix: gtk_ruler_
prefix: gtk_
outFile: Ruler

file: GtkHRuler.html
struct: GtkHRuler
class: HRuler
prefix: gtk_hruler_
prefix: gtk_
outFile: HRuler

file: GtkVRuler.html
struct: GtkVRuler
class: VRuler
prefix: gtk_vruler_
prefix: gtk_
outFile: VRuler

###########################################################
### Deprecated ############################################
###########################################################

#file: GtkCList.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkCTree.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkCombo.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

file: GtkItemFactory.html
struct: GtkItemFactory
class: ItemFactory
prefix: gtk_item_factory_
prefix: gtk_
noprefix: gtk_item_factory_create_menu_entries
import: glib.Str
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.ItemFactory
structWrap: GtkItemFactory* ItemFactory
#import: gtk.ItemFactoryEntry
#structWrap: GtkItemFactoryEntry* ItemFactoryEntry
outFile: ItemFactory

#file: GtkList.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkListItem.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkOldEditable.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkOptionMenu.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkPixmap.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkPreview.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkText.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: gtkTipsQuery.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkTree.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkTreeItem.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

file: GtkProgress.html
struct: GtkProgress
class: Progress
prefix: gtk_progress_
prefix: gtk_
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: Progress
