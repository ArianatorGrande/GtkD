/*
 * This file is part of dui.
 * 
 * dui is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 * 
 * dui is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with dui; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/*
 * - automatically generated by leds
 * - pos-processed by Antonio Monteiro
 */

module dglib.ErrorG;

private import def.Types;
//private import def.Constants;

extern(C)
{

public:
	struct GError
	{
		GQuark       domain;
		gint         code;
		gchar       *message;
	}

private:
	GError*     g_error_new                     (GQuark domain,gint code,  gchar *format,...);
	GError*     g_error_new_literal             (GQuark domain,gint code,  gchar *message);
	void        g_error_free                    (GError *error);
	GError*     g_error_copy                    (  GError *error);
	gboolean    g_error_matches                 (  GError *error,GQuark domain,gint code);
	void        g_set_error                     (GError **err,GQuark domain,gint code,  gchar *format,...);
	void        g_propagate_error               (GError **dest,GError *src);
	void        g_clear_error                   (GError **err);
}

/**
 * GLib provides a standard method of reporting errors from a called function to
 * the calling code. (This is the same problem solved by exceptions in other
 * languages.) It's important to understand that this method is both a data type
 * (the GError object) and a set of rules. If you use GError incorrectly, then
 * your code will not properly interoperate with other code that uses GError, and
 * users of your API will probably get confused. First and foremost: GError
 * should only be used to report recoverable runtime errors, never to report
 * programming errors. If the programmer has screwed up, then you should use
 * g_warning(), g_return_if_fail(), g_assert(), g_error(), or some similar
 * facility. (Incidentally, remember that the g_error() function should only be
 * used for programming errors, it should not be used to print any error
 * reportable via GError.) Examples of recoverable runtime errors are "file not
 * found" or "failed to parse input." Examples of programming errors are "NULL
 * passed to strcmp()" or "attempted to free the same pointer twice." These two
 * kinds of errors are fundamentally different: runtime errors should be handled
 * or reported to the user, programming errors should be eliminated by fixing the
 * bug in the program. This is why most functions in GLib and GTK+ do not use the
 * GError facility.
 */
public
class ErrorG
{
	
	private import dool.String;

	protected:

	GError* gError;

	public:

	GError* getG()
	{
		return gError;
	}
	GError** getGA()
	{
		return &gError;
	}
	
	/**
	 * Creates a ErrorG from a GtkErrorG
	 * @param *gtkWidget the gtk struct address pointer
	 * @return 
	 */
    this(GError* gError)
    {
        this.gError = gError;
    }

	this()
	{
		gError = new GError;
		//clearError();
	}

	/**
	 * Creates a new GError with the given domain and code, and a message formatted with format.
	 * @param domain error domain
	 * @param code error code
	 * @param format printf()-style format for error message
	 * @param ... parameters for message format
	 * @return a new GError
	 */
	//this(Quark domain, gint code, String  format, ... )
	//{
	//	this(g_error_new(domain.getG(), code, format.toStringz(), null));
	//}


	/**
	 * Creates a new GError; unlike gErrorNew(), message is not a printf()-style format string. Use this function if
	 * message contains text you don't have control over, that could include printf() escape sequences.
	 * @param domain error domain
	 * @param code error code
	 * @param message error message
	 * @return a new GError
	 */
	//this(Quark domain, gint code, String  message)
	//{
	//	this(g_error_new_literal(domain.getG(), code, message.toStringz()));
	//}


	/**
	 * Frees a GError and associated resources.
	 * @param error a GError
	 */
	void free()
	{
		g_error_free(gError);
	}


	/**
	 * Makes a copy of error.
	 * @param error a GError
	 * @return a new GError
	 */
	ErrorG copy()
	{
		return new ErrorG(g_error_copy(gError));
	}


	/**
	 * Returns TRUE if error matches domain and code, FALSE otherwise.
	 * @param error a GError
	 * @param domain an error domain
	 * @param code an error code
	 * @return whether error has domain and code
	 */
	//bit matches(Quark domain, gint code)
	//{
	//	return g_error_matches(gError, domain.getG(), code) == 0 ? false : true;
	//}


	/**
	 * Does nothing if err is NULL; if err is non-NULL, then *err must be NULL. A new GError is created and assigned
	 * to *err.
	 * @param err a return location for a GError, or NULL
	 * @param domain error domain
	 * @param code error code
	 * @param format printf()-style format
	 * @param ... args for format
	 */
	//void setError(Quark domain, gint code, String  format, ... )
	//{
	//	g_set_error(gError, domain.getG(), code, format).toStringz(, null);
	//}


	/**
	 * If dest is NULL, free src; otherwise, moves src into *dest. *dest must be NULL.
	 * @param dest error return location
	 * @param src error to move into the return location
	 */
	void propagateError(ErrorG src)
	{
		g_propagate_error(&gError, src.getG());
	}


	/**
	 * If err is NULL, does nothing. If err is non-NULL, calls gErrorFree() on *err and sets *err to NULL.
	 * @param err a GError return locatio
	 */
	void clearError()
	{
		g_clear_error(&gError);
	}


	String getMessage()
	{
		return new String(gError.message);
	}

	int getCode()
	{
		return gError.code;
	}
	
	void dump()
	{
		printf("ErrorG (%d) = %s\n", getCode(), getMessage().toStringz());
	}

}
